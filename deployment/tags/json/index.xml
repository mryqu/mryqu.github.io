<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Json on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/json/</link>
    <description>Recent content in Json on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 23 Oct 2017 05:47:58 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/json/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>学习一下TOML</title>
      <link>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Btoml/</link>
      <pubDate>Mon, 23 Oct 2017 05:47:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Btoml/</guid>
      <description>TOML（Tom&amp;rsquo;s Obvious, Minimal Language）是（GitHub的联合创始人及前CEO）Tom Preston-Werner于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。它是YAML和JSON的替代品，跟JSON相对对人类更友好，比YAML更简单。 GitHub：toml-lang/toml
Learn toml in Y minutes
[](https://www.cnblogs.com/unqiang/p/6399136.html)
TOML简介 （转）</description>
    </item>
    
    <item>
      <title>YAML</title>
      <link>https://mryqu.github.io/post/yaml/</link>
      <pubDate>Fri, 22 May 2015 22:55:52 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/yaml/</guid>
      <description>简介 YAML是一个可读性高的数据序列化格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。ClarkEvans在2001年首次发表了这种语言 ，另外Ingy d?t Net与OrenBen-Kiki也是这语言的共同设计者。目前已经有数种编程语言或脚本语言支援（或者说解析）这种语言。 _YAML_是&amp;rdquo;YAML Ain&amp;rsquo;t a Markup Language&amp;rdquo;（YAML不是一种标记语言）的递回缩写。在开发的这种语言时，_YAML_的意思其实是：&amp;rdquo;Yet Another Markup Language&amp;rdquo;（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重新命名。
功能 YAML的语法和其他高阶语言类似，并且可以简单表达列表、哈希表，标量等数据形式。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、调试时的转储内容、文件标题（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达分层数据，不过也有紧凑的语法可以表示关联性数据。由于YAML使用空白字符和分行来分隔数据，使得它特别适合用grep／Python／Perl／Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构时会变得复杂而难以辨认。
范例 简单的文件 数据结构可以用类似大纲的缩排方式呈现
--- receipt: Oz-Ware Purchase Invoice date: 2007-08-06 customer: given: Dorothy family: Gale items: - part_no: A4786 descrip: Water Bucket (Filled) price: 1.47 quantity: 4 - part_no: E1628 descrip: High Heeled &amp;quot;Ruby&amp;quot; Slippers price: 100.27 quantity: 1 bill-to: &amp;amp;id001 street: | 123 Tornado Alley Suite 16 city: East Westville state: KS ship-to: *id001 specialDelivery: &amp;gt; Follow the Yellow Brick Road to the Emerald City.</description>
    </item>
    
    <item>
      <title>玩玩GoJS BPMN样例</title>
      <link>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9gojs_bpmn%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Wed, 25 Feb 2015 19:50:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9gojs_bpmn%E6%A0%B7%E4%BE%8B/</guid>
      <description>玩一玩GoJS，GoJS是Northwoods Software的产品。Northwoods Software创立于1995年，专注于交互图控件和类库。旗下四款产品： - GoJS：用于在HTML上创建交互图的纯javaSCript库，GoJS支持复杂的模板定义和数据绑定。 - GoDiagram：用于WinForms的.NET图控件。 - GoXam：用于WPF/Silverlight的图控件。 - JGo：用于Swing/SWT中创建交互图的java库。
试了一下GoJS的BPMN样例，很容易导出SVG或PNG/JPEG等格式的图像数据。其中： - 由于GoJS是经过代码混淆的，不能对makeSVG方法进行确定的分析，大概是采用HTMLCanvasElement.getContext(&amp;lsquo;2d&amp;rsquo;).drawImage(&amp;hellip;).getImageData(&amp;hellip;)获得的 - makeImage和makeImageData方法通过HTMLCanvasElement.toDataURL()方法实现的
在控制台执行window.myDiagram.model.toJson()，返回如下结果：
{ &amp;quot;class&amp;quot;: &amp;quot;go.GraphLinksModel&amp;quot;, &amp;quot;linkFromPortIdProperty&amp;quot;: &amp;quot;fromPort&amp;quot;, &amp;quot;linkToPortIdProperty&amp;quot;: &amp;quot;toPort&amp;quot;, &amp;quot;nodeDataArray&amp;quot;: [ { &amp;quot;category&amp;quot;: &amp;quot;activity&amp;quot;, &amp;quot;item&amp;quot;: &amp;quot;User task&amp;quot;, &amp;quot;key&amp;quot;: 7, &amp;quot;loc&amp;quot;: &amp;quot;388.33645784919577 140.35229369949943&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;User Task&amp;quot;, &amp;quot;taskType&amp;quot;: 2, &amp;quot;boundaryEventArray&amp;quot;: [ ], &amp;quot;size&amp;quot;: &amp;quot;120 80&amp;quot; }, { &amp;quot;category&amp;quot;: &amp;quot;event&amp;quot;, &amp;quot;item&amp;quot;: &amp;quot;End&amp;quot;, &amp;quot;key&amp;quot;: 104, &amp;quot;loc&amp;quot;: &amp;quot;569.86545617508 140.90913111767696&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;End&amp;quot;, &amp;quot;eventType&amp;quot;: 1, &amp;quot;eventDimension&amp;quot;: 8 }, { &amp;quot;category&amp;quot;: &amp;quot;event&amp;quot;, &amp;quot;item&amp;quot;: &amp;quot;start&amp;quot;, &amp;quot;key&amp;quot;: 101, &amp;quot;loc&amp;quot;: &amp;quot;183.</description>
    </item>
    
    <item>
      <title>Spring3 REST can&#39;t solve list of object generated by Javascript</title>
      <link>https://mryqu.github.io/post/spring3_rest_cant_solve_list_of_object_generated_by_javascript/</link>
      <pubDate>Fri, 16 Jan 2015 21:21:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spring3_rest_cant_solve_list_of_object_generated_by_javascript/</guid>
      <description>最近遭遇Spring3REST无法解析对象数组这么一个问题。为了排除客户端Javascript代码嫌疑，我通过GET操作从Spring RestfulWeb服务获取一个复杂对象，然后通过POST操作将其原封不动返给Spring Restful Web服务，问题依旧重现。
客户端代码 var meatadata=&#39;[{&amp;quot;varName&amp;quot;:&amp;quot;id&amp;quot;,&amp;quot;varTitle&amp;quot;:&amp;quot;The Id&amp;quot;,&amp;quot;varIndex&amp;quot;:1},{&amp;quot;varName&amp;quot;:&amp;quot;name&amp;quot;,&amp;quot;varTitle&amp;quot;:&amp;quot;The Name&amp;quot;,&amp;quot;varIndex&amp;quot;:2},{&amp;quot;varName&amp;quot;:&amp;quot;age&amp;quot;,&amp;quot;varTitle&amp;quot;:&amp;quot;The Age&amp;quot;,&amp;quot;varIndex&amp;quot;:3}]&#39;; $.ajax({ url: &amp;quot;configure&amp;quot;, type: &amp;quot;POST&amp;quot;, data: metadata, dataType: &amp;quot;json&amp;quot;, contentType: &amp;quot;application/json&amp;quot;, success: function (res) { $(&#39;#cfgContent&#39;).text(JSON.stringify(res)); $(&#39;#cfgError&#39;).text(&amp;quot;&amp;quot;); }, error: function (res) { $(&#39;#cfgContent&#39;).text(&amp;quot;&amp;quot;); $(&#39;#cfgError&#39;).text(res.responseText); } });  中间层代码 package com.yqu.rest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; import java.util.ArrayList; import java.util.List; @RestController public class ConfigurationController { @RequestMapping(value = &amp;quot;/&amp;quot;, method = RequestMethod.GET) public ModelAndView home(Model m){ System.</description>
    </item>
    
    <item>
      <title>Spring REST can&#39;t solve nested object array generated by JavaScript</title>
      <link>https://mryqu.github.io/post/spring_rest_cant_solve_nested_object_array_generated_by_javascript/</link>
      <pubDate>Thu, 15 Jan 2015 21:27:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spring_rest_cant_solve_nested_object_array_generated_by_javascript/</guid>
      <description>最近遭遇SpringREST无法解析嵌套对象数组这么一个问题。为了排除客户端Javascript代码嫌疑，我通过GET操作从Spring RestfulWeb服务获取一个复杂对象，然后通过POST操作将其原封不动返给Spring Restful Web服务，问题依旧重现。
所操作的复杂对象 客户端POST响应 中间层代码 package com.yqu.rest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; import java.util.ArrayList; import java.util.List; @RestController public class ConfigurationController { @RequestMapping(value = &amp;quot;/&amp;quot;, method = RequestMethod.GET) public ModelAndView home(Model m){ System.out.println(&amp;quot;home&amp;quot;); return new ModelAndView(&amp;quot;index&amp;quot;); } @RequestMapping(value = &amp;quot;/configure&amp;quot;, method = RequestMethod.GET) public @ResponseBody SheetVO getConfiguration() { List columns = new ArrayList(); columns.add(new ColumnVO(&amp;quot;id&amp;quot;,&amp;quot;The Id&amp;quot;,1)); columns.add(new ColumnVO(&amp;quot;name&amp;quot;,&amp;quot;The Name&amp;quot;,2)); columns.add(new ColumnVO(&amp;quot;age&amp;quot;,&amp;quot;The Age&amp;quot;,3)); SheetVO metadata = new SheetVO(SheetVO.</description>
    </item>
    
    <item>
      <title>[OpenUI5] MVC示例:JSView embedding JSVIEW</title>
      <link>https://mryqu.github.io/post/openui5_mvc%E7%A4%BA%E4%BE%8Bjsview_embedding_jsview/</link>
      <pubDate>Wed, 07 Jan 2015 23:47:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/openui5_mvc%E7%A4%BA%E4%BE%8Bjsview_embedding_jsview/</guid>
      <description>OpenUI5 SDK的演示程序里面有一个视图嵌套另外一个视图，但是通过Componentcontainer和Component.js实现的。一直对视图直接嵌套另外一个视图觉得理所当然但是有点顾虑，此外也担心外层视图的数据模型如何传递给内部视图。当然内外两层视图可以使用不同的数据模型，但是如果不知道共享一份数据视图是否可行?
在jsbin上做了一个示例：http://jsbin.com/jirogo/1/edit?html,output，结果显示担忧是多余的</description>
    </item>
    
    <item>
      <title>[JavaScript] 字符串与JSON数据互转</title>
      <link>https://mryqu.github.io/post/javascript_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Ejson%E6%95%B0%E6%8D%AE%E4%BA%92%E8%BD%AC/</link>
      <pubDate>Tue, 26 Aug 2014 06:06:26 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/javascript_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Ejson%E6%95%B0%E6%8D%AE%E4%BA%92%E8%BD%AC/</guid>
      <description>字符串-&amp;gt;JSON 转换方法有3种:
使用浏览器内置window.JSON.parse方法 原生方法，速度最快，首选方案。老版本浏览器不支持。
|浏览器|支持版本 |&amp;mdash; |Chrome|(Yes) |Firefox (Gecko)|3.5 (1.9.1) |Internet Explorer|8.0 |Opera|10.5 |Safari|4.0 |Android|(Yes) |Chrome for Android|(Yes) |Firefox Mobile (Gecko)|1.0 (1.0) |IE Mobile|(Yes) ||Opera Mobile|(Yes) |Safari Mobile|(Yes)
使用Funtion()构造函数 较eval_r()快
使用 eval_r() 函数 功能强大，能解析任何JS代码,但是执行效率和安全性都不好示例代码：
var jsonStr = &#39;{&amp;quot;name&amp;quot;:&amp;quot;kxeg&amp;quot;,&amp;quot;data&amp;quot;:[{&amp;quot;key&amp;quot;:&amp;quot;Alpha&amp;quot;,&amp;quot;color&amp;quot;:&amp;quot;lightblue&amp;quot;},{&amp;quot;key&amp;quot;:&amp;quot;Beta&amp;quot;,&amp;quot;color&amp;quot;:&amp;quot;orange&amp;quot;}]}&#39;; //JSON.parse() if (window &amp;amp;&amp;amp; window.JSON &amp;amp;&amp;amp; window.JSON.parse) jsonObj1 = window.JSON.parse(jsonStr); //Function 创建一个闭包,返回一个json数据对象 jsonObj2 = (new Function(&#39;return&#39;+jsonStr))(); //eval_r() jsonObj3 = eval_r(&#39;(&#39;+jsonStr+&#39;)&#39;);  JSON-&amp;gt;字符串 使用浏览器内置window.JSON.stringify方法
参考 js中字符串数据转为json对象的方法
MDN：JSON</description>
    </item>
    
  </channel>
</rss>
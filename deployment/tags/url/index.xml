<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Url on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/url/</link>
    <description>Recent content in Url on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 09 Jan 2016 05:44:05 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/url/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Facebook API Endpoint URL</title>
      <link>https://mryqu.github.io/post/facebook_api_endpoint_url/</link>
      <pubDate>Sat, 09 Jan 2016 05:44:05 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/facebook_api_endpoint_url/</guid>
      <description>阅读com.restfb.DefaultFacebookClient中的createEndpointForApiCall方法，发现有四种端点URL。
端点URL地址说明FACEBOOK_READ_ONLY_ENDPOINT_URL
https://api-read.facebook.com/method从官方PHP客户端抓取的只读函数列表，当API请求为如下列表项，使用该只读端点URL。
admin.getallocationadmin.getapppropertiesadmin.getbannedusersadmin.getlivestreamvialinkadmin.getmetricsadmin.getrestrictioninfoapplication.getpublicinfoauth.getapppublickeyauth.getsessionauth.getsignedpublicsessiondatacomments.getconnect.getunconnectedfriendscountdashboard.getactivitydashboard.getcountdashboard.getglobalnewsdashboard.getnewsdashboard.multigetcountdashboard.multigetnewsdata.getcookiesevents.getevents.getmembersfbml.getcustomtagsfeed.getappfriendstoriesfeed.getregisteredtemplatebundlebyidfeed.getregisteredtemplatebundlesfql.multiqueryfql.queryfriends.arefriendsfriends.getfriends.getappusersfriends.getlistsfriends.getmutualfriendsgifts.getgroups.getgroups.getmembersintl.gettranslationslinks.getnotes.getnotifications.getpages.getinfopages.isadminpages.isappaddedpages.isfanpermissions.checkavailableapiaccesspermissions.checkgrantedapiaccessphotos.getphotos.getalbumsphotos.gettagsprofile.getinfoprofile.getinfooptionsstream.getstream.getcommentsstream.getfiltersusers.getinfousers.getloggedinuserusers.getstandardinfousers.hasapppermissionusers.isappuserusers.isverifiedvideo.getuploadlimitsFACEBOOK_GRAPH_VIDEO_ENDPOINT_URL
https://graph-video.facebook.comAPI请求以/video或/advideos结尾FACEBOOK_ENDPOINT_URL
https://www.facebook.comAPI请求以logout.php结尾FACEBOOK_GRAPH_ENDPOINT_URL
https://graph.facebook.com不满足上述三种的默认URL </description>
    </item>
    
    <item>
      <title>[Spring Boot] Use alwaysUseFullPath for Spring MVC URL mapping</title>
      <link>https://mryqu.github.io/post/spring_boot_use_alwaysusefullpath_for_spring_mvc_url_mapping/</link>
      <pubDate>Thu, 03 Dec 2015 06:38:56 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spring_boot_use_alwaysusefullpath_for_spring_mvc_url_mapping/</guid>
      <description>简介 SpringMVC的URL映射有一个控制路径匹配的参数alwaysUseFullPath。当它被设置为true后，总是使用当前servlet上下文中的全路径进行URL查找，否则使用当前servlet映射内的路径。默认为false。下面示例一下当一个请求的全路径通过servlet映射找到所服务的RequestDispatcherservelet后alwaysUseFullPath为false时URL映射表现：
         servlet mapping = &amp;ldquo;/*&amp;ldquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/test/a&amp;rdquo;   servlet mapping = &amp;ldquo;/&amp;rdquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/test/a&amp;rdquo;   servlet mapping = &amp;ldquo;/test/*&amp;ldquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/a&amp;rdquo;   servlet mapping = &amp;ldquo;/test&amp;rdquo;; request URI = &amp;ldquo;/test&amp;rdquo; -&amp;gt; &amp;ldquo;&amp;rdquo;   servlet mapping = &amp;ldquo;/*.test&amp;rdquo;; request URI = &amp;ldquo;/a.test&amp;rdquo; -&amp;gt; &amp;ldquo;&amp;rdquo;    从org.</description>
    </item>
    
    <item>
      <title>cURL速查表</title>
      <link>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Thu, 30 Apr 2015 06:16:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通訊协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。
请求多个资源curl http://api.test.com/pp/[123-321]
curl http://api.test.com/pp/{abc,def,ghi}/status允许重定向-L如果服务器返回3XX响应，使用-L选项可以让curl向新新地址发送请求。Cookies-b --cookie {name=data}发送原始Cookies或文件中的Cookies
范例：-b &#39;n1=v1; n2=v2&#39;-c / --cookie-jar {file name}将Cookies存入文件发送数据-d / --data {data}-d {data} 发送原始数据
-d {@filename} 发送文件中的数据。
如果不想对@进行解析，可以使用--data-raw。
JSON范例：
-d &#39;{&#34;firstName&#34;:&#34;yd&#34;, &#34;lastName&#34;:&#34;q&#34;}&#39;
原始数据范例：
-d &#39;name=yqu&#39; -d &#39;sex=male&#39;--data-ascii {data}等同于--data
--data-raw {data}几乎等同于--data，除了不对@进行解析。--data-binary {data}--data-binary {data} 发送原始二进制数据
--data-binary {@filename} 发送文件中的二进制数据。
在发送前对数据不做任何处理。发送表单-F / --form {name=content}以Content-Type: multipart/form-data方式发送数据
范例：
curl -F password=@/etc/passwd www.mypasswords.com允许&#34;不安全&#34;SSL-k / --insecure所有的SSL连接使用默认安装的CA证书捆绑试图保障其安全。除非使用-k/--insecure，否则所有被认为是“不安全”的连接将会失败。认证-u / --user {user:password}服务器认证
-U / --proxy-user {user:password}代理认证
代理-x / --proxyHTTP方法-X / --request {request}可以指定的方法为：POST、HEAD、PUT、GET、DELETE输出至文件-o / --output {file}输出到文件而不是标准输出输出至与远端文件同名的本地文件-O / --remote-name上传文件-T / --upload-file {file}curl -T &#34;</description>
    </item>
    
    <item>
      <title>Servlet URL映射模式</title>
      <link>https://mryqu.github.io/post/servlet_url%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Oct 2013 20:56:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/servlet_url%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>Servlet 2.5规范中的映射规则:  完全匹配URL 匹配通配符路径 匹配扩展名 匹配默认servlet  特殊URL模式: url-pattern:/* servlet上的/* 会压制所有其他servlet。无论什么请求都会被该servlet处理。这是一种不好的URL模式。通常，仅将/* 用于过滤器。它能通过调用FilterChain#doFilter()让请求继续由监听另外一个特定URL模式的任何servlet处理。
url-pattern:/ / 不会压制其他servlet。它仅会替换servlet容器内建的默认servlet，用于无法匹配任何已注册servlet的所有请求。一般仅调用在静态资源(CSS/JS/image/etc)和列举目录上。servlet容器内建默认servlet也能处理HTTP缓存请求、媒体（音视频）流和文件重新下载。由于必须负责默认servlet的所有任务，工作量不小，通常不会想要替换默认servlet。这也是一种不好的URL模式。关于为什么JSP页面不会调用这个servlet，是因为servlet容器的内建JSPservlet默认映射到*.jsp并被调用。
url-pattern: 这也有一个空字符串URL模式。当上下文根被请求时会被调用。这不同于welcome-file方法，因为它对任何子目录请求不会被调用，而welcome-file方法对任何局部有效但没有匹配上servlet的请求都会被调用。这更像需要“主页servlet”所要用到的URL模式。.</description>
    </item>
    
  </channel>
</rss>
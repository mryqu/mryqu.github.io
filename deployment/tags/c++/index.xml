<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 31 Jul 2017 05:46:44 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;] 优化twitcurl项目中的HMAC_SHA1</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</link>
      <pubDate>Mon, 31 Jul 2017 05:46:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</guid>
      <description>twitcurl开源项目中包含SHA1.cpp和HMAC_SHA1.cpp用于计算Twitter认证所需的HMAC-SHA1签名。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC_SHA1需要一个密钥，而SHA1不需要。HMAC_SHA1的公式为：SHA1(Key XOR opad, SHA1(Key XOR ipad, text)) 通过分析oauthlib.cpp和HMAC_SHA1.cpp可知： 1. 对于HMAC_SHA1算法，请求URL及参数信息作为文本输入，ConsumerSecret和AccessTokenSecret组合作为密钥输入； 2. 第一步：如果密钥输入大小超过64字节，则先做一次SHA1获取其摘要用于后继操作；否则直接使用密钥进行后继操作； 3. 第二步：密钥输入（/密钥输入摘要）XOR ipad（即0x36）； 4. 第三步：将上一步的[Key XOR ipad]和文本输入并入缓存AppendBuf1； 5. 第四步：使用上一步生成的缓存AppendBuf1一起进行SHA1以产生内部摘要； 6. 第五步：密钥输入（/密钥输入摘要）XOR opad（即0x5C）； 7. 第六步：将上一步的[Key XOR opad]和第四步产生的内部摘要并入缓存AppendBuf2； 8. 第七步：使用上一步生成的缓存AppendBuf2一起进行SHA1以产生外部摘要。
HMAC_SHA1.h中定义的AppendBuf1和AppendBuf2都有4K大小，合计8K。能不能省点空间呢？
下面我们可以看一个小示例：
char srcTest[] = &amp;quot;abcdef&amp;quot;; int srcTestL = strlen(srcTest); char srcTest1[] = &amp;quot;abc&amp;quot;; int srcTestL1 = strlen(srcTest1); char srcTest2[] = &amp;quot;def&amp;quot;; int srcTestL2 = strlen(srcTest2); unsigned char dst1[20] = &amp;quot;&amp;quot;; unsigned char dst2[20] = &amp;quot;&amp;quot;; CSHA1 sha1A = CSHA1(); sha1A.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Compile JsonCpp library using CMake</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_compile_jsoncpp_library_using_cmake/</link>
      <pubDate>Thu, 23 Mar 2017 06:14:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_compile_jsoncpp_library_using_cmake/</guid>
      <description>本文为升级JsonCpp库操作过程的备份笔记。
Linux/Unix平台 下载JsonCpp 从JsonCpp releases页面可知，当前最高版本为1.8.0。
wget https://github.com/open-source-parsers/jsoncpp/archive/1.8.0.tar.gz tar xzvf 1.8.0.tar.gz cd jsoncpp-1.8.0 mkdir build/release  升级gcc 这里我选择使用gcc 5:
sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-5 g++-5 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 1  升级cmake JsonCpp 1.8.0要求cmake&amp;gt;=3.1
sudo apt-get install software-properties-common sudo add-apt-repository ppa:george-edison55/cmake-3.x sudo apt-get update sudo apt-get upgrade cmake  编译JsonCpp cmake -DCMAKE_BUILD_TYPE=release -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G &amp;quot;Unix Makefiles&amp;quot; .</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Build JsonCpp library in Linux platform</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_build_jsoncpp_library_in_linux_platform/</link>
      <pubDate>Wed, 22 Mar 2017 05:47:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_build_jsoncpp_library_in_linux_platform/</guid>
      <description>wget https://github.com/open-source-parsers/jsoncpp/archive/1.8.0.tar.gz tar xzvf 1.8.0.tar.gz cd jsoncpp-1.8.0/src/lib_json g++ -g -std=c++11 -Wall -fPIC -c -I../../include json_reader.cpp json_value.cpp json_writer.cpp ar rvs libjsoncpp.a *.o g++ -g json_reader.o json_writer.o json_value.o -shared -o libjsoncpp.so  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 将JSON转成字符串</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E5%B0%86json%E8%BD%AC%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 26 Dec 2016 05:24:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E5%B0%86json%E8%BD%AC%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>需要将如下JSON字符串作为GoogleSheets API POST请求的消息体。打算使用JsonCpp实现。
{&amp;quot;majorDimension&amp;quot;:&amp;quot;ROWS&amp;quot;,&amp;quot;values&amp;quot;:[[&amp;quot;Name&amp;quot;,&amp;quot;Sex&amp;quot;,&amp;quot;Age&amp;quot;,&amp;quot;Height&amp;quot;,&amp;quot;Weight&amp;quot;],[&amp;quot;阿尔弗雷德&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;112.5&amp;quot;],[&amp;quot;爱丽丝&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;56.5&amp;quot;,&amp;quot;84&amp;quot;],[&amp;quot;芭芭拉&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;65.3&amp;quot;,&amp;quot;98&amp;quot;],[&amp;quot;凯露&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;62.8&amp;quot;,&amp;quot;102.5&amp;quot;],[&amp;quot;亨利&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;63.5&amp;quot;,&amp;quot;102.5&amp;quot;],[&amp;quot;詹姆斯&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;57.3&amp;quot;,&amp;quot;83&amp;quot;],[&amp;quot;简&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;59.8&amp;quot;,&amp;quot;84.5&amp;quot;],[&amp;quot;雅妮特&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;62.5&amp;quot;,&amp;quot;112.5&amp;quot;],[&amp;quot;杰弗瑞&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;62.5&amp;quot;,&amp;quot;84&amp;quot;],[&amp;quot;约翰&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;59&amp;quot;,&amp;quot;99.5&amp;quot;],[&amp;quot;乔伊斯&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;11&amp;quot;,&amp;quot;51.3&amp;quot;,&amp;quot;50.5&amp;quot;],[&amp;quot;茱迪&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;64.3&amp;quot;,&amp;quot;90&amp;quot;],[&amp;quot;罗伊斯&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;56.3&amp;quot;,&amp;quot;77&amp;quot;],[&amp;quot;玛丽&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;66.5&amp;quot;,&amp;quot;112&amp;quot;],[&amp;quot;菲利普&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;16&amp;quot;,&amp;quot;72&amp;quot;,&amp;quot;150&amp;quot;],[&amp;quot;罗伯特&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;64.8&amp;quot;,&amp;quot;128&amp;quot;],[&amp;quot;罗纳德&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;67&amp;quot;,&amp;quot;133&amp;quot;],[&amp;quot;托马斯&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;11&amp;quot;,&amp;quot;57.5&amp;quot;,&amp;quot;85&amp;quot;],[&amp;quot;威廉&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;66.5&amp;quot;,&amp;quot;112&amp;quot;]]}  最终代码：</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 调试libcurl程序</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%B0%83%E8%AF%95libcurl%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 25 Dec 2016 21:22:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%B0%83%E8%AF%95libcurl%E7%A8%8B%E5%BA%8F/</guid>
      <description>最近在调试通过libcurl发送GoogleSheets API POST请求时，增加了一点经验，特此总结。
GoogleSheets API 请求 POST /v4/spreadsheets?access_token={YOUR_ACCESSTOKEN}&amp;amp;fields=spreadsheetId HTTP/1.1 Host: sheets.googleapis.com Content-Type: application/json;charset=UTF-8 Accept: application/json Cache-Control: no-cache {&amp;quot;properties&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;newhaha&amp;quot;},&amp;quot;sheets&amp;quot;:[{&amp;quot;properties&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;Sheet1&amp;quot;}}]}  libcurl调试 当GoogleSheets API 请求失败时，仅能获得返回的状态码和消息。感觉没有更多信息可以研究！后来通过CURLOPT_VERBOSE和CURLOPT_DEBUGFUNCTION获得了更多调试信息。
使用CURLOPT_VERBOSE curl_easy_setopt(m_curl, CURLOPT_VERBOSE, 1L);  这样就可以看到请求报头、响应报头和消息体了。
使用CURLOPT_DEBUGFUNCTION 使用libcurl API指南中CURLOPT_DEBUGFUNCTION示例代码即可。这样就可以看到完整的请求和响应内容了。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 给twitcurl添加访问频次限制信息获取功能</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</link>
      <pubDate>Thu, 24 Mar 2016 06:05:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</guid>
      <description>在我之前的博文Twitter API访问频次限制处理中，描述了Twitter API访问频次限制及Twitter4J对其处理。twitcurl项目并没有这样的功能，今天我将getLastRateLimitStatus功能添加到了twitcurl。 通过添加如下代码，我可以获取响应头信息：
curl_easy_setopt( m_curlHandle, CURLOPT_HEADERFUNCTION, curlHeaderCallback ); curl_easy_setopt( m_curlHandle, CURLOPT_HEADERDATA, this );  输出的调试信息如下：
Enter string to search: va Limit search results to: 2 twitCurl::curlHeaderCallback headers: HTTP/1.1 200 OK twitCurl::curlHeaderCallback headers: cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0 twitCurl::curlHeaderCallback headers: content-disposition: attachment; filename=json.json twitCurl::curlHeaderCallback headers: content-encoding: gzip twitCurl::curlHeaderCallback headers: content-length: 1301 twitCurl::curlHeaderCallback headers: content-type: application/json;charset=utf-8 twitCurl::curlHeaderCallback headers: date: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: expires: Tue, 31 Mar 1981 05:00:00 GMT twitCurl::curlHeaderCallback headers: last-modified: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: pragma: no-cache twitCurl::curlHeaderCallback headers: server: tsa_b twitCurl::curlHeaderCallback headers: set-cookie: guest_id=v1:145879558114535127; Domain=.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]获取Facebook帖子生成的SAS时间</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96facebook%E5%B8%96%E5%AD%90%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 20 Feb 2016 06:13:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96facebook%E5%B8%96%E5%AD%90%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</guid>
      <description>写了一个小代码分析Facebook帖子生成时间字符串，将其解析成SAS时间。 简而言之，time_t存储的是距00:00:00, Jan 1, 1970 UTC的秒数（epoch），其中tm_year存储的是当前年数减去1900；而SAS时间起始点为00:00:00, Jan 1, 1960UTC；转换主要使用difftime获取两者的时间差。
代码如下：参考 C++: time_t
C++: time
C++: gmtime</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]获取推文生成的SAS时间</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96%E6%8E%A8%E6%96%87%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</link>
      <pubDate>Fri, 19 Feb 2016 06:07:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96%E6%8E%A8%E6%96%87%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</guid>
      <description>写了一个小代码分析推文生成时间字符串，将其解析成SAS时间。 简而言之，time_t存储的是距00:00:00, Jan 1, 1970 UTC的秒数（epoch），其中tm_year存储的是当前年数减去1900；而SAS时间起始点为00:00:00, Jan 1, 1960UTC；转换主要使用difftime获取两者的时间差。 代码如下：参考 C++: time_t
C++: time
C++: gmtime</description>
    </item>
    
    <item>
      <title>cURL错误处理</title>
      <link>https://mryqu.github.io/post/curl%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 07 Jan 2016 06:08:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/curl%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>cURL执行错误分为两种： - 通过curl_easy_perform函数执行请求结果，返回值不是CURLE_OK。错误信息除了可以对照CURLcode定义查看，也可以通过设置CURLOPT_ERRORBUFFER设置错误缓存区获得人类易读的错误文字信息。范例见https://curl.haxx.se/libcurl/c/CURLOPT_ERRORBUFFER.html
 curl = curl_easy_init(); if(curl) { CURLcode res; char errbuf[CURL_ERROR_SIZE]; curl_easy_setopt(curl, CURLOPT_URL, &amp;quot;http://example.com&amp;quot;); curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf); errbuf[0] = 0; res = curl_easy_perform(curl); if(res != CURLE_OK) { size_t len = strlen(errbuf); fprintf(stderr, &amp;quot;\nlibcurl: (%d) &amp;quot;, res); if(len) fprintf(stderr, &amp;quot;%s%s&amp;quot;, errbuf, ((errbuf[len - 1] != &#39;\n&#39;) ? &amp;quot;\n&amp;quot; : &amp;quot;&amp;quot;)); else fprintf(stderr, &amp;quot;%s\n&amp;quot;, curl_easy_strerror(res)); } }   另一种是curl_easy_perform返回CURLE_OK，但是HTTP响应代码为400及以上的整数。HTTP响应代码可以通过curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE,&amp;amp;httpCode)获得错误消息需要通过curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,curlCallback)获得消息体后解析而得。  </description>
    </item>
    
    <item>
      <title>为cURL库设置HTTP代理的代码片段</title>
      <link>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
      <pubDate>Wed, 06 Jan 2016 06:01:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
      <description>在twitcurl看到cURL库设置http代理的方法，记录一下。
void twitCurl::prepareCurlProxy() { if( m_curlProxyParamsSet ) { return; } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYUSERPWD, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYAUTH, (long)CURLAUTH_ANY ); std::string proxyIpPort(&amp;quot;&amp;quot;); if( getProxyServerIp().size() ) { utilMakeCurlParams( proxyIpPort, getProxyServerIp(), getProxyServerPort() ); } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, proxyIpPort.c_str() ); if( m_proxyUserName.length() &amp;amp;amp;&amp;amp;amp; m_proxyPassword.length() ) { std::string proxyUserPass; utilMakeCurlParams( proxyUserPass,getProxyUserName(),getProxyPassword() ); curl_easy_setopt( m_curlHandle,CURLOPT_PROXYUSERPWD,proxyUserPass.c_str() ); } m_curlProxyParamsSet = true; }  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]用正则表达式检查日期格式yyyy-MM-dd</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</link>
      <pubDate>Thu, 31 Dec 2015 06:21:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</guid>
      <description>写了一个小程序使用C++的正则表达式检查日期是否符合yyyy-MM-dd格式： 结果总是抛出exception，错误代码不是error_brack就是error_escape。检查了一下代码，没觉得不符合ECMAScript语法法则。 查了一下我的环境，用的gcc 4.7.0。试了一下regex_match的例子，没问题，但是稍微改动一下用\d{4}检查4位数字就又抛exception了。
C:\&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=C:\quTools\Anaconda\Scripts\g++.bat\..\..\MinGW\bin\g++.exe COLLECT_LTO_WRAPPER=c:/qutools/anaconda/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.7.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../build/gcc/src/configure --target=x86_64-w64-mingw32 --prefix=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --with-sysroot=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --enable-languages=all,obj-c++ --enable-fully-dynamic-string --disable-multilib Thread model: win32 gcc version 4.7.0 20111220 (experimental) (GCC)  搜了一下，发现C++2011标准中的regex功能直到gcc 4.9.0才正式发布。啥也不说了，在Mingw-w64 Toolchains上直接下载个gcc 5.3.0试试，一切正常了
C:\ctest&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=C:/tools/mingw32/bin/../libexec/gcc/i686-w64-mingw32/5.3.0/lto-wrapper.exe Target: i686-w64-mingw32 Configured with: ../../../src/gcc-5.3.0/configure --host=i686-w64-mingw32 --build=i686-w64-mingw32 --target=i686-w64-mingw32 --prefix=/mingw32 --with-sysroot=/c/mingw530/i686-530-posix-dwarf-rt_v4-rev0/mingw32 --with-gxx-include-dir=/mingw32/i686-w64-mingw32/include/c++ --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-sjlj-exceptions -- with-dwarf2 --disable-isl-version-check --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=i686 --with-tune=generic --with-libiconv --with-system-zlib --with-gmp=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpfr=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpc=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-isl=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-pkgversion=&#39;i686-posix-dwarf-rev0, Built by MinGW -W64 project&#39; --with-bugurl=http://sourceforge.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]玩玩Designated Initializer</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%8E%A9%E7%8E%A9designated_initializer/</link>
      <pubDate>Mon, 28 Dec 2015 06:18:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%8E%A9%E7%8E%A9designated_initializer/</guid>
      <description>玩一把gcc的Designated Initializers： 测试结果：结构体内的变量必须按照声明的顺序初始化，并且不能遗漏，否则会报“sorry, unimplemented:non-trivial designated initializers not supported”错误。
参考 C99标准
Bug 55606 - sorry, unimplemented: non-trivial designated initializers not supported
C++ - g++: sorry, unimplemented: non-trivial designated initializers not supported - SysTutorials QA
http://stackoverflow.com/questions/31215971/non-trivial-designated-initializers-not-supported
Non-trivial designated initializers not supported · Issue #8 · couchbaselabs/cbforest · GitHub</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]遭遇error C2039: &#39;min&#39; : is not a member of &#39;std&#39;</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%81%AD%E9%81%87error_c2039_min__is_not_a_member_of_std/</link>
      <pubDate>Tue, 22 Dec 2015 05:31:50 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%81%AD%E9%81%87error_c2039_min__is_not_a_member_of_std/</guid>
      <description>使用Visual Studio2013编译twitcurl遭遇下列错误：
error C2039: &#39;min&#39; : is not a member of &#39;std&#39;  解决方法：
#include &amp;lt;algorithm&amp;gt;  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Building twitcurl Library in Unix platform</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_building_twitcurl_library_in_unix_platform/</link>
      <pubDate>Sat, 19 Dec 2015 05:47:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_building_twitcurl_library_in_unix_platform/</guid>
      <description> Download twitcurl source from https://github.com/swatkat/twitcurl using Git client.  git clone https://github.com/swatkat/twitcurl.git  In Unix shell, cd into libtwitcurl directory. Compile all of the twitcurlsource files into object files.  g++ -Wall -fPIC -c -I. twitcurl.cpp oauthlib.cpp urlencode.cpp base64.cpp HMAC_SHA1.cpp SHA1.cpp  Building twitcurl asstatic library: Use the archive commandto build twitcurl library from object files.  ar rvs libtwitcurl.a *.o   </description>
    </item>
    
    <item>
      <title>Sublime Text2&#43;Ctags&#43;Cscope使用实践</title>
      <link>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 09 Dec 2015 07:07:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</guid>
      <description>安装 安装Package Control 步骤见https://packagecontrol.io/installation#st2
安装CTags插件  通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Ctags插件（快捷键Ctrl+Shift+P，输入install） 打开Preference -&amp;gt; Package Settings -&amp;gt; Ctags -&amp;gt;Settings-Default和Setting-User，将Settings-Default中的内容拷贝到Setting-User中，将&amp;rdquo;command&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;rdquo; 填入Ctags.exe的路径位置 打开C工程根目录，在上点击右键，选择Ctags:Rebuild tags  安装Cscope插件  同样通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Cscope插件（快捷键Ctrl+Shift+P，输入install） 通过cscope –Rb在C工程根目录创建cscope.out文件 Cscope在ST2上没有包配置菜单，需要打开CscopeSublime.sublime-settings文件(我的机器在C:/Users/yqu/AppData/Roaming/SublimeText 2/Packages/Cscope目录下)，将 &amp;ldquo;executable&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;ldquo;填入Cscope.exe的路径位置,将 &amp;ldquo;database_location&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的&amp;rdquo;&amp;ldquo;填入cscope.out的路径位置。  使用 CTags命令 |Command|Key Binding|Alt Binding|Mouse Binding |&amp;mdash;&amp;ndash; |rebuild_ctags|ctrl+t, ctrl+r| &amp;nbsp; | &amp;nbsp; |navigate_to_definition|ctrl+t, ctrl+t|ctrl+&amp;gt;|ctrl+shift+left_click |jump_prev|ctrl+t, ctrl+b|ctrl+&amp;lt;|ctrl+shift+right_click |show_symbols|alt+s| &amp;nbsp;| &amp;nbsp; |show_symbols (all files)|alt+shift+s| &amp;nbsp;| &amp;nbsp; |show_symbols (suffix)|ctrl+alt+shift+s| &amp;nbsp;| &amp;nbsp;</description>
    </item>
    
    <item>
      <title>MinGW安装和使用</title>
      <link>https://mryqu.github.io/post/mingw%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 04 Feb 2014 18:17:07 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/mingw%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>MinGW简介 MinGW全称Minimalist GNU For Windows，，是将GCC编译器和GNUBinutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。MinGW是从Cygwin1.3基础上发展而来，相比Cygwin而言体积更小、使用更方便。MinGW分两个分支，MinGW（即MinGW32）和MinGW-w64。 MinGW包括： - GNU编译器套件，包括C/C++、ADA语言和Fortran语言编译器 - 用于生成Windows二进制文件的GNU工具（编译器、链接器和档案管理器） - 用于Windows平台安装和部署MinGW和MSYS的命令行安装器（mingw-get） - 用于命令行安装器的GUI打包器（mingw-get-inst）
MinGW安装和使用 我只想使用C/C++，所以仅安装mingw32-base、mingw32-gcc-g++。msys-base其实也是可以不用安装的，因为我可以使用已有的GitBash。 我选择了默认的安装路径c:\MinGW，可以将c:\MinGW\bin加入环境变量以便使用。 参考 MinGW 官方网站
SourceForge.net：MinGW - Minimalist GNU for Windows
SourceForge.net：MinGW-w64 - for 32 and 64 bit Windows</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]不错的C&#43;&#43;引用参数分析</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%B8%8D%E9%94%99%E7%9A%84c&#43;&#43;%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 09 Nov 2013 07:29:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%B8%8D%E9%94%99%E7%9A%84c&#43;&#43;%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</guid>
      <description>阅读了一篇不错的C++ 引用参数 深入分析，摘要如下：
把参数声明成引用，实际上改变了缺省的按值传递参数的传递机制，在按值传递时，函数操纵的是实参的本地拷贝。
一、引用参数的三种常见用法：  需要改变实参的值，比如swap()。参数是引用时，函数接收的是实参的左值而不是值的拷贝。这意味着函数知道实参在内存中的位置，因而能够改变它的值或取它的地址。 向主调函数返回额外的结果。 向函数传递大型的类对象。  二、如果引用参数不希望在被调用的函数内部被修改，那么把参数声明为 const 型的引用是个不错的办法。 三、 我们可以声明任意内置数据类型的引用参数 四、引用参数还是指针参数 这两种参数都能够改变实参的值，也可以有效的传递大型类对象，怎么样决定参数该声明成哪种呢？ 根本区别是：引用必须被初始化为指向一个对象，一旦初始化了，它就不能再指向其他对象；指针可以指向一系列不同的对象也可以什么都不指向。因为指针可能指向一个对象或没有任何对象，所以函数在确定指针实际指向一个有效的对象之前不能安全地解引用（dereference）一个指针。另一方面，对于引用参数，函数不需要保证它指向一个对象。引用必须指向一个对象，甚至在我们不希望这样时也是如此。 如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必须使用指针参数 。 引用参数的一个重要用法是：它允许我们在有效地实现重载操作符的同时，还能保证用法的直观性。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 重温函数隐藏和重写</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</link>
      <pubDate>Sat, 26 Oct 2013 08:23:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</guid>
      <description>首先回顾一下C++的重载、隐藏和重写概念：
 在相同作用域中，同名不同参的函数称为重载，这是c++多态的一种表现。对相同名字的成员函数，编译器可以根据传递的参数类型调用相应的成员函数。同名不同参的全局函数和类成员函数由于作用域不同，不是重载。不能通过函数返回值进行重载。像int和float这样不同的参数类型，可能会由于隐式转换隐患而无法通过编译。 当派生类中的成员函数/变量和基类中的成员函数/变量同名时，会隐藏基类的成员函数/变量，也就是指在派生类调用这个同名的成员函数/变量，调用的是派生类的成员函数/变量，而不是基类的那个成员函数/变量。可以通过类名::成员函数/变量去访问基类中同名的成员函数/变量。 派生类中的成员函数与基类的成员函数同名同参，就称为重写。当直接访问成员函数调用的是在派生类中重写的函数而不是从基类继承下来的成员函数，如果要访问从基类继承下来的成员函数也是通过类名::成员函数这种方式去调用基类的成员函数。  下面的小示例testOverride.cpp用于测试添加virtual与否对重写的影响：
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } BaseClass(const BaseClass&amp;amp;) { cout &amp;lt;&amp;lt; &amp;quot;BaseClass(BaseClass) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); bo1-&amp;gt;vfun1(); bo1-&amp;gt;vfun2(); bo1-&amp;gt;fun1(); bo1-&amp;gt;fun2(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); do1-&amp;gt;vfun1(); // error: &#39;virtual void DerivedClass::vfun2()&#39; is private // within this context // do1-&amp;gt;vfun2(); do1-&amp;gt;fun1(); // error: &#39;void DerivedClass::fun2()&#39; is private // within this context // do1-&amp;gt;fun2(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); bo2-&amp;gt;vfun1(); bo2-&amp;gt;vfun2(); bo2-&amp;gt;fun1(); bo2-&amp;gt;fun2(); delete bo2; return 0; }  vfun2和fun2在BaseClass类中是public访问权限，而在DerivedClass类中是private访问权限。 - 对DerivedClass指针，vfun2和fun2无法访问，这个满足期望。 - 对于指向DerivedClass对象的BaseClass指针，vfun2和fun2仍然可以访问。我只能在心里留一个&amp;rdquo;?</description>
    </item>
    
    <item>
      <title>Cscope笔记</title>
      <link>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 20:20:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</guid>
      <description>Cscope简介 Cscope是一个类似Ctags的工具，但功能比ctags强大很多。Cscope是一款自带一个基于文本的用户界面的源代码浏览工具，尽管它最初是为C代码的搜索（包括lex、yacc文件）设计的，但是也可以用于对C++和Java代码的搜索。用Cscope你可以轻易地搜索到你的标识符是在哪里被定义和使用的，它可以轻而易举地解决以下问题： - 这个变量在哪里被使用？ - 这个预处理符号的值是什么？ - 这个函数都在哪些源代码文件中出现过？ - 都有哪些函数调用了这个函数？ - &amp;ldquo;out of space&amp;rdquo;的消息是从哪里来的？ - 这个源文件在在目录结构中的位置？ - 都有哪些源文件包含了这个头文件？
Cscope是由Santa Cruz Operation, Inc发布的，它遵循BSD开源协议。
安装 Cscope项目仅提供源代码，不提供二进制文件。cscope-win32项目提供了使用MinGW、MSYS和Cygwin编译Windows平台Cscope的方法，此外也提供编译好好的csope.exe文件。下载cscope-15.8a-win64rev1-static.zip，将其中的cscope.exe解压缩到系统环境变量path包含的路径即可。 使用 创建符号数据库 Cscope在第一次被使用在指定的源文件时会建立一个符号的数据库。接下来调用时，Cscope仅仅重建那些被改动或者和新文件相关的数据库。那些没有被改动的文件相关的数据库会被直接复制使用。这使得重建数据库要比第一次运行快许多。 Cscope命令的参数如下： - -R: 在生成索引文件时，搜索子目录树中的代码 - -b: 只生成索引文件，不进入cscope的界面 - -q:生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度 - -k: 在生成索引文件时，不搜索/usr/include目录 - -i:如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”-“，表示由标准输入获得文件列表。 - -Idir:在-I选项指出的目录中查找头文件 - -u: 扫描所有文件，重新生成交叉索引文件 - -C: 在搜索时忽略大小写 - -Ppath:在以相对路径表示的文件前加上的path，这样，你不用切换到你数据库文件所在的目录也可以使用它了。 我针对curl项目执行cscope -Rkq ，这样会启动Cscope的文本用户界面，之后我搜索set_binmode函数： 搜索符号 在Cscope的文本界面里可以在命令模式执行:cs find或:cs f命令搜索符号，其参数为： - s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方 - g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能 - d: 查找本函数调用的函数 - c: 查找调用本函数的函数 - t: 查找指定的字符串 - e: 查找egrep模式，相当于egrep功能，但查找速度快多了 - f: 查找并打开文件，类似vim的find功能 - i: 查找包含本文件的文件</description>
    </item>
    
    <item>
      <title>Exuberant Ctags笔记</title>
      <link>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 14:46:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</guid>
      <description>Ctags简介 Ctags（Generate tag files for sourcecode）产生标记(/索引)文件以帮助在源文件中定位对象。Ctags最初支持C语言，现在已经支持C/C++/Java/JS/Python等41种语言。Vim/Emacs/SublimeText/UltraEdit等编辑器或工具都支持Ctags生成的标记文件。 对于C/C++语言来说，其生成的标记文件tags中包括这些对象的列表： - 用#define定义的宏 - 枚举型变量的值 - 函数的定义、原型和声明 - 名字空间（namespace） - 类型定义（typedefs） - 变量（包括定义和声明） - 类（class）、结构（struct）、枚举类型（enum）和联合（union） - 类、结构和联合中成员变量或函数
安装 下载ctags58.zip，将其中的ctags.exe解压缩到系统环境变量path包含的路径即可。 使用选项 如果没有指定−−language−force选项，每个源文件的语言基于文件名和语言的映射进行自动选择。该映射可用−−list−maps选项显示，它可能会被−−langmap选项改变。对于操作系统所支持的文件，如果文件名无法映射到某种语言且该文件可被执行，则会对文件第一行检查是为&amp;rdquo;#!&amp;ldquo;公认的语言脚本。默认情况下，所有其他文件名都会被忽略。由于仅文件名可匹配某种语言的文件会被扫描，这使得在单个目录对所有文件(例如&amp;rdquo;ctags*&amp;ldquo;)或对目录树的所有文件(例如&amp;rdquo;ctags −R&amp;rdquo;)执行ctags成为可能。.h扩展名即用于C++也用于C，所以Ctags将.h映射为C++，这样做不会有不良后果。
 -R：等同于&amp;ndash;recurse，递归子目录遍历 -L：从文件读取Ctags待处理文件列表并对其执行ctags  find . -name &amp;quot;*.h&amp;quot; -o -name &amp;quot;*.c&amp;quot; -o -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.bld&amp;quot; -o -name &amp;quot;*.blt&amp;quot; &amp;gt; prj.files ctags -L prj.files  --list−maps：显示文件名和语言的映射  --list−languanges：显示所有支持的语言  --langmap：设置文件名和语言的映射 如果程序中有的.c文件其实是C++程序，这该怎么办？答案是使用ctags &amp;ndash;langmap=c++:+.c。 −−language−force：强制使用特定语言，而不是通过文件名和语言的映射进行自动选择 像C++标准库stl中文件名没有后缀，怎么办？ 使用ctags−−language−force=C++这样就把所有文件当成C++来处理了。 −−fields：指定标记文件中条目的可用扩展字段（没有指明的默认关闭） a
类成员的访问属性
f
文件限制范围 [enabled]</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 类型转换</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 15 Dec 2007 21:20:37 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>C++中的强制转换函数共有以下几种： - C 风格（C-style）强制转型: (Type) expr - 函数风格（Function-style）强制转型: Type( expr )要注意的是Type(expr)语法上等同(Type)expr，但是要避免使用。Type(expr,expr_else)是安全的。 - static_cast &amp;lt;type-id&amp;gt; ( expr )：用于非多态类型转换。static_cast是第一个应该尝试的类型转换。它完成类似隐性类型转换（例如int转float，指针转void*）这样的工作，也能调用显式（或隐式）类型转换函数。在很多情况下，显式使用static_cast没有必要。static_cast也能在继承层次上进行类型转换。在进行上行转换（子类转父类）是没有必要的，下行转换只要没有虚拟继承的情况下也可用，但是它不会做任何检查，下行转换为非该对象真正的类型时行为不明确。type-id和expr必须是指针、引用、算术类型或枚举类型。 - dynamic_cast &amp;lt;type-id&amp;gt; ( expr )：用于多态类型转换。dynamic_cast是几乎唯一用于处理多态类型转换的。你可以将一个指针或引用转换成其他类的多态类型（一个多态类型至少有一个虚函数，不管是声明的还是继承的）。它不仅经可用于下行转换，还可以横向转换或上行转换到另一个继承链。dynamic_cast会检查转换是否可行，如果可行则返回期望的对象，否则原表达式是指针的话返回空指针、原表达式是引用的话抛出std::bad_cast异常。dynamic_cast有一些限制。当继承层次上有相同类型的多个对象（DiamondDerivationproblem，菱形派生问题）而又没有使用虚拟继承时，无法工作。它仅能遍历公开继承，在遍历保护继承或私有继承时总是失败。非公开的继承很少使用，所以这种问题也很少见。Type-id必须是类的指针、类的引用或者void*；如果type-id是类指针类型，那么expr也必须是一个指针，如果type-id是一个引用，那么exp也必须是一个引用。 - const_cast &amp;lt;type-id&amp;gt; ( expr)：用来修改类型的const、volatile和__unaligned属性。const_cast可用于对一个变量添加或删除const属性，其他C++类型转换（甚至reinterpret_cast）没有删除const的能力。需要注意的是原有变量是const的，如果修改之前的常量值会造成不确定的行为。如果一个const引用指向非常量，对引用去掉const是安全的。当重载的成员函数是const的时候非常有用，例如你可以对一个对象添加const以调用重载的成员函数。const_cast也能对volatile属性进行修改，只是会更少被用到。除了const 或volatile修饰之外， type_id和expr的类型是一样的。 - reinterpret_cast &amp;lt;type-id&amp;gt; ( expr )：对类型简单重新解释reinterpret_cast是最危险的类型转换，应该尽可能少地使用。它直接将一个类型转换成另外一个，例如将一个指针获得的值转换成另一种类型、将指针存储成整型值、或其他一些丑陋的转换。基本上，reinterpret_cast仅能保障转换回原类型是正常的，你能在中间类型不小于原有类型的情况下获得相同的值。有很多reinterpret_cast不能做的转换。主要用于转义转换和二进制处理，例如将原始数据流转成实际数据、或将数据存储在对齐指针的低bit位中。type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
其中前两种称为旧风格（old-style）的强制转型，后四种为标准C++的类型转换符。
旧风格的强制转型可以看成按下列顺序排列的第一个成功的类型转换组合： - const_cast - static_cast (忽略访问限制) - static_cast接着const_cast - reinterpret_cast - reinterpret_cast接着const_cast
旧风格的强制转型比较危险，因为可能被解析成reinterpret_cast，而且解析成static_cast时会忽略访问权限控制（能做其他类型转换无法实现的功能）。此外，使用旧风格的强制转型也不如C++类型转换容易查找，所以一般不推荐使用。
参考 Type conversions
MSDN：Casting Operators
When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
总结C++中的所有强制转换函数(const_cast，reinterpret_cast，static_cast，dynamic_cast)
In C++, why use static_cast(x) instead of (int)x?</description>
    </item>
    
  </channel>
</rss>
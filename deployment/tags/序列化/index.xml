<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>序列化 on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/</link>
    <description>Recent content in 序列化 on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 22 Sep 2013 22:45:14 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>尝试Protocol Buffers支持的各种数据类型</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95protocol_buffers%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 22 Sep 2013 22:45:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95protocol_buffers%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Protocol Buffers(即protobuf)是Google开源的序列化库，是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化/反序列化。它很适合做数据存储或RPC的数据交换格式，常用作通信协议、数据存储等领域。 相比于常见的XML格式，ProtocolBuffers官方网站这样描述它的优点： - 平台无关、语言无关； - 高性能； - 体积小； - 使用简单； - 兼容性好。
现在尝试一下Protocol Buffers支持的各种数据类型。
test.proto package com.yqu.proto; option java_package = &amp;quot;com.yqu.proto&amp;quot;; option java_outer_classname=&amp;quot;TestProtos&amp;quot;; message Test { required double doubleVar = 1; required float floatVar = 2; required int32 int32Var = 3; required int64 int64Var = 4; required uint32 uint32Var = 5; required uint64 uint64Var = 6; required sint32 sint32Var = 7; required sint64 sint64Var = 8; required fixed32 fixed32Var = 9; required fixed64 fixed64Var = 10; required sfixed32 sfixed32Var = 11; required sfixed64 sfixed64Var = 12; required bool booleanVar = 13; required string stringVar = 14; required bytes bytesVar = 15; enum Suit { SPADES = 0; HEARTS = 1; DIAMONDS = 2; CLUBS = 3; } required Suit enumVar = 16 [default = HEARTS]; repeated int32 int32ArrayVar = 17; repeated uint32 uint32ArrayVar = 18 [packed=true]; repeated string stringArrayVar = 19; message MsgVar { required string url = 1; optional string title = 2; } repeated MsgVar msgVar = 20; }  使用Google提供的Protocol Buffers编译器生成Java语言：</description>
    </item>
    
    <item>
      <title>尝试Apache Avro支持的各种数据类型</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95apache_avro%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 18 Sep 2013 22:16:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95apache_avro%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Apache Avro是一个独立与编程语言的数据序列化系统，该项目由Doug Cutting（Hadoop之父）牵头创建的。它可以提供： - 丰富的数据结构类型 - 快速可压缩的二进制数据形式 - 存储持久数据的文件容器 - 远程过程调用（RPC） - 同动态语言的简单集成。读写数据文件和使用RPC协议都不需要生成代码，而代码生成作为一种可选的优化只值得在静态类型语言中实现。
今天尝试一下Apache Avro支持的各种数据类型。
test.avsc {&amp;quot;namespace&amp;quot;: &amp;quot;com.yqu.avro&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;record&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Test&amp;quot;, &amp;quot;fields&amp;quot;: [ {&amp;quot;name&amp;quot;: &amp;quot;stringVar&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;bytesVar&amp;quot;, &amp;quot;type&amp;quot;: [&amp;quot;bytes&amp;quot;, &amp;quot;null&amp;quot;]}, {&amp;quot;name&amp;quot;: &amp;quot;booleanVar&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;intVar&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;int&amp;quot;, &amp;quot;order&amp;quot;:&amp;quot;descending&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;longVar&amp;quot;, &amp;quot;type&amp;quot;: [&amp;quot;long&amp;quot;, &amp;quot;null&amp;quot;], &amp;quot;order&amp;quot;:&amp;quot;ascending&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;floatVar&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;float&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;doubleVar&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;double&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;enumVar&amp;quot;, &amp;quot;type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;enum&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Suit&amp;quot;, &amp;quot;symbols&amp;quot; : [&amp;quot;SPADES&amp;quot;, &amp;quot;HEARTS&amp;quot;, &amp;quot;DIAMONDS&amp;quot;, &amp;quot;CLUBS&amp;quot;]}}, {&amp;quot;name&amp;quot;: &amp;quot;strArrayVar&amp;quot;, &amp;quot;type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;, &amp;quot;items&amp;quot;: &amp;quot;string&amp;quot;}}, {&amp;quot;name&amp;quot;: &amp;quot;intArrayVar&amp;quot;, &amp;quot;type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;, &amp;quot;items&amp;quot;: &amp;quot;int&amp;quot;}}, {&amp;quot;name&amp;quot;: &amp;quot;mapVar&amp;quot;, &amp;quot;type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;map&amp;quot;, &amp;quot;values&amp;quot;: &amp;quot;long&amp;quot;}}, {&amp;quot;name&amp;quot;: &amp;quot;fixedVar&amp;quot;, &amp;quot;type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;fixed&amp;quot;, &amp;quot;size&amp;quot;: 16, &amp;quot;name&amp;quot;: &amp;quot;md5&amp;quot;}} ] }  使用下列命令将schema编译成代码</description>
    </item>
    
    <item>
      <title>序列化压缩实现及对比测试</title>
      <link>https://mryqu.github.io/post/%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%8B%E7%BC%A9%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 08 Aug 2013 07:13:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%8B%E7%BC%A9%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95/</guid>
      <description>网上介绍序列化压缩的用gzip比较多。写个测试代码，测试一下四种序列化方式： - 无压缩 - zlib压缩 - gzip压缩 - zip压缩
测例结果显示压缩效果：gzip压缩 &amp;gt; zlib压缩 &amp;gt; zip压缩&amp;gt; 无压缩 测例结果显示压缩速度：zlib压缩&amp;gt; gzip压缩&amp;gt; zip压缩 = 无压缩 确实用gzip性价比比较高！
### zlib介绍
zlib是一个开源库，提供了在内存中压缩和解压的函数。zlib它的设计目标是处理单纯的数据（而不管数据的来源是什么）。
### gzip介绍
gzip是UNIX下的一种数据格式(.tar.gz)。gzip是在zlib之上，包了一层，在头和尾添加了一些额外的信息。 gzip是一种文件压缩工具（或该压缩工具产生的压缩文件格式），它的设计目标是处理单个的文件。gzip在压缩文件中的数据时使用的就是zlib。为了保存与文件属性有关的信息，gzip需要在压缩文件（.gz）中保存更多的头信息内容，而zlib不用考虑这一点。但gzip只适用于单个文件，所以我们在UNIX/Linux上经常看到的压缩包后缀都是.tar.gz或*.tgz，也就是先用tar把多个文件打包成单个文件，再用gzip压缩的结果。
### zip介绍
zip只是一种数据结构，跟rar同级别的。zip是适用于压缩多个文件的格式（相应的工具有PkZip和WinZip等），因此，zip文件还要进一步包含文件目录结构的信息，比gzip的头信息更多。但需要注意，zip格式可采用多种压缩算法，我们常见的zip文件大多不是用zlib的算法压缩的，其压缩数据的格式与gzip大不一样。 Java SDK提供了对上述三种压缩技术的支持：Inflater类和Deflater类直接用zlib库对数据压缩/解压缩，GZIPInputStream类和GZIPOutputStream类提供了对gzip格式的支持，ZipFile、ZipInputStream、ZipOutputStream则用于处理zip格式的文件。 所以，你应当根据你的具体需求，选择不同的压缩技术：如果只需要压缩/解压缩数据，你可以直接用zlib实现，如果需要生成gzip格式的文件或解压其他工具的压缩结果，你就必须用gzip或zip等相关的类来处理了。
测试代码 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Arrays; import java.util.zip.DataFormatException; import java.util.zip.Deflater; import java.util.zip.GZIPInputStream; import java.util.zip.GZIPOutputStream; import java.util.zip.Inflater; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; import java.</description>
    </item>
    
    <item>
      <title>小玩Java序列化</title>
      <link>https://mryqu.github.io/post/%E5%B0%8F%E7%8E%A9java%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 08 Jul 2013 21:17:41 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%8F%E7%8E%A9java%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>折腾GemFire，免不了要折腾序列化和发序列化。GemFire支持Java的序列化，同时也有自己的DataSerializable接口实现自己的序列化，此外还有Delta接口支持数据同步时仅传送上一次数据同步后的更新。 今天测试的实现先用Java的序列化，一开始玩java.io.Serializable接口，后来玩writeObject()和readObject()方法。顺便看看有writeObject方法后ObjectOutputStream调用堆栈与原有分支的不同。
private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException { ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &amp;lt; slots.length; i++) { ObjectStreamClass slotDesc = slots[i].desc; if (slotDesc.hasWriteObjectMethod()) { PutFieldImpl oldPut = curPut; curPut = null; if (extendedDebugInfo) { debugInfoStack.push(&amp;quot;custom writeObject data (class \&amp;quot;&amp;quot; + slotDesc.getName() + &amp;quot;\&amp;quot;)&amp;quot;); } SerialCallbackContext oldContext = curContext; try { curContext = new SerialCallbackContext(obj, slotDesc); bout.setBlockDataMode(true); slotDesc.invokeWriteObject(obj, this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); } finally { curContext.</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Override on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/override/</link>
    <description>Recent content in Override on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 14 Jan 2016 05:48:14 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/override/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[CSS] 判断一条CSS样式规则的覆盖者</title>
      <link>https://mryqu.github.io/post/css_%E5%88%A4%E6%96%AD%E4%B8%80%E6%9D%A1css%E6%A0%B7%E5%BC%8F%E8%A7%84%E5%88%99%E7%9A%84%E8%A6%86%E7%9B%96%E8%80%85/</link>
      <pubDate>Thu, 14 Jan 2016 05:48:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/css_%E5%88%A4%E6%96%AD%E4%B8%80%E6%9D%A1css%E6%A0%B7%E5%BC%8F%E8%A7%84%E5%88%99%E7%9A%84%E8%A6%86%E7%9B%96%E8%80%85/</guid>
      <description>最近项目中有个OpenUI5控件显示缺少左填充，可它在公司的演示项目中却是正常的。接着发现.sasUiWndSectionCont是决定进行填充CSS规则。可是怎么在我的项目中就不成了呢？ 调试过程如下： - 打开Chrome开发者工具，选择元素检测器（ElementInspector），选择计算后样式（Computed）标签页，鼠标移动到感兴趣的左填充上（padding-left），点击圆圈图标查看详细内容- 跳到样式标签页后发现VDB项目下的.sasUiWndSectionCont定义覆盖了htmlcommons的。定位成功!</description>
    </item>
    
    <item>
      <title>[JavaScript] 继承</title>
      <link>https://mryqu.github.io/post/javascript_%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Wed, 27 Aug 2014 20:41:17 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/javascript_%E7%BB%A7%E6%89%BF/</guid>
      <description>示例：
function BaseClass() {}; BaseClass.prototype.method1 = function() { console.log(&amp;quot;BaseClass#method1&amp;quot;) }; BaseClass.prototype.method2 = function() { console.log(&amp;quot;BaseClass#method2&amp;quot;) }; BaseClass.prototype.method3 = function() { return &amp;quot;BaseClass#method3&amp;quot;; }; ChildClass.prototype = new BaseClass(); function ChildClass() { //BaseClass.call(this); }; ChildClass.prototype.method2 = function() { console.log(&amp;quot;ChildClass#method2&amp;quot;) }; ChildClass.prototype.method3 = function() { console.log(BaseClass.prototype.method3.call(this)+&amp;quot; by ChildClass!&amp;quot;); }; ChildClass.prototype.method4 = function() { console.log(&amp;quot;ChildClass#method4&amp;quot;) }; var myobj = new ChildClass(); myobj.method1(); myobj.method2(); myobj.method3(); myobj.method4();  测试： 注解：
Javascript的继承要在原型链上进行，没有super()可以调用父类，覆盖父类函数时只能通过父类原型以call或apply函数的形式调用父类的方法。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 重温函数隐藏和重写</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</link>
      <pubDate>Sat, 26 Oct 2013 08:23:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</guid>
      <description>首先回顾一下C++的重载、隐藏和重写概念：
 在相同作用域中，同名不同参的函数称为重载，这是c++多态的一种表现。对相同名字的成员函数，编译器可以根据传递的参数类型调用相应的成员函数。同名不同参的全局函数和类成员函数由于作用域不同，不是重载。不能通过函数返回值进行重载。像int和float这样不同的参数类型，可能会由于隐式转换隐患而无法通过编译。 当派生类中的成员函数/变量和基类中的成员函数/变量同名时，会隐藏基类的成员函数/变量，也就是指在派生类调用这个同名的成员函数/变量，调用的是派生类的成员函数/变量，而不是基类的那个成员函数/变量。可以通过类名::成员函数/变量去访问基类中同名的成员函数/变量。 派生类中的成员函数与基类的成员函数同名同参，就称为重写。当直接访问成员函数调用的是在派生类中重写的函数而不是从基类继承下来的成员函数，如果要访问从基类继承下来的成员函数也是通过类名::成员函数这种方式去调用基类的成员函数。  下面的小示例testOverride.cpp用于测试添加virtual与否对重写的影响：
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } BaseClass(const BaseClass&amp;amp;) { cout &amp;lt;&amp;lt; &amp;quot;BaseClass(BaseClass) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); bo1-&amp;gt;vfun1(); bo1-&amp;gt;vfun2(); bo1-&amp;gt;fun1(); bo1-&amp;gt;fun2(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); do1-&amp;gt;vfun1(); // error: &#39;virtual void DerivedClass::vfun2()&#39; is private // within this context // do1-&amp;gt;vfun2(); do1-&amp;gt;fun1(); // error: &#39;void DerivedClass::fun2()&#39; is private // within this context // do1-&amp;gt;fun2(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); bo2-&amp;gt;vfun1(); bo2-&amp;gt;vfun2(); bo2-&amp;gt;fun1(); bo2-&amp;gt;fun2(); delete bo2; return 0; }  vfun2和fun2在BaseClass类中是public访问权限，而在DerivedClass类中是private访问权限。 - 对DerivedClass指针，vfun2和fun2无法访问，这个满足期望。 - 对于指向DerivedClass对象的BaseClass指针，vfun2和fun2仍然可以访问。我只能在心里留一个&amp;rdquo;?</description>
    </item>
    
    <item>
      <title>[Eclipse] Find the override method implementation in subclasses</title>
      <link>https://mryqu.github.io/post/eclipse_find_the_override_method_implementation_in_subclasses/</link>
      <pubDate>Sat, 26 Oct 2013 00:00:39 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse_find_the_override_method_implementation_in_subclasses/</guid>
      <description>已知当前对象为org.apache.hadoop.hdfs.client.HdfsDataInputStream实例，调用其祖宗抽象类java.io.InputStream的publicint read(byte b[], int off, int len) throwsIOException方法，究竟最后使用的是那个类的实现呢？ 由如上类继承图可知，应该从对象类往上依次查找方法实现：HdfsDataInputStream、FSDataInputStream、&amp;hellip;&amp;hellip;。工作很繁琐，挑战眼力！
一个快捷的方式就是进入java.io.InputStream类，选中read(byte b[], int off, intlen) 方法，按住CTRL键后点击鼠标左键，这样会出现一个菜单： 选择OpenImplementation菜单，输入HdfsDataInputStream、FSDataInputStream、&amp;hellip;&amp;hellip;，可以更轻松的找到重写该方法的子类。 最终可知使用的是java.io.DataInputStream类中的实现：
public final int read(byte b[], int off, int len) throws IOException { return in.read(b, off, len); }  </description>
    </item>
    
  </channel>
</rss>
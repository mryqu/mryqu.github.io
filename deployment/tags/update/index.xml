<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Update on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/update/</link>
    <description>Recent content in Update on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 13 Apr 2015 05:49:35 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/update/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Gradle] 强制重新下载依赖</title>
      <link>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Mon, 13 Apr 2015 05:49:35 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</guid>
      <description>强制Gradle重新下载依赖的方式有两种： - 在Gradle命令中加入&amp;ndash;refresh-dependencies选项。该选项会让Gradle忽略已解析模块和构件的所有缓存项，对所配置的仓库重新进行解析，动态计算版本、更新模块和下载构件。 - 删除Gralde的缓存目录~/.gradle/caches。这个有点过于粗暴。
示例：
gradlew clean --refresh-dependencies build bootRun  </description>
    </item>
    
    <item>
      <title>PostgreSQL数据库分区的update操作</title>
      <link>https://mryqu.github.io/post/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%8C%BA%E7%9A%84update%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 19 Jul 2013 23:23:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%8C%BA%E7%9A%84update%E6%93%8D%E4%BD%9C/</guid>
      <description>CREATE TABLE measurement ( city_id int not null, unitsales int ); CREATE TABLE measurement_1 ( CHECK (unitsales &amp;lt; 100 ) ) INHERITS (measurement); CREATE TABLE measurement_2 ( CHECK (unitsales &amp;gt;= 100 ) ) INHERITS (measurement); CREATE OR REPLACE FUNCTIONmeasurement_insert_trigger() RETURNS TRIGGER AS $$ BEGIN IF (NEW.unitsales &amp;lt; 100) THEN INSERT INTO measurement_1 VALUES (NEW.*); ELSE INSERT INTO measurement_2 VALUES (NEW.*); END IF; RETURNNULL; END; $$ LANGUAGE plpgsql; CREATE TRIGGER insert_measurement_trigger BEFOREINSERT ON measurement FOR EACH ROWEXECUTE PROCEDURE measurement_insert_trigger(); INSERT INTO measurement VALUES (1, 1); INSERT INTO measurement VALUES (2, 2); INSERT INTO measurement VALUES (3, 300); INSERT INTO measurement VALUES (4, 400); mysdm=# select * from measurement_1; city_id | unitsales ---------+----------- 1| 1 2| 2 (2 rows) mysdm=# select * from measurement_2; city_id | unitsales ---------+----------- 3| 300 4| 400 (2 rows)  Postgres没有智能到在update时根据记录的新值变动分区，而是报错！</description>
    </item>
    
  </channel>
</rss>
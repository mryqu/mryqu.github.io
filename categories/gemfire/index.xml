<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gemfire on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/categories/gemfire/</link>
    <description>Recent content in Gemfire on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 05 Jul 2013 21:23:00 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/categories/gemfire/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>动态GemFire Region使用局限</title>
      <link>https://mryqu.github.io/post/%E5%8A%A8%E6%80%81gemfire_region%E4%BD%BF%E7%94%A8%E5%B1%80%E9%99%90/</link>
      <pubDate>Fri, 05 Jul 2013 21:23:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%8A%A8%E6%80%81gemfire_region%E4%BD%BF%E7%94%A8%E5%B1%80%E9%99%90/</guid>
      <description> 介绍 当前项目原有设计使用了嵌套的Map作为缓存。我在使用GemFire产品时使用普通region替代外层map，使用动态region替代内层map。
对于&amp;rdquo;/outer_region/Dimension&amp;rdquo;region中的条目，键是维ID（例如5），值是动态region&amp;rdquo;/inter_region/Dimension/5&amp;rdquo;. &amp;ldquo;/outer_region/Dimension&amp;rdquo; region的容量是256个条目，动态region&amp;rdquo;/inter_region/Dimension/5&amp;rdquo;的容量是10个条目。 当维#5被删除，&amp;rdquo;/outer_region/Dimension&amp;rdquo;相应条目应该删除，而动态region&amp;rdquo;/inter/Dimension/5&amp;rdquo;应该被销毁。
测试发现，当GemFire节点通过API创建了动态region后，它会将动态region列表发送给其他节点，此后的GemFire节点在创建Cache会失败。通过异常日志可知动态region会在Cache创建过程中被创建，但后继GemFire节点无法找到父region (在该节点创建Cache之前根本没机会创建region!),这是导致失败的原因。
如果对cache使用cache-xml-file， GemFire会先创建普通region之后创建动态region。这需要将一个cache下所有region定义都放到cache-xml-file里，上述问题可能会被避免。但是一个cache被多个项目共享，所有项目的region定义放在一起的话，配置耦合度很高，对于产品的灵活性和扩展性很不利。
日志 Caused by: com.gemstone.gemfire.cache.RegionDestroyedException: Error -- Could not find a region named: &#39;/inter_region/Dimension&#39; at com.gemstone.gemfire.cache.DynamicRegionFactory.createDynamicRegionImpl(DynamicRegionFactory.java) at com.gemstone.gemfire.cache.DynamicRegionFactory.createDefinedDynamicRegions(DynamicRegionFactory.java) at com.gemstone.gemfire.cache.DynamicRegionFactory._internalInit(DynamicRegionFactory.java) at com.gemstone.gemfire.internal.cache.DynamicRegionFactoryImpl.internalInit(DynamicRegionFactoryImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.readyDynamicRegionFactory(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.initializeDeclarativeCache(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.init(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.create(GemFireCacheImpl.java) at com.gemstone.gemfire.cache.CacheFactory.create(CacheFactory.java) at com.gemstone.gemfire.cache.CacheFactory.create(CacheFactory.java) at org.springframework.data.gemfire.CacheFactoryBean.createCache(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.init(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.getObject(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.getObject(CacheFactoryBean.java) at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java) ... 34 more  </description>
    </item>
    
    <item>
      <title>嵌套的动态GemFire region研究</title>
      <link>https://mryqu.github.io/post/%E5%B5%8C%E5%A5%97%E7%9A%84%E5%8A%A8%E6%80%81gemfire_region%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Fri, 28 Jun 2013 16:16:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B5%8C%E5%A5%97%E7%9A%84%E5%8A%A8%E6%80%81gemfire_region%E7%A0%94%E7%A9%B6/</guid>
      <description>研究目的和结论  研究多级动态region是否可行，结论可行 研究嵌套region(一个region是另一个region的值)是否可行，结论可行  Java代码 import java.util.Set; import com.gemstone.gemfire.cache.Cache; import com.gemstone.gemfire.cache.CacheFactory; import com.gemstone.gemfire.cache.DynamicRegionFactory; import com.gemstone.gemfire.cache.Region; public class EmbededDynamicRegion { public static void main(String[] args) { System.out.println(&amp;quot;\nConnecting to the distributed system and creating the cache.&amp;quot;); Cache cache = null; try { // Create the cache which causes the cache-xml-file to be parsed cache = new CacheFactory().set(&amp;quot;name&amp;quot;, &amp;quot;yqu_test_cache&amp;quot;) .set(&amp;quot;cache-xml-file&amp;quot;, &amp;quot;xml/YquTest.xml&amp;quot;).create(); // Get the exampleRegion Region yquRegion = cache.getRegion(&amp;quot;yqu_region&amp;quot;); printRegionFullPath(yquRegion); DynamicRegionFactory dynRegFactory = DynamicRegionFactory.</description>
    </item>
    
    <item>
      <title>用GemFire做Hibernate二级缓存</title>
      <link>https://mryqu.github.io/post/%E7%94%A8gemfire%E5%81%9Ahibernate%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sun, 16 Jun 2013 11:13:02 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%94%A8gemfire%E5%81%9Ahibernate%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</guid>
      <description>打开二级缓存 &amp;lt;property name=&amp;quot;hibernate.cache.use_second_level_cache&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;  为查询缓存设置Cache Factory &amp;lt;property name=&amp;quot;hibernate.cache.region.factory_class&amp;quot;&amp;gt; com.gemstone.gemfire.modules.hibernate.GemFireRegionFactory &amp;lt;/property&amp;gt;  共享缓存模式 ENABLE_SELECTIVE|DISABLE_SELECTIVE|ALL|NONE  ENABLE_SELECTIVE (默认值及推荐值): 仅标注为可缓存的实体会被缓存。 DISABLE_SELECTIVE: 仅标注为不可缓存的实体才不会被缓存。 ALL: 即使实体标为不可缓存也会被缓存。 NONE: 即使实体标为可缓存也不会被缓存。该选项意味着完全禁止二级缓存。
GemFire相关配置 设置GemFire缓存属性
&amp;lt;property name=&amp;quot;gemfire.PROPERTY_NAME&amp;quot;&amp;gt;PROPERTY_VALUE&amp;lt;/property&amp;gt;  设置GemFire缓存默认region类型
&amp;lt;property name=&amp;quot;gemfire.default-region-attributes-id&amp;quot;&amp;gt; REGION_ATTRIBUTE &amp;lt;/property&amp;gt;  REGION_ATTRIBUTE是预定义region类型快捷定义中的任一个。默认为REPLICATE_HEAP_LRU。其他有效region快捷定义包括:REPLICATE、 REPLICATE_PERSISTENT、 PARTITION、 PARTITION_PERSISTENT、PARTITION_REDUNDANT、 PARTITION_REDUNDANT_PERSISTENT。
设置特定GemFire缓存region属性
&amp;lt;property name=&amp;quot;gemfire.region-attributes-for: com.foo.Bar&amp;quot;&amp;gt; REGION_ATTRIBUTE &amp;lt;/property&amp;gt;  缓存映射 @Cache ( CacheConcurrencyStrategy usage(); String region() default &amp;quot;&amp;quot;; String include() default &amp;quot;all&amp;quot;; )  usage: 缓存并发策略(NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE,TRANSACTIONAL) region (可选项，默认为实体类的全类名或集合的全类名加属性名):缓存region名 include (选项项，默认为all): all则缓存所有实体属性，non-lazy仅缓存非懒惰加载的实体属性。</description>
    </item>
    
    <item>
      <title>用GemFire做Mybatis二级缓存</title>
      <link>https://mryqu.github.io/post/%E7%94%A8gemfire%E5%81%9Amybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</link>
      <pubDate>Wed, 22 May 2013 09:12:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%94%A8gemfire%E5%81%9Amybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</guid>
      <description>MyBatis支持第三方二级缓存实现，目前支持Ehcache、Hazelcast和OSCache。 GemFire不在支持的范围，但是可以通过实现org.apache.ibatis.cache.Cache接口来使用。
MyBatis的Cache配置及实现  设置MyBatis的Cache全局使用开关：默认是true，如果它配成false，其余各个MapperXML文件配成支持cache也没用。  &amp;lt;settings&amp;gt; &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/settings&amp;gt;  各个Mapper XML文件，默认是不采用cache。在配置文件加一行就可以支持cache：  &amp;lt;cache /&amp;gt;  实现GemfireCache
package com.yqu.mybatis.caches.gemfire; import com.gemstone.gemfire.cache.AttributesFactory; import com.gemstone.gemfire.cache.CacheFactory; import com.gemstone.gemfire.cache.Region; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; import org.apache.ibatis.cache.Cache; import org.apache.ibatis.cache.CacheException; public final class GemfireCache implements Cache { private static Region&amp;lt;object&amp;gt; mybatis_region = null; private Region&amp;lt;object&amp;gt; region = null; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public void setId(String id) { this.id = id; } public void setRegion(Region&amp;lt;object&amp;gt; region) { this.</description>
    </item>
    
    <item>
      <title>GemFire 数据逐出和持久化</title>
      <link>https://mryqu.github.io/post/gemfire_%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Fri, 17 May 2013 15:48:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gemfire_%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>为什么逐出数据? 如果有多于JVM内存的数据想放入Region，数据逐出是可能使用的一种解决方案。 一种备选方案是对数据进行分区。然而分区Region也可能无法将所有数据放入内存，所以有可能需要对分区Region采用数据逐出。 另一种备选方案是让数据过一定期限后从内存删除，这是基于时间而不是空间的一种方案。
数据逐出如何工作？ 当使用数据逐出时需要决定所采用的算法和动作。 算法规定了需要检查的所耗费资源的最大值，可为基于条目数量、内存消耗字节数和可用堆消耗百分比的LRU（最近最少使用）算法。 - 条目数量和绝对内存消耗量完全由GemFire逐出控制器基于Region级别进行管理。EntryLRU是最简单的算法，适用于每个条目消耗相同大小的内存。Memory LRU则适用于每个条目消耗不同大小的内存。 - Heap消耗百分比由GemFire逐出控制器基于缓存级别进行管理。最大值设置在管理器配置的缓存下配置。当管理器断定需要进行数据逐出时，它命令逐出控制器对所有逐出算法设为lru-heap-percentage的region采取数据逐出，直到管理器停止这一命令。注意的是，当其他非LRU资源甚至非GemFire缓存消耗内存时，这一算法也会导致HeapLRUregion的数据逐出。
对于一个region，数据逐出操作会逐出最近最少使用到的条目。几乎所有操作（包括读写）都认为是对条目的使用，除了以下的操作： - Region.containsKey - Region.containsValue - Region.getEntry
当使用MemoryLRU或HeapLRU算法时需要实现ObjectSizer接口。这让GemFire可以调用自己的代码来计算条目的字节大小。让条目大小估算精确很重要，但同时需要注意的是复杂ObjectSize实现会花费较长时间并导致性能下降。如果条目的所有值都是String或byte[]类型，GemFire会自动计算内存大小，无须实现ObjectSizer。
分区Region在数据逐出的不同之处 对于分区region，基于条目数量和内存消耗量的逐出行为当节点数据超过本地缓存主副本和冗余副本组合的限制后发生。对于基于堆消耗百分比的逐出行为由管理器驱动。 因为维护整个分区region或者同一节点所有桶（bucket）的LRU条目信息代价太大，GemFire是基于桶来维护LRU条目信息的。此外，对分区region的所有桶施行数据组出会导致数据分布失衡。 因此，对分区region进行的数据逐出可能会保留相对本地节点其他桶或其他分布系统节点相对更老的条目。它可能在主副本中保留条目而在第二副本中逐出条目，或者相反。 LRU逐出对每个桶单独进行: - 对基于内存和条目数的数据逐出，LRU逐出在操作新条目时有可能执行，直到Region的桶组合整体内存下降到门限下结束。对于内存逐出，分区region最大内存门限会忽略lru-memory-size设置，始终是local-max-memory。 - 对于基于堆的数据逐出，每个分区region桶被当作单独region来处理，每个逐出动作仅考虑桶内的LRU，而不是整体分区region。
动作为本地删除条目的数据逐出无法用于复制region，因为不允许对复制分区进行本地写操作，这会违反所有数据在复制分区都可见的契约。如果需要使用本地删除条目的数据逐出，可以考虑使用预加载数据策略，其行为在初始化时与复制分区相同并允许动作为本地删除条目的数据逐出。
| |数据无持久化|数据持久化 |&amp;mdash;&amp;ndash; |EvictionAction.NONE|条目将在内存中一直保存。|条目将在内存和磁盘中一直保存。 |EvictionAction.LOCAL_DESTROY|条目（键和值两部分）将从内存中释放。仅当被逐出数据可从外部数据源加载时可用。| |EvictionAction.OVERFLOW_TO_DISK|条目将被逐出到磁盘但是不会持久化 (当缓存关闭时磁盘文件将被删除)，条目的键部分始终在内存中保存。|条目(键和值两部分)一直在磁盘中保存。条目的值部分将被逐出，键部分始终在内存中保存。
磁盘存储文件名和扩展名 磁盘存储文件包括存储管理、访问控制文件和操作日志（oplog，记录了删除和其他所有操作）。下面的表描述了文件名和扩展名及示例。
文件名 文件名包括三部分:
第一部分: 使用标识 |值|用途|示例 |&amp;mdash;&amp;ndash; |OVERFLOW|仅为溢出region和队列的操作日志数据。|OVERFLOWoverflowDS1_1.crf |BACKUP|持久化、持久化+溢出rgion和队列操作日志数据。|BACKUPoverflowDS1.if, BACKUPDEFAULT.if |DRLK_IF|访问控制 - 对磁盘存储上锁。|DRLK_IFoverflowDS1.lk, DRLK_IFDEFAULT.lk
第二部分: 磁盘存储名 |值|用途|示例 |&amp;mdash;&amp;ndash; |&amp;lt;磁盘存储名&amp;gt;|非默认磁盘存储。|name=&amp;ldquo;overflowDS1&amp;rdquo; DRLK_IFoverflowDS1.lk,
name=&amp;ldquo;persistDS1&amp;rdquo; BACKUPpersistDS1_1.crf |DEFAULT|默认磁盘存储名，当对region或队列指定持久化或溢出但没有命名磁盘存储时使用。|DRLK_IFDEFAULT.lk, BACKUPDEFAULT_1.crf
第三部分: 操作日志序列号 |值|用途|示例 |&amp;mdash;&amp;ndash; |序列号格式为_n|仅用于操作日志。编码从1开始。|OVERFLOWoverflowDS1_1.crf, BACKUPpersistDS1_2.crf, BACKUPpersistDS1_3.crf</description>
    </item>
    
    <item>
      <title>GemFire查询</title>
      <link>https://mryqu.github.io/post/gemfire%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 15 May 2013 07:30:01 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gemfire%E6%9F%A5%E8%AF%A2/</guid>
      <description>GemFire在region中存储的数据为键值对，其中值可以为任何对象，例如简单的字节数组或者复杂的嵌套对象。GemFire提供了一种查询机制可以获得满足特定条件的键、值或条目集合。GemFire支持的查询语义和语法是OQL（对象查询语言）的一个子集。OQL是由对象数据管理组制定的ODMG3.0对象模型的重要组件之一，与SQL很相似，可以查询复杂对象、对象属性和方法，支持完整的ASCII和Unicode字符集。 为了提高查询执行效率，GemFire像数据库一样支持索引。在查询执行时，查询引擎使用数据存储上的索引可以减少查询处理时间。查询是GemFire很强大的功能，但它也需要大量性能优化和容量规划也确保不拖垮系统。
Region存储示例 本文的查询示例基于类Porfolio和Positon的对象。
Portfolio.java package query; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import com.gemstone.gemfire.DataSerializable; import com.gemstone.gemfire.DataSerializer; public class Portfolio implements Serializable, DataSerializable { private int ID; public String pkid; public Position position1; public Position position2; public String description; public HashMap positions = new HashMap(); String type; public String status; public String [] names={&amp;quot;aaa&amp;quot;,&amp;quot;bbb&amp;quot;,&amp;quot;ccc&amp;quot;,&amp;quot;ddd&amp;quot;}; public int getID() { return ID; } public String getPk() { return pkid; } public HashMap getPositions() { return positions; } public Position getP1() { return position1; } public Position getP2() { return position2; } public boolean isActive() { return status.</description>
    </item>
    
    <item>
      <title>GemFire Region分类</title>
      <link>https://mryqu.github.io/post/gemfire_region%E5%88%86%E7%B1%BB/</link>
      <pubDate>Wed, 15 May 2013 07:28:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gemfire_region%E5%88%86%E7%B1%BB/</guid>
      <description>GemFire开发指南6.5的第4.2节仅列举了分区、复制（分布式）、分布式（非复制）和本地四种Region类型，但RegionShortcut类却定义了23个快捷预定义属性Region。Region的主要行为取决于数据策略、关注策略、范围、本地最大内存和冗余拷贝数（仅用于分区Region）、逐出算法和动作。
Region快捷预定义属性数据策略范围本地
最大
内存
注1冗余
拷贝
数
注1逐出算法逐出动作LOCALNORMALLOCAL    LOCAL_HEAP_LRUNORMALLOCAL  LRU_HEAPLOCAL_DESTROYLOCAL_OVERFLOWNORMALLOCAL  LRU_HEAPOVERFLOW_TO_DISKLOCAL_PERSISTENTPERSISTENT_REPLICATELOCAL    LOCAL_PERSISTENT_OVERFLOWPERSISTENT_REPLICATELOCAL  LRU_HEAPOVERFLOW_TO_DISKPARTITIONPARTITION     PARTITION_HEAP_LRUPARTITION   LRU_HEAPLOCAL_DESTROYPARTITION_OVERFLOWPARTITION   LRU_HEAPOVERFLOW_TO_DISKPARTITION_PERSISTENTPERSISTENT_PARTITION     PARTITION_PERSISTENT_OVERFLOWPERSISTENT_PARTITION   LRU_HEAPOVERFLOW_TO_DISKPARTITION_PROXYPARTITION 0   PARTITION_PROXY_REDUNDANTPARTITION 01  PARTITION_REDUNDANTPARTITION  1  PARTITION_REDUNDANT_HEAP_LRUPARTITION  1LRU_HEAPLOCAL_DESTROYPARTITION_REDUNDANT_OVERFLOWPARTITION  1LRU_HEAPOVERFLOW_TO_DISKPARTITION_REDUNDANT_PERSISTENTPERSISTENT_PARTITION  1  PARTITION_REDUNDANT_
PERSISTENT_OVERFLOWPERSISTENT_PARTITION  1LRU_HEAPOVERFLOW_TO_DISKREPLICATEREPLICATEDISTRIBUTED_ACK    REPLICATE_HEAP_LRUPRELOADDISTRIBUTED_ACK  LRU_HEAPLOCAL_DESTROYREPLICATE_OVERFLOWREPLICATEDISTRIBUTED_ACK  LRU_HEAPOVERFLOW_TO_DISKREPLICATE_PERSISTENTPERSISTENT_REPLICATEDISTRIBUTED_ACK    REPLICATE_PERSISTENT_OVERFLOWPERSISTENT_REPLICATEDISTRIBUTED_ACK  LRU_HEAPOVERFLOW_TO_DISKREPLICATE_PROXYEMPTYDISTRIBUTED_ACK     注1：仅用于分区region http://www.</description>
    </item>
    
  </channel>
</rss>
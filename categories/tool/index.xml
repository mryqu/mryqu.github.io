<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tool on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/categories/tool/</link>
    <description>Recent content in Tool on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 14 Jan 2019 18:07:31 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/categories/tool/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用了Widnows包管理器Chocolatey</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8%E4%BA%86widnows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8chocolatey/</link>
      <pubDate>Mon, 14 Jan 2019 18:07:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8%E4%BA%86widnows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8chocolatey/</guid>
      <description>系统由于升级微软安全补丁起不来了，在IT同事的帮助下重装了系统。
然后就开始重装大量软件，看到有些软件可以用Widnows包管理器Chocolatey安装，一时轻浮，按捺不住对新事物的向往，就装了Chocolatey。
通过Chocolatey安装了Gradle，后来IntelliJ问我Gradle装哪里了，我一时就蒙了。
想想Linux下的软件都不问，为啥到Windows就不成了？估计还是Linux下包管理是主流，判断依赖软件装没装直接先问deb/apt-get。
估计Windows下用Chocolatey的太少，不但人而且软件的习惯都还没培养起来。这是我的不对，赶紧自己搜出来“C:\ProgramData\chocolatey\lib\gradle\tools\gradle-5.1.1”应付交差了。</description>
    </item>
    
    <item>
      <title>使用Packer创建基于Ubuntu的Vagrant Box</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8packer%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Eubuntu%E7%9A%84vagrant_box/</link>
      <pubDate>Fri, 04 Jan 2019 06:07:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8packer%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Eubuntu%E7%9A%84vagrant_box/</guid>
      <description>前一博客创建基于Ubuntu的Vagrant Box是手工完成的，这意味着每次实施后需要写出详细文档，以便于以后查档、定位问题或者更新。
持续交付和DevOps技术的快速进步和演化，使得基础设施的配置不得不频繁变化。基础设施即代码(IaC)是一种使用新的技术来构建和管理动态基础设施的方式。它把基础设施、工具和服务以及对基础设施的管理本身作为一个软件系统，采纳软件工程实践以结构化的安全的方式来管理对系统的变更。
Packer是由HashiCorp推出的一款轻量级镜像定义工具，用于从单一配置来源为多平台创建相同的机器映像。目前支持的平台包括Alicloud ECS、Amazon EC2、Azure、CloudStack、DigitalOcean、Docker、File、Google Cloud、Hetzner Cloud、Hper-V、LXC、LXD、NAVER Cloud、1&amp;amp;1、OpenStack、Oracle、Parallels、ProfitBricks、QEMU、Scaleway、Triton、VirtualBox和VMware。
配置好一个模版文件，用pakcer命令就可以按需构建机器镜像。也可以根据需求及时更改配置。 加入软件版本控制（主要用的是 Git）后，就可以很方便的追溯更改。
尝试了用Packer模板创建Ubuntu基于VirtualBox provider的Vagrant Box，日志如下：
C:\quTemp\PackerTest&amp;gt;REM set PACKER_LOG=1 C:\quTemp\PackerTest&amp;gt;packer build -var &amp;quot;mirror=c:/quTemp&amp;quot; -var &amp;quot;mirror_directory=PackerTest&amp;quot; ubuntu-14.04-amd64.json virtualbox-iso output will be in this color. ==&amp;gt; virtualbox-iso: Retrieving Guest additions virtualbox-iso: Using file in-place: file:///C:/quTools/Oracle/VirtualBox/VBoxGuestAdditions.iso ==&amp;gt; virtualbox-iso: Retrieving ISO virtualbox-iso: Using file in-place: file:///C:/quTemp/PackerTest/ubuntu-14.04.5-server-amd64.iso ==&amp;gt; virtualbox-iso: Starting HTTP server on port 8711 ==&amp;gt; virtualbox-iso: Creating virtual machine... ==&amp;gt; virtualbox-iso: Creating hard drive... ==&amp;gt; virtualbox-iso: Creating forwarded port mapping for communicator (SSH, WinRM, etc) (host port 3620) ==&amp;gt; virtualbox-iso: Executing custom VBoxManage commands.</description>
    </item>
    
    <item>
      <title>创建基于Ubuntu的Vagrant Box</title>
      <link>https://mryqu.github.io/post/%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Eubuntu%E7%9A%84vagrant_box/</link>
      <pubDate>Wed, 02 Jan 2019 06:07:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8Eubuntu%E7%9A%84vagrant_box/</guid>
      <description>学习一下创建Ubuntu基于VirtualBox provider的Vagrant Box。
准备环境  Vagrant VirtualBox 下载Ubuntu 14.04.5 LTS (Trusty Tahr)服务器版ISO文件  创建虚拟机 创建VirtualBox VM mryqu-ubuntu 内存1024MB 创建VMDK类型、自动分配的虚拟硬盘 安装Ubuntu 点击Setting，在Storage配置页的Controller:IDE中增加CD，选择所下载的Ubuntu ISO文件。然后启动虚拟机。 安装过程除了下列项之外使用默认选择：
- Configure the network - Hostname: vagrant
- Set up users and passwords: vagrant/vagrant
- Encrypt your home directory? Select No
- Select your time zone: UTC
- Partitioning method: Guided – use entire disk and set up LVM
- When prompted which software to install, select OpenSSH server</description>
    </item>
    
    <item>
      <title>[Vagrant]学习VBoxManage定制</title>
      <link>https://mryqu.github.io/post/vagrant_%E5%AD%A6%E4%B9%A0vboxmanage%E5%AE%9A%E5%88%B6/</link>
      <pubDate>Thu, 26 Jul 2018 05:56:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant_%E5%AD%A6%E4%B9%A0vboxmanage%E5%AE%9A%E5%88%B6/</guid>
      <description>Vagrant Configuration - VBoxManage Customizations里面有讲到通过VBoxManage修改VirtualBox虚拟机。而VBoxManage modifyvm里面细致的介绍了所有设置。
VBoxManage modifyvm设置 接触过的VBoxManage modifyvm设置 下面就仔细研究一下我看到过的modifyvm设置：
# -*- mode: ruby -*- # vi: set ft=ruby : VAGRANTFILE_API_VERSION = &amp;quot;2&amp;quot; Vagrant.require_version &amp;quot;&amp;gt;= 1.6.3&amp;quot; Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.provider &amp;quot;virtualbox&amp;quot; do |vb| # --memory设置用来指定分配的内存，单位为MB # 可简写为vb.memory=8192 vb.customize [&#39;modifyvm&#39;, :id, &#39;--memory&#39;, &#39;8192&#39;] # --cpus设置用来指定虚拟机的虚拟CPU个数 # 可简写为vb.cpus=3 vb.customize [&#39;modifyvm&#39;, :id, &#39;--cpus&#39;, &#39;3&#39;] # --cpuexecutioncap &amp;lt;1-100&amp;gt;设置用来指定虚拟CPU可用的CPU时间比例。 # 值50意味无论VM使用多少个虚拟虚拟CPU，都不会超过宿主机CPU时间的一半。 vb.customize [&#39;modifyvm&#39;, :id, &#39;--cpuexecutioncap&#39;, &#39;75&#39;] # --natdnshostresolver&amp;lt;1-N&amp;gt; on|off用来指定NAT使用宿主机的解析机制处理DNS请求。 vb.customize [&#39;modifyvm&#39;, :id, &#39;--natdnshostresolver1&#39;, &#39;on&#39;] # --natdnsproxy&amp;lt;1-N&amp;gt; on|off用来指定NAT将所有客户机DNS请求代理到宿主机的DNS服务器。 vb.</description>
    </item>
    
    <item>
      <title>[Vagrant] 学习一下Vagrant的Provider类型</title>
      <link>https://mryqu.github.io/post/vagrant_%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Bvagrant%E7%9A%84provider%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 Jul 2018 06:05:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant_%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Bvagrant%E7%9A%84provider%E7%B1%BB%E5%9E%8B/</guid>
      <description>偶尔动了心思，想自己装一个Wiki。就按照MediaWiki-Vagrant，装一个Vagrant版的MediaWiki玩玩。MediaWiki全球最著名的开源wiki程序，运行于PHP+MySQL环境。MediaWiki从2002年2月25日被作为维基百科全书的系统软件，并有大量其他应用实例。 顺手研究了一下mediawiki/vagrant项目的Vagrantfile文件，跟我们自己项目用的Vagrantfile仅仅配置了一个VirtualBox provider不同，它配置了VirtualBox、VMWare Fusion、Microsoft Hyper-V、LXC、Parallels和libvirt (KVM/QEMU)六种provider。 在Vagrant的网站上仅仅提及了默认的VirtualBox、VMware、Docker、Hyper-V四款provider。那到底Vagrant有多少provider类型呢？ 从Vagrant Cloud上可知有22种provider类型的Vagrant box镜像可供下载： - aws - cloudstack - digitalocean - docker - google - hyperv - libvirt - lxc - openstack - parallels - qemu - rackspace - softlayer - veertu - virtualbox - vmware - vmware_desktop - vmware_fusion - vmware_ovf - vmware_workstation - vsphere - xenserver</description>
    </item>
    
    <item>
      <title>[AWS] 安装AWSCLI </title>
      <link>https://mryqu.github.io/post/aws_%E5%AE%89%E8%A3%85awscli/</link>
      <pubDate>Mon, 02 Jul 2018 05:40:10 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/aws_%E5%AE%89%E8%A3%85awscli/</guid>
      <description>想玩玩AWS CLI，就从https://aws.amazon.com/cli/装了一个，但是一执行就是出LookupError: unknown encoding: cp65001错误，查了一下据说是Python2.7导致的。 首先去https://www.python.org/下载了最新的Python3.7.0。然后重新安装AWS CLI，依旧出错，只好卸载。 查看是否安装pip，结果发现没有。根据https://packaging.python.org/tutorials/installing-packages/中的提示下载了get-pip.py，执行python get-pip.py，成功安装好pip。
C:\&amp;gt;pip --version pip 10.0.1 from c:\users\mryqu\appdata\local\programs\python\python37-32\lib\site-packages\pip (python 3.7  最后使用pip安装AWS CLI:
C:\&amp;gt;pip install awscli Collecting awscli Downloading https://files.pythonhosted.org/packages/1b/1b/7446d52820533164965f7e7d08cee70b170c78fbbcbd0c7a11ccb9187be6/awscli-1.15.49-py2.py3-none-any.whl (1.3MB) 100% |████████████████████████████████| 1.3MB 6.6MB/s Collecting docutils&amp;gt;=0.10 (from awscli) Downloading https://files.pythonhosted.org/packages/36/fa/08e9e6e0e3cbd1d362c3bbee8d01d0aedb2155c4ac112b19ef3cae8eed8d/docutils-0.14-py3-none-any.whl (543kB) 100% |████████████████████████████████| 552kB 3.3MB/s Collecting s3transfer&amp;lt;0.2.0,&amp;gt;=0.1.12 (from awscli) Downloading https://files.pythonhosted.org/packages/d7/14/2a0004d487464d120c9fb85313a75cd3d71a7506955be458eebfe19a6b1d/s3transfer-0.1.13-py2.py3-none-any.whl (59kB 100% |████████████████████████████████| 61kB 787kB/s Collecting botocore==1.10.48 (from awscli) Downloading https://files.pythonhosted.org/packages/0b/56/44067a8f0cae5f33007e7cbdbaac67cbd9fa598c733ad25eb8f252288fe9/botocore-1.10.48-py2.py3-none-any.whl (4.4MB 100% |████████████████████████████████| 4.4MB 6.6MB/s Collecting PyYAML&amp;lt;=3.12,&amp;gt;=3.10 (from awscli) Downloading https://files.</description>
    </item>
    
    <item>
      <title>使用Consul DNS接口</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consuldns%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 21 Jun 2018 06:08:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consuldns%E6%8E%A5%E5%8F%A3/</guid>
      <description>Consul提供了两个查询接口：HTTP和DNS。DNS接口允许应用程序在没有与consul高度集成的情况下使用服务发现。 以下面这个小Consul集群为例：
root@consul:/# /usr/bin/consul members Node Address Status Type Build Protocol DC configuration 172.17.0.7:8301 alive client X.Y.Z 2 dc1 consul 172.17.0.2:8301 alive server X.Y.Z 2 dc1 httpd 172.17.0.4:8301 alive client X.Y.Z 2 dc1 logon 172.17.0.8:8301 alive client X.Y.Z 2 dc1 postgres 172.17.0.3:8301 alive client X.Y.Z 2 dc1 rabbitmq 172.17.0.6:8301 alive client X.Y.Z 2 dc1  可以通过DNS接口以&amp;lt;dnode&amp;gt;.node[.datacenter].&amp;lt;domain&amp;gt;的形式查询节点地址，也可以[tag.]&amp;lt;dservice&amp;gt;.service[.datacenter].&amp;lt;domain&amp;gt;的形式查询服务地址。
root@httpd:/# dig @127.0.0.1 -p53 postgres.node.consul ANY ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.5-9-Debian &amp;lt;&amp;lt;&amp;gt;&amp;gt; @127.0.0.1 -p53 postgres.</description>
    </item>
    
    <item>
      <title>Vagrant折腾记</title>
      <link>https://mryqu.github.io/post/vagrant%E6%8A%98%E8%85%BE%E8%AE%B0/</link>
      <pubDate>Tue, 19 Jun 2018 05:59:52 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant%E6%8A%98%E8%85%BE%E8%AE%B0/</guid>
      <description>自从用了OpenStack，真是很久没玩Vagrant。偶尔想用用，问题不断，废了一点功夫才解决。
遭遇VBoxManage.exe: error $ vagrant up Bringing machine &#39;xdevimg&#39; up with &#39;virtualbox&#39; provider... ==&amp;gt; xdevimg: Checking if box &#39;devimage-ubuntu&#39; is up to date... ==&amp;gt; xdevimg: A newer version of the box &#39;devimage-ubuntu&#39; is available! You currently ==&amp;gt; xdevimg: have version &#39;0.13.0&#39;. The latest is version &#39;0.13.2&#39;. Run ==&amp;gt; xdevimg: `vagrant box update` to update. ==&amp;gt; xdevimg: Clearing any previously set forwarded ports... ==&amp;gt; xdevimg: Clearing any previously set network interfaces.</description>
    </item>
    
    <item>
      <title>[AWS] 学习AWS上SAS联合账户的使用</title>
      <link>https://mryqu.github.io/post/aws_%E5%AD%A6%E4%B9%A0aws%E4%B8%8Asas%E8%81%94%E5%90%88%E8%B4%A6%E6%88%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 18 Apr 2018 06:11:04 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/aws_%E5%AD%A6%E4%B9%A0aws%E4%B8%8Asas%E8%81%94%E5%90%88%E8%B4%A6%E6%88%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>今天顺利学完《SAS Federated Accounts on Amazon Web Services》课程，测验全都答/蒙对了。 1. 创建了EC2实例。
2. 第一次用MobaXterm。相对Putty，省了将.pem SSH密钥通过PuTTYgen工具转换成.ppk格式这一步操作。 3. 在/etc/resolv.conf文件中增加了几个nameserver以指定单位的DNS，在search项增加了多个域名以解析单位的机器名。
4. 安装libXext.x86_64、libXp.x86_64、libXtst.x86_64、xorg-x11-xauth.x86_64、xorg-x11-apps等包以支持图形显示。</description>
    </item>
    
    <item>
      <title>[Gradle] 遭遇 Unable to process incoming event &#39;ProgressComplete&#39; (ProgressCompleteEvent)</title>
      <link>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</link>
      <pubDate>Thu, 30 Nov 2017 06:08:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</guid>
      <description>最近开始玩一个项目，结果gradle build总是报错：
FAILURE: Build failed with an exception. * What went wrong: Unable to process incoming event &#39;ProgressComplete &#39; (ProgressCompleteEvent)  参考了帖子Build fails with “Unable to process incoming event ‘ProgressComplete ’ (ProgressCompleteEvent)”：
The Workaround: use the --console plain gradle command line switch The Fix: If you use git + git-bash, upgrade to git 2.x.x (2.9.3 is current and works for me) If you use DOS, try increasing your screen buffer size.</description>
    </item>
    
    <item>
      <title>OpenGrok使用感受</title>
      <link>https://mryqu.github.io/post/opengrok%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97/</link>
      <pubDate>Mon, 12 Jun 2017 06:22:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/opengrok%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97/</guid>
      <description>之前为了学习项目涉及的C/C++代码，试用过SourceInsight，后来改成Vim+Exuberant Ctags+Cscope。最近一个美国同事给了个链接，原来那边的兄弟是用OpenGrok搜项目代码的！ OpenGrok是一个快速、便于使用的源码搜索引擎与对照引擎，它能够帮助我们快速地搜索、定位、对照代码树。它可以理解各种程序语言和文件格式，及Mercurial、Git、SCCS、RCS、CVS、Subversion、Teamware、ClearCase、Perforce、Monotone和Bazaar等版本控制历史记录。OpenGrok是OpenSolaris操作系统源文件浏览和搜索的工具。 OpenGrok由Java语言实现，需要Java 1.8、一个Servlet容器以及Exuberant Ctags。 用完就一个字：爽！
参考 OpenGrok主页
GitHub：OpenGrok/OpenGrok
OpenGrok：Comparison with Similar Tools
OpenGrok：Supported Languages and Formats
OpenGrok：Supported Revision Control Systems
Ubuntu环境下OpenGrok的安装及使用</description>
    </item>
    
    <item>
      <title>玩一下uptodate-gradle-plugin插件</title>
      <link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Fri, 03 Mar 2017 05:57:34 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</guid>
      <description>玩了一下uptodate-gradle-plugin插件，使用这个插件后执行gradle uptodate 可以看到那些库在Maven Central仓库有新版本，用于辅助判断是否需要更新Java库。 我一般不追新库，所以这个插件对我的用处小，看一看玩一玩，仅此而已。</description>
    </item>
    
    <item>
      <title>恢复误删文件内容</title>
      <link>https://mryqu.github.io/post/%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Fri, 02 Dec 2016 05:49:46 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>昨天鼠标有毛病，本意是选择Ultraedit中的文件，结果莫名其妙关闭了。重新打开后，内容都丢了，而且还认为是正藏保存的。傻眼了，记了一年多的内容呀！ 今天终于找到恢复方法了，右键点击文件-查看属性-选择以前版本-选择版本并恢复。我的天呀，终于不必愁眉苦脸了！</description>
    </item>
    
    <item>
      <title>尝试Travis CI</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95travis_ci/</link>
      <pubDate>Sat, 05 Nov 2016 06:00:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95travis_ci/</guid>
      <description>从GitHub上下载的很多项目都包含一个.travis.yml文件，一开始不知道是什么鬼，后来才知道是Travis CI配置文件。 Travis CI是基于云的持续集成项目，供GitHub上的开源项目使用。对于GitHub上的项目来说，Travis CI无需自己部署服务器，仅需添加一个.travis.yml文件就可进行持续集成，入侵性很小，所以很多项目都纷纷采用了。
Travis CI与Jenkins的比较 对于企业开发来收，目前主流还是Jenkins/Hudson，下面可以看一下二者的功能比较。 名称平台许可构建器：Windows构建器：Java构建器：其他通知集成 IDE集成 其他Jenkins-HudsonWeb容器Creative Commons和 MITMSBuild
NAntAnt
Maven&amp;nbsp;2
KundoCmake
Gant
Gradle
Grails, Phing
Rake
Ruby
SCons
Python
shell script
command-lineAndroid
Email
Google Calendar
IRC
XMPP
RSS
Twitter
Slack
Catlight
CCMenu
CCTrayEclipse
IntelliJ IDEA
NetBeansBugzilla
Google Code
Jira
Bitbucket
Redmine
FindBugs
Checkstyle
PMD&amp;nbsp;and&amp;nbsp;Mantis
Trac
HP ALMTravis CI已在云上部署MIT无Ant
Maven
GradleC
C++
Clojure
Elixir
Erlang
Go
Groovy
Haskell
Java
Node.js
Perl
PHP
Python
Ruby
Rust</description>
    </item>
    
    <item>
      <title>update-alternatives与JAVA_HOME</title>
      <link>https://mryqu.github.io/post/update-alternatives%E4%B8%8Ejava_home/</link>
      <pubDate>Wed, 02 Nov 2016 06:15:02 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/update-alternatives%E4%B8%8Ejava_home/</guid>
      <description>测试 /etc/profile配置 export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin  使用update-alternatives切换JAVA hadoop@note50064:~$ which java /usr/bin/java hadoop@note50064:~$ sudo update-alternatives --config java There are 2 choices for the alternative . Selection Path Priority Status ------------------------------------------------------------ 0 /usr/lib/jvm/java-7-oracle/jre/bin/java 1072 auto mode * 1 /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java 1071 manual mode 2 /usr/lib/jvm/java-7-oracle/jre/bin/java 1072 manual mode Press enter to keep the current choice[*], or type selection number: hadoop@note50064:~$ ls -l /usr/bin/java lrwxrwxrwx 1 root root 22 Nov 21 03:26 /usr/bin/java -&amp;gt; /etc/alternatives/java hadoop@note50064:~$ ls -l /etc/alternatives/java lrwxrwxrwx 1 root root 46 Nov 1 01:44 /etc/alternatives/java -&amp;gt; /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java hadoop@note50064:~$ java -version java version &amp;quot;1.</description>
    </item>
    
    <item>
      <title>[Gradle] 将多项目转换成Maven项目</title>
      <link>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Fri, 02 Sep 2016 05:46:07 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</guid>
      <description>手头有一个构建多项目的Gradle构建脚本，但是一个哥们问我能不能换成Maven的，搜到一篇gradle项目与maven项目相互转化，照着实践，证明多项目构建也是可行的。
文件结构介绍  ts-demo目录  setting.gradle build.gradle ts-service目录 build.gradle src目录 ts-webapp目录 build.gradle src目录   ts-demo/setting.gradle rootProject.name = &#39;ts-demo&#39; include &amp;quot;ts-service&amp;quot; include &amp;quot;ts-webapp&amp;quot; project(&amp;quot;:ts-service&amp;quot;).name = &amp;quot;ts-service&amp;quot; project(&amp;quot;:ts-webapp&amp;quot;).name = &amp;quot;ts-webapp&amp;quot;  ts-demo/build.gradle buildscript { repositories { mavenCentral() } } allprojects { apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;maven&#39; repositories { mavenCentral() } group = &#39;com.yqu&#39; version = &#39;0.1.0&#39; task writeNewPom { pom { project { inceptionYear &#39;2016&#39; licenses { license { name &#39;The Apache Software License, Version 2.</description>
    </item>
    
    <item>
      <title>搞清楚CONSUL_PORT_8500_TCP_ADDR</title>
      <link>https://mryqu.github.io/post/%E6%90%9E%E6%B8%85%E6%A5%9Aconsul_port_8500_tcp_addr/</link>
      <pubDate>Mon, 22 Aug 2016 05:41:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%90%9E%E6%B8%85%E6%A5%9Aconsul_port_8500_tcp_addr/</guid>
      <description>Consul集群里既有Server也有Client。那除了Consul serverleader，其他节点怎么加入这个Consul集群里呢？我目前看到的Docker方案是其他节点使用consul agent -join$CONSUL_PORT_8500_TCP_ADDR加入Consul集群的。那么CONSUL_PORT_8500_TCP_ADDR是怎么设置到其他容器节点的？
root@httpd:/# env CONSUL_PORT_8300_TCP_PORT=8300 CONSUL_PORT_53_TCP_PORT=53 VAGRANT_CONSUL_1_PORT_8301_UDP_ADDR=172.17.0.2 HOSTNAME=httpd CONSUL_PORT_8301_TCP_PROTO=tcp VAGRANT_CONSUL_1_PORT_8302_TCP_PORT=8302 VAGRANT_CONSUL_1_PORT_53_UDP_PROTO=udp CONSUL_1_PORT_8300_TCP_ADDR=172.17.0.2 VAGRANT_CONSUL_1_PORT_8301_TCP_ADDR=172.17.0.2 CONSUL_1_PORT_8400_TCP=tcp://172.17.0.2:8400 CONSUL_1_PORT_53_UDP=udp://172.17.0.2:53 CONSUL_1_PORT_8300_TCP_PROTO=tcp APACHE_RUN_USER=www-data VAGRANT_CONSUL_1_PORT_8301_TCP_PROTO=tcp CONSUL_PORT_8301_UDP=udp://172.17.0.2:8301 VAGRANT_CONSUL_1_PORT_8400_TCP_ADDR=172.17.0.2 CONSUL_PORT_53_TCP_ADDR=172.17.0.2 VAGRANT_CONSUL_1_PORT_8301_UDP_PORT=8301 CONSUL_1_PORT_53_TCP=tcp://172.17.0.2:53 CONSUL_1_PORT_8300_TCP_PORT_START=8300 CONSUL_PORT_53_TCP_PROTO=tcp VAGRANT_CONSUL_1_PORT_8302_TCP=tcp://172.17.0.2:8302 VAGRANT_CONSUL_1_PORT_8300_UDP_END=udp://172.17.0.2:8302 CONSUL_1_NAME=/vagrant_httpd_1/consul_1 CONSUL_1_PORT_8300_UDP_PORT_END=8302 VAGRANT_CONSUL_1_PORT_53_TCP_PROTO=tcp CONSUL_1_PORT_8500_TCP=tcp://172.17.0.2:8500 CONSUL_PORT_53_UDP_ADDR=172.17.0.2 CONSUL_PORT_8300_TCP_PORT_START=8300 CONSUL_1_PORT_53_TCP_PORT=53 CONSUL_1_PORT_8302_UDP_PORT=8302 VAGRANT_CONSUL_1_PORT_8400_TCP=tcp://172.17.0.2:8400 CONSUL_1_PORT_8300_UDP_END=udp://172.17.0.2:8302 CONSUL_PORT_8302_UDP_PORT=8302 CONSUL_PORT_8302_TCP_ADDR=172.17.0.2 VAGRANT_CONSUL_1_PORT_8301_UDP_PROTO=udp CONSUL_1_PORT_8302_TCP_PORT=8302 CONSUL_1_PORT_8301_TCP=tcp://172.17.0.2:8301 CONSUL_ENV_CONSUL_OPTIONS=-bootstrap -client 0.0.0.0 VAGRANT_CONSUL_1_PORT_8302_UDP_PORT=8302 CONSUL_1_PORT_8302_UDP=udp://172.17.0.2:8302 CONSUL_PORT_53_UDP_PORT=53 VAGRANT_CONSUL_1_PORT_8302_UDP_PROTO=udp VAGRANT_CONSUL_1_PORT_8300_TCP_START=tcp://172.17.0.2:8300 CONSUL_PORT_8302_UDP_ADDR=172.17.0.2 CONSUL_PORT_8300_TCP=tcp://172.17.0.2:8300 CONSUL_1_PORT_8302_TCP_ADDR=172.17.0.2 CONSUL_1_PORT_53_TCP_PROTO=tcp VAGRANT_CONSUL_1_PORT_53_TCP=tcp://172.17.0.2:53 CONSUL_1_PORT_8302_UDP_PROTO=udp VAGRANT_CONSUL_1_PORT_8300_TCP=tcp://172.17.0.2:8300 CONSUL_1_PORT_8301_TCP_PROTO=tcp CONSUL_PORT_8400_TCP=tcp://172.17.0.2:8400 VAGRANT_CONSUL_1_PORT_8500_TCP_PROTO=tcp CONSUL_PORT_8301_TCP_PORT=8301 VAGRANT_CONSUL_1_PORT_53_UDP_PORT=53 VAGRANT_CONSUL_1_PORT_8300_TCP_PROTO=tcp CONSUL_1_PORT_8301_UDP_ADDR=172.17.0.2 CONSUL_1_PORT_8300_TCP_START=tcp://172.17.0.2:8300 APACHE_LOG_DIR=/var/log/apache2 CONSUL_PORT_53_TCP=tcp://172.17.0.2:53 VAGRANT_CONSUL_1_PORT_8301_TCP_PORT=8301 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CONSUL_PORT_8500_TCP_ADDR=172.</description>
    </item>
    
    <item>
      <title>在Ubuntu中识别当前Init系统</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E8%AF%86%E5%88%AB%E5%BD%93%E5%89%8Dinit%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 05 Aug 2016 05:53:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E8%AF%86%E5%88%AB%E5%BD%93%E5%89%8Dinit%E7%B3%BB%E7%BB%9F/</guid>
      <description>Ubuntu 14.04 首先用uname命令查看一下系统信息：
ubuntu@node50069:~$ uname -a Linux node50069 3.19.0-25-generic #26~14.04.1-Ubuntu SMP Fri Jul 24 21:16:20 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux  用pstree命令查看一下ID为1的进程，原来是init：可以下面几个命令查看init进程所用的命令信息： - ps -efa|grep init - type init - sudo stat /proc/1/exe
最终通过&amp;rdquo;sudo init &amp;ndash;version&amp;rdquo;可知当前的Init系统为upstart：Ubuntu 15.04 首先查看一下系统信息：
vagrant@vagrant-ubuntu-trusty:~$ uname -a Linux vagrant-ubuntu-trusty 3.19.0-15-generic #15-Ubuntu SMP Thu Apr 16 23:32:37 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux  用pstree命令查看一下ID为1的进程，原来是systemd：参考 WIKI：init</description>
    </item>
    
    <item>
      <title>微信语音导出和转换</title>
      <link>https://mryqu.github.io/post/%E5%BE%AE%E4%BF%A1%E8%AF%AD%E9%9F%B3%E5%AF%BC%E5%87%BA%E5%92%8C%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 18 Jun 2016 05:23:05 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%BE%AE%E4%BF%A1%E8%AF%AD%E9%9F%B3%E5%AF%BC%E5%87%BA%E5%92%8C%E8%BD%AC%E6%8D%A2/</guid>
      <description>用微信语音发送了一段儿子朗诵诗，想导出来做个念想，结果发现还挺麻烦。 - 在tencent/MicsoMsg目录下有名字很长的文件夹就是微信聊天记录存放的文件夹，每登陆一个微信就会产生一个名字很长的文件夹。在这个目下下有个Voice2目录，将下面的子目录按照日期排序缩小范围，查找疑似子目录下的amr文件，想办法拷贝到计算机中。 - 一开始我按照网上的攻略用格式工厂转换成mp3，报错。用Ultraedit打开文件，头部显示有silk_v3。SILKv3编码是Skype向第三方开发人员和硬件制造商提供免版税认证(RF)的Silk宽带音频编码器，Skype后来将其开源。在Github上找到了https://github.com/kn007/silk-v3-decoder，搞定！</description>
    </item>
    
    <item>
      <title>在Outlook 2013中查看邮件的消息头</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8outlook_2013%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%82%AE%E4%BB%B6%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%B4/</link>
      <pubDate>Thu, 09 Jun 2016 05:24:46 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8outlook_2013%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%82%AE%E4%BB%B6%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%B4/</guid>
      <description>双击邮件后选择File菜单，点击Porperties按钮：查看Internet headers：</description>
    </item>
    
    <item>
      <title>在Linux终端下启动SAS管理控制台</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%90%AF%E5%8A%A8sas%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/</link>
      <pubDate>Tue, 29 Mar 2016 21:50:15 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%90%AF%E5%8A%A8sas%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/</guid>
      <description>在Linux终端下没有X11显示系统的情况下，可以通过如下命令将X11转移到其他X视窗服务器以显示SMC界面：
$ export DISPLAY=[machine]:[port] $ pwd /local/install/SASServer/SASHome/SASManagementConsole/9.4 $ ./sasmc  </description>
    </item>
    
    <item>
      <title>遇到&#34;vagrant up&#34;无法读取box元数据问题</title>
      <link>https://mryqu.github.io/post/%E9%81%87%E5%88%B0vagrant_up%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96box%E5%85%83%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 18 Mar 2016 06:46:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%81%87%E5%88%B0vagrant_up%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96box%E5%85%83%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</guid>
      <description>昨天在某个Windows Server2008上升级了Vagrant (1.8.1)和VitualBox(5.0.16)，然后vagrant up就开始出问题了。
C:\foo&amp;gt;vagrant up Bringing machine &#39;xfoo&#39; up with &#39;virtualbox&#39; provider... ==&amp;gt; xfoo: Box ‘foo-ubuntu‘ could not be found. Attempting to find and install... xfoo: Box Provider: virtualbox xfoo: Box Version: &amp;gt;= 0.12.0, &amp;lt; 1.0.0 ==&amp;gt; xfoo: Box file was not detected as metadata. Adding it directly... You specified a box version constraint with a direct box file path. Box version constraints only work with boxes from Vagrant Cloud or a custom box host.</description>
    </item>
    
    <item>
      <title>升级Windows版Git客户端</title>
      <link>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7windows%E7%89%88git%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 17 Mar 2016 06:10:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7windows%E7%89%88git%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>今天在公司收到通知，说Git又有安全漏洞了，需要升级到最新的2.7.3。扫了一眼Get ready to patch Git servers, clients – nasty-looking bugs surface，漏洞涉及到2.x、1.9和1.7版本。 我本机装的是git version 1.9.5.msysgit.0，这才发现MsysGit去年八月份就被Git for Windows 2.x取代了。这次顺手把Git Extensions也给升级到2.48.05了。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 我服务器上的GCC版本不支持C&#43;&#43;11特性</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E6%88%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84gcc%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81c&#43;&#43;11%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 25 Dec 2015 06:10:29 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E6%88%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84gcc%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81c&#43;&#43;11%E7%89%B9%E6%80%A7/</guid>
      <description>用了点C++11特性，结果编译失败，编译参数加&amp;rdquo;-std=c++0x&amp;rdquo;，结果识别不出来。
$ g++ -v Using built-in specs. Target: amd64-undermydesk-freebsd Configured with: FreeBSD/amd64 system compiler Thread model: posix gcc version 4.2.1 20070719 [FreeBSD]  C++0x/C++11 Support in GCC提到GCC 4.3版本之后才支持C++11特性，白折腾一把！ 好吧，我用gcc docker!</description>
    </item>
    
    <item>
      <title>Visual Studio: 使用简体中文（GB2312）编码加载文件, 有些字节已用Unicode替换字符更换</title>
      <link>https://mryqu.github.io/post/visual_studio_%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87gb2312%E7%BC%96%E7%A0%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6_%E6%9C%89%E4%BA%9B%E5%AD%97%E8%8A%82%E5%B7%B2%E7%94%A8unicode%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E6%9B%B4%E6%8D%A2/</link>
      <pubDate>Mon, 21 Dec 2015 05:55:02 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/visual_studio_%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87gb2312%E7%BC%96%E7%A0%81%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6_%E6%9C%89%E4%BA%9B%E5%AD%97%E8%8A%82%E5%B7%B2%E7%94%A8unicode%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E6%9B%B4%E6%8D%A2/</guid>
      <description>遭遇下列VS2010错误: Some bytes have been replaced with the Unicodesubstitution character while loading file base64.cpp with ChineseSimplified (GB2312) encoding. Saving the file will not preserve theoriginal file contents. 我的Visual Studio已经勾选了Auto-detect UTF-8 encoding withoutsignature:Ultraedit不能正常显示base64.cpp，但Sublime Text能正常显示。 原因是base64.cpp并不是UTF-8编码，但是包含一个十六进制为&amp;rdquo;E9&amp;rdquo;的字符，即带重音符的e。由于我的系统locale是RPC，所以显示不正常，估计系统locale改成CP1252 - Windows 拉丁语1代码页就可以了。用Sublime Text将其转存为UTF-8编码当然也可以。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用NM查看目标文件的符号列表</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8nm%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 18 Dec 2015 06:10:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8nm%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8/</guid>
      <description>练习使用nm查看目标文件的符号列表。此外发现G++竟然创建了两套构造函数和析构函数。
nm命令  -a或&amp;ndash;debug-syms：显示调试符号。 -B：等同于&amp;ndash;format=bsd，用来兼容MIPS的nm。 -C或&amp;ndash;demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D或&amp;ndash;dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -fformat：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g或&amp;ndash;extern-only：仅显示外部符号。 -n、-v或&amp;ndash;numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p或&amp;ndash;no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P或&amp;ndash;portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-fposix。 -s或&amp;ndash;print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r或&amp;ndash;reverse-sort：反转排序的顺序(例如，升序变为降序)。 &amp;ndash;size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -tradix或&amp;ndash;radix=radix：使用radix进制显示符号值。radix只能为&amp;rdquo;d&amp;rdquo;表示十进制、&amp;rdquo;o&amp;rdquo;表示八进制或&amp;rdquo;x&amp;rdquo;表示十六进制。 &amp;ndash;target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u或&amp;ndash;undefined-only：仅显示没有定义的符号(那些外部符号)。 -l或&amp;ndash;line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V或&amp;ndash;version：显示nm的版本号。 &amp;ndash;help：显示nm的任选项。  练习 symtest.hpp #include &amp;lt;iostream&amp;gt; class SymTest { SymTest(); SymTest(int x); ~SymTest(); void foo(); };  symtest.cpp #include &amp;quot;symtest.hpp&amp;quot; SymTest::SymTest() { printf(&amp;quot;SymTest::SymTest\n&amp;quot;); } SymTest::SymTest(int x) { printf(&amp;quot;SymTest::SymTest(int)\n&amp;quot;); } SymTest::~SymTest() { printf(&amp;quot;SymTest::~SymTest\n&amp;quot;); } void SymTest::foo() { printf(&amp;quot;SymTest::foo\n&amp;quot;); }  编译 NM: -g 仅显示外部符号 -C 显示用户级名字 学习了StackOverflow上的帖子Dual emission of constructor symbols，才了解这是G++的一个已知问题，两套构造函数分别是complete objectconstructor和base object constructor。</description>
    </item>
    
    <item>
      <title>Sublime Text2&#43;Ctags&#43;Cscope使用实践</title>
      <link>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 09 Dec 2015 07:07:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</guid>
      <description>安装 安装Package Control 步骤见https://packagecontrol.io/installation#st2
安装CTags插件  通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Ctags插件（快捷键Ctrl+Shift+P，输入install） 打开Preference -&amp;gt; Package Settings -&amp;gt; Ctags -&amp;gt;Settings-Default和Setting-User，将Settings-Default中的内容拷贝到Setting-User中，将&amp;rdquo;command&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;rdquo; 填入Ctags.exe的路径位置 打开C工程根目录，在上点击右键，选择Ctags:Rebuild tags  安装Cscope插件  同样通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Cscope插件（快捷键Ctrl+Shift+P，输入install） 通过cscope –Rb在C工程根目录创建cscope.out文件 Cscope在ST2上没有包配置菜单，需要打开CscopeSublime.sublime-settings文件(我的机器在C:/Users/yqu/AppData/Roaming/SublimeText 2/Packages/Cscope目录下)，将 &amp;ldquo;executable&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;ldquo;填入Cscope.exe的路径位置,将 &amp;ldquo;database_location&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的&amp;rdquo;&amp;ldquo;填入cscope.out的路径位置。  使用 CTags命令 |Command|Key Binding|Alt Binding|Mouse Binding |&amp;mdash;&amp;ndash; |rebuild_ctags|ctrl+t, ctrl+r| &amp;nbsp; | &amp;nbsp; |navigate_to_definition|ctrl+t, ctrl+t|ctrl+&amp;gt;|ctrl+shift+left_click |jump_prev|ctrl+t, ctrl+b|ctrl+&amp;lt;|ctrl+shift+right_click |show_symbols|alt+s| &amp;nbsp;| &amp;nbsp; |show_symbols (all files)|alt+shift+s| &amp;nbsp;| &amp;nbsp; |show_symbols (suffix)|ctrl+alt+shift+s| &amp;nbsp;| &amp;nbsp;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用readelf</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8readelf/</link>
      <pubDate>Tue, 08 Dec 2015 06:06:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8readelf/</guid>
      <description>在计算机科学中，ELF文件（Executableand LinkableFormat）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件，是UNIX系统实验室（USL）作为应用程序二进制接口（ApplicationBinaryInterface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。1999年，被86open项目选为x86架构上的类Unix操作系统的二进制文件标准格式，用来取代COFF。因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上。 ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program headertable）、节（Section）和节头表（Section headertable）。实际上，一个文件中不一定包含全部内容，而且他们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。 而readelf用于显示ELF文件的信息。 Usage: readelf &amp;lt;option(s)&amp;gt; elf-file(s) Display information about the contents of ELF format files Options are: -a --all 全部 Equivalent to: -h -l -S -s -r -d -V -A -I -h --file-header ELF头 Display the ELF file header -l --program-headers 程序头表 Display the program headers --segments An alias for --program-headers -S --section-headers 节头 Display the sections&#39; header --sections An alias for --section-headers -g --section-groups 节组 Display the section groups -t --section-details 节细节 Display the section details -e --headers 全部头 Equivalent to: -h -l -S -s --syms 符号表 Display the symbol table --symbols An alias for --syms --dyn-syms 动态符号表 Display the dynamic symbol table -n --notes 核心注释 Display the core notes (if present) -r --relocs 重定位 Display the relocations (if present) -u --unwind Display the unwind info (if present) -d --dynamic 动态节 Display the dynamic section (if present) -V --version-info 版本节 Display the version sections (if present) -A --arch-specific 架构信息 Display architecture specific information (if any) -c --archive-index 该架构下符号/文件索引 Display the symbol/file index in an archive -D --use-dynamic Use the dynamic section info when displaying symbols -x --hex-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as bytes -p --string-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as strings -R --relocated-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as relocated bytes -w[lLiaprmfFsoRt] or --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames, =frames-interp,=str,=loc,=Ranges,=pubtypes, =gdb_index,=trace_info,=trace_abbrev,=trace_aranges, =addr,=cu_index] 显示DWARF2调试节 Display the contents of DWARF2 debug sections --dwarf-depth=N Do not display DIEs at depth N or greater --dwarf-start=N Display DIEs starting with N, at the same depth or deeper -I --histogram 柱状图 Display histogram of bucket list lengths -W --wide 输出宽度 Allow output width to exceed 80 characters @&amp;lt;file&amp;gt; Read options from &amp;lt;file&amp;gt; -H --help 帮助 Display this information -v --version 版本 Display the version number of readelf  练习 - 查看ELF文件头 hadoop@node51054:/usr/bin$ readelf -h curl ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x4023b1 Start of program headers: 64 (bytes into file) Start of section headers: 152600 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 27  练习 - 查看符号表 hadoop@node51054:/usr/bin$ readelf -s curl Symbol table &#39;.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用ldd</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8ldd/</link>
      <pubDate>Mon, 07 Dec 2015 06:05:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8ldd/</guid>
      <description>ldd是用来查看共享库依赖的Shell脚本命令。下面来看一下ldd命令的参数。 - -v：显示所有信息，例如包括符号版本信息。 - -u：显示没有使用的直接依赖。 - -d：执行重新定位，报告任何缺失对象（仅针对ELF） - -r：对数据对象和函数执行重新定位，报告任何缺失对象或函数（仅针对ELF）
Oracle - Linker and Libraries Guide - Relocations介绍了重新定位技术的来龙去脉，也介绍了ldd命令的相关使用。
ldd练习 hadoop@node51054:/usr/bin$ ldd curl linux-vdso.so.1 =&amp;gt; (0x00007ffefe989000) libcurl.so.4 =&amp;gt; /usr/lib/x86_64-linux-gnu/libcurl.so.4 (0x00007fb86cf8f000) libz.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fb86cd76000) libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fb86cb58000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb86c790000) libidn.so.11 =&amp;gt; /usr/lib/x86_64-linux-gnu/libidn.so.11 (0x00007fb86c55d000) librtmp.so.0 =&amp;gt; /usr/lib/x86_64-linux-gnu/librtmp.so.0 (0x00007fb86c343000) libssl.so.1.0.0 =&amp;gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fb86c0e4000) libcrypto.so.1.0.0 =&amp;gt; /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007fb86bd08000) libgssapi_krb5.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007fb86bac1000) liblber-2.4.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/liblber-2.4.so.2 (0x00007fb86b8b2000) libldap_r-2.4.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libldap_r-2.4.so.2 (0x00007fb86b661000) /lib64/ld-linux-x86-64.so.2 (0x00007fb86d1f6000) libgnutls.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] GNU Binutils之ar和ranlib</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_gnu_binutils%E4%B9%8Bar%E5%92%8Cranlib/</link>
      <pubDate>Sun, 06 Dec 2015 07:36:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_gnu_binutils%E4%B9%8Bar%E5%92%8Cranlib/</guid>
      <description>GNU binutils是一组二进制工具集。包括：ld、as、addr2line、ar、gprof、nm、objcopy、objdump、ranlib、size、strings、strip等。本文重点学习一下其中的ar和ranlib。
ar命令 ar用于建立、修改、提取档案文件(archive)。archive是一个包含多个被包含文件的单一文件（也称之为库文件），其结构保证了可以从中检索并得到原始的被包含文件（称之为archive中的member）。member的原始文件内容、模式（权限）、时间戳、所有者和组等属性都被保存在archive中。member被提取后，他们的属性被恢复到初始状态。 ar命令第一个参数可混合指令代码（operationcode p）和修饰符标志（modifier flags mod），可按意愿添加一个折线。
ar [--plugin name] [-X32_64] [-]p[mod [relpos] [count]] archive [member...]  指令参数  d：删除档案文件中的成员文件。 m：移动在档案文件中的成员文件，改变次序。可以借助修饰符标志a、b、i移动到指定位置。 p：显示档案文件中的成员文件内容。 q：将文件快速附加在档案文件末端。不检查、不替换已有同名成员文件，也不更新档案文件的符号表索引，修饰符标志a、b、i无效。然而很多不同系统都假设q指令重建档案文件的符号表索引，因此GNU将其按照r指令进行相同实现。 r：将文件插入档案文件中。检查并替换已有同名成员文件，重建档案文件的符号表索引，借助修饰符标志a、b、i将文件插入到指定位置。 t：显示档案文件中所包含的文件。 x：自档案文件中取出成员文件。  修饰符标志  a &amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之后。 b&amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之前。 c：建立档案文件。当更新档案文件时，档案文件不存在则创建档案文件，但会告警。此标志可抑制告警。 D：以确定模式工作。 f：为避免过长的文件名不兼容于其他系统的ar指令指令，可利用此参数，截掉要放入档案文件中过长的成员文件名称。 i &amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之前。（等同标志b） I：可接受但不使用。 N：使用count参数。当档案文件中存在多个同名成员，用于指定提取/删除的个数。 o：保留档案文件中文件的日期。如无此参数，则输出文件的修改时间为提取时间。 s：若档案文件中包含了对象模式，可利用此参数建立档案文件的符号表。 S：不产生符号表。 T：使指定档案文件成为瘦档案文件。例如将多个档案文件加入目标档案文件，目标档案文件可以包含符号索引及对源档案文件中成员文件的引用。 u：只将日期较新文件插入档案文件中。 v：程序执行时显示详细的信息。 V：显示版本信息。  练习 # 将当前目录下所有.o打包成libyqutest.a档案文件：r插入，v显示操作信息，s生成符号表。 ar rvs libyqutest.a *.o # 制作瘦档案文件：r插入，c建立档案文件，T指定为瘦档案文件。 ar -rcT libkx.a libke.a libxiao.a  ranlib命令 为档案文件创建符号索引。
ranlib [-vVt] archive  选项： - -v、-V或&amp;ndash;version：显示版本 - -t：更新档案文件符号映射的时戳。</description>
    </item>
    
    <item>
      <title>[Git] 操作Git仓库已删除文件</title>
      <link>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 11 Nov 2015 05:49:56 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</guid>
      <description>忙着工作，忽然出了一下神，觉得自己对Git仓库已删除文件的操作还没有练习过，决定找资料学习一下。
列举所有Git仓库已删除文件 下列命令可以列举出所有提交信息及被删除的文件：
git log --diff-filter=D --summary  下列命令可以列举出所有被删除的文件，不显示提交信息：
git log --diff-filter=D --summary | grep delete  列举一个Git仓库已删除文件的提交历史信息 仅使用git log无法查看Git仓库已删除文件的提交历史信息。
git log $deletedFile fatal: ambiguous argument &#39;deletedFile&#39;: unknown revision or path not in the working tree.  下列命令则可以：
git log -- $deletedFile  恢复一个Git仓库已删除文件 找到删除该文件的提交哈希值
git rev-list -n 1 HEAD -- $deletedFile  通过删除该文件提交（$deletingCommit）的前一个提交($deletingCommit~1)恢复已删除文件:
git checkout $deletingCommit~1 -- $deletedFile  参考 Is there a way in Git to list all deleted files in the repository</description>
    </item>
    
    <item>
      <title>[Git] 分支笔记</title>
      <link>https://mryqu.github.io/post/git_%E5%88%86%E6%94%AF%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 08 Nov 2015 05:44:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E5%88%86%E6%94%AF%E7%AC%94%E8%AE%B0/</guid>
      <description>最近接触了一些Git远程分支的操作和管理，做个笔记。
 创建本地分支  git branch [branch]  切换本地分支  git checkout [branch]  删除本地分支  git branch -D [branch]  重命名本地分支  git branch -m [oldbranch] [newbranch]  查看分支 ```
查看本地分支 （-v选项可以显示sha1和提交消息标题） git branch git branch -v
  # 查看远程分支 git branch -r git branch -rv
# 查看本地和远程分支 git branch -a git branch -av
- 向远程分支推送（远程分支不存在则会创建远程分支）  # 期望本地分支与远程分支同名，可以先切换到本地分支进行提交 git push [remote] [branch]
# 通过-u选项同时使新创建的远程分支成为本地分支的上游分支 git push -u [remote] [branch]</description>
    </item>
    
    <item>
      <title>Cisco AnyConnect Secure Mobility Client的VPN profile位置</title>
      <link>https://mryqu.github.io/post/cisco_anyconnect_secure_mobility_client%E7%9A%84vpn_profile%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sat, 31 Oct 2015 06:19:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cisco_anyconnect_secure_mobility_client%E7%9A%84vpn_profile%E4%BD%8D%E7%BD%AE/</guid>
      <description>在其安装路径C:\Program Files\Cisco\Cisco AnyConnect Secure MobilityClient搜寻未果。
全盘搜索后，发现在这个位置：C:\ProgramData\Cisco\Cisco AnyConnect Secure MobilityClient\Profile</description>
    </item>
    
    <item>
      <title>[Eclipse] 遭遇Unable to install breakpoint due to missing line number attribute</title>
      <link>https://mryqu.github.io/post/eclipse_%E9%81%AD%E9%81%87unable_to_install_breakpoint_due_to_missing_line_number_attribute/</link>
      <pubDate>Fri, 30 Oct 2015 05:49:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse_%E9%81%AD%E9%81%87unable_to_install_breakpoint_due_to_missing_line_number_attribute/</guid>
      <description>今天遇到了“Unable to install breakpoint due to missing line numberattribute. Modify compiler options to generate line numberattributes”问题。 检查Preferences -&amp;gt; Java -&amp;gt; Perference，&amp;rdquo;Add linenumber attributes to generated class files (used by thedebugger)&amp;ldquo;已经勾选了。 应该是SpringAOP产生的代码没有行数信息，但是我自己写的代码还是带行数信息的，因此虽然会弹出这些烦人的警告，所设断点还是其作用的。让它不再提示即可。</description>
    </item>
    
    <item>
      <title>[Gradle] 创建含有依赖库的jar文件</title>
      <link>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 18 Oct 2015 05:54:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</guid>
      <description>想把自己的Gradle项目打成jar文件，但是&amp;rsquo;gradle build jar&amp;rsquo;生成的jar文件不含依赖库。
按照Gradle – Create a Jar file with dependencies改写了自己的build.gradle，成功包含了依赖库。但是依赖库不再是原来的jar文件，而是以目录的形式存在。
我的build.gradle
buildscript { repositories { mavenCentral() } } apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; jar { baseName = &#39;HelloTwitter4J&#39; version = &#39;0.1.0&#39; } task fatJar(type: Jar) { baseName = &#39;HelloTwitter4J-all&#39; version = &#39;0.1.0&#39; manifest { attributes &amp;quot;Main-Class&amp;quot;: &amp;quot;com.yqu.cdfwebtool.twitter.TwitterRateInfo&amp;quot; } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } with jar } repositories { mavenCentral() } sourceCompatibility = 1.</description>
    </item>
    
    <item>
      <title>Remote debugging on microservice at docker container inside vagrant box</title>
      <link>https://mryqu.github.io/post/remote_debugging_on_microservice_at_docker_container_inside_vagrant_box/</link>
      <pubDate>Mon, 05 Oct 2015 05:59:07 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/remote_debugging_on_microservice_at_docker_container_inside_vagrant_box/</guid>
      <description> Docker compose configuration foo-service: image: foo-service:latest hostname: foo-service dns: 127.0.0.1 restart: always  Vagrant configuration config.vm.network &amp;quot;forwarded_port&amp;quot;, guest: 8787, host: 8787, auto_correct: true  Consul configuration curl -X PUT -H &#39;application/json&#39; -d &#39;java_option_server_port:java_option_xms:java_option_xmx:java_option_debug&#39; http://localhost:8500/v1/kv/config/foo-service/jvm/java_options curl -X PUT -H &#39;application/json&#39; -d &#39;-Xdebug -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=n&#39; http://localhost:8500/v1/kv/config/foo-service/jvm/java_option_debug  IntelliJ IDEA configuration </description>
    </item>
    
    <item>
      <title>继续使用Win10的Windows defender</title>
      <link>https://mryqu.github.io/post/%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8win10%E7%9A%84windows_defender/</link>
      <pubDate>Sun, 04 Oct 2015 05:49:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8win10%E7%9A%84windows_defender/</guid>
      <description>从Win7升级到了Win10，有一天忽然发现Microsoft SecurityEssentials不见了。上网一查，才知道被Win10内置了，改叫Windows defender。可是Windowsdefender也没见运行呀？
提示说“此应用已经关闭，不会监视你的计算机”。开始追查！！！
 通过“Windows键+X”进入控制面板 在安全中心，发现是腾讯的电脑管家导致Windows defender被禁用。 关闭电脑管家的实时系统防护。 收到安全性提示，选择启用Windows defender。 又见到小城墙了  </description>
    </item>
    
    <item>
      <title>Node.js npm代理设置</title>
      <link>https://mryqu.github.io/post/node.js_npm%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Wed, 30 Sep 2015 06:06:46 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/node.js_npm%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</guid>
      <description>用Gradle编译当前一个项目，总是报告Node.js的包管理工具npm安装node包失败。美国那边没有问题，不知道是否跟防火墙有关。
npm的代理设置为：
npm config set proxy http://proxyServer:proxyPort npm config set https-proxy http://proxyServer:proxyPort  操作显示能解决我的部分问题！
参考 NPM小结</description>
    </item>
    
    <item>
      <title>遭遇&#34;HTTPS endpoint unresponsive and insecure mode isn&#39;t enabled.&#34;</title>
      <link>https://mryqu.github.io/post/%E9%81%AD%E9%81%87https_endpoint_unresponsive_and_insecure_mode_isnt_enabled./</link>
      <pubDate>Tue, 29 Sep 2015 05:38:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%81%AD%E9%81%87https_endpoint_unresponsive_and_insecure_mode_isnt_enabled./</guid>
      <description>今天使用docker-compose去获取最新的镜像，遭遇&amp;rdquo;HTTPS endpoint unresponsive andinsecure mode isn&amp;rsquo;t enabled.&amp;ldquo;错误。
mryqu$ docker-compose pull Pulling cadvisor (docker.mryqu.com/google/cadvisor:latest)... Traceback (most recent call last): File &amp;quot;&amp;lt;string&amp;gt;&amp;quot;, line 3, in &amp;lt;module&amp;gt; File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.main&amp;quot;, line 32, in main File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.docopt_command&amp;quot;, line 21, in sys_dispatch File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.command&amp;quot;, line 34, in dispatch File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.docopt_command&amp;quot;, line 24, in dispatch File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.command&amp;quot;, line 66, in perform_command File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.cli.main&amp;quot;, line 235, in pull File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.project&amp;quot;, line 285, in pull File &amp;quot;/code/build/docker-compose/out00-PYZ.pyz/compose.service&amp;quot;, line 713, in pull File &amp;quot;/code/build/docker-compose/out00-PYZ.</description>
    </item>
    
    <item>
      <title>kitematic代理设置</title>
      <link>https://mryqu.github.io/post/kitematic%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Wed, 16 Sep 2015 06:09:37 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/kitematic%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</guid>
      <description>在DockerToolbox目录下创建一个批处理脚本文件kitematic_proxy.cmd，插入下面代码，将&amp;rdquo;YOUR_PROXY&amp;rdquo;替换为所用的代理（http://host:port）。
set proxy=YOUR_PROXY SET HTTP_PROXY=%proxy% SET HTTPS_PROXY=%proxy% for /f %%i in (&#39;docker-machine.exe ip default&#39;) do set DOCKER_HOST=%%i SET NO_PROXY=%DOCKER_HOST% set DOCKER_HOST=tcp://%DOCKER_HOST%:2376 cd Kitematic Kitematic.exe  参考 kitematic Proxy/VPN error reports #1031</description>
    </item>
    
    <item>
      <title>Postman使用笔记</title>
      <link>https://mryqu.github.io/post/postman%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 15 Sep 2015 06:15:18 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/postman%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>以前用过cURL和rest-shell进行RESTAPI测试，最近偶然看到了Postman。Postman是一款Chrome插件，强大、便利，可以在浏览器里直接测试RESTAPI。
安装 在Chrome浏览器里进入Postman插件安装地址即可安装Postman。 使用 Postman可以模拟各种Http请求，并且可以额外设置特殊的URL参数、Http头以及Basic Auth、DigestAuth、OAuth 1.0等认证信息。在展现Http响应上，Postman支持完美打印，JSON、XML或是HTML都会整理成人类阅读的格式，有助于我们更清楚地查看响应内容。特色功能  更多的Http方法：Postman除了支持GET、POST、PUT、PATCH、DELETE、HEAD、OPTIONS这些常用Http方法，还支持COPY、LINK、UNLINK、PURGE。 集合（Collection）功能：Postman可以管理Http请求的集合，在做完单个测试时，可以将该请求存入特定集合内。这样在后继的重复测试，无需重新输入Http请求，就可以快速测试并获得结果。集合支持输入或导出，便于团队共享。 设置环境变量（Environment）：Postman可以管理环境变量。一般我们有可能有多种环境：development、staging或local，每种环境下的请求URL有可能各不相同。通过环境变量，在切换环境测试时无需重写Http请求。  参考 Postman插件安装地址
Github：postmanlabs
Postman官方博客
HTTP Link and Unlink Methods</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] addr2line使用</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_addr2line%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 11 Sep 2015 05:33:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_addr2line%E4%BD%BF%E7%94%A8/</guid>
      <description>GNU Binutils的Addr2line工具是一个可以将指令的地址和可执行程序转换成文件名、函数名和源代码行数的工具。这种功能对于将跟踪地址转换成更有意义的内容来说简直是太棒了。
下面是一个小示例testAddr2line.c：
#include &amp;quot;stdio.h&amp;quot; void test() { printf(&amp;quot;Hello Addr2line\n&amp;quot;); } int main() { test(); return 0; }  编译时使用-g选项包含调试符号条，使用-Wl,-Map=testAddr2line.map选项输出MapFile。
gcc -Wl,-Map=testAddr2line.map -g -o testAddr2line testAddr2line.c  testAddr2line.map部分内容如下： testAddr2line中也包含符号表信息，因而可以使用objdump查找：
hadoop@node51054:~/ctest$ objdump -t testAddr2line | grep &#39;main\|test&#39; testAddr2line: file format elf64-x86-64 0000000000000000 l df *ABS* 0000000000000000 testAddr2line.c 0000000000000000 F *UND* 0000000000000000 __libc_start_main@@GLIBC_2.2.5 0000000000400547 g F .text 0000000000000015 main 0000000000400536 g F .text 0000000000000011 test  使用addr2line：
hadoop@node51054:~/ctest$ addr2line -e testAddr2line 400536 /home/hadoop/ctest/testAddr2line.</description>
    </item>
    
    <item>
      <title>Gradle代理配置</title>
      <link>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 31 Aug 2015 05:46:52 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid>
      <description> HTTP代理配置 gradlew -Dhttp.proxyHost=[myServer] -Dhttp.proxyPort=[myPort] -Dhttp.proxyUser=[myUser] -Dhttp.proxyPassword=[myPassword]  HTTPS代理配置 gradlew -Dhttps.proxyHost=[myServer] -Dhttps.proxyPort=[myPort] -Dhttps.proxyUser=[myUser] -Dhttps.proxyPassword=[myPassword]  </description>
    </item>
    
    <item>
      <title>试用了一下Kitematic</title>
      <link>https://mryqu.github.io/post/%E8%AF%95%E7%94%A8%E4%BA%86%E4%B8%80%E4%B8%8Bkitematic/</link>
      <pubDate>Fri, 28 Aug 2015 06:31:06 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%AF%95%E7%94%A8%E4%BA%86%E4%B8%80%E4%B8%8Bkitematic/</guid>
      <description>Kitematic是一个一个简单的 Docker容器管理GUI程序，它可以在Windows/Mac上更快速、更简单的运行Docker。Kitematic 完全自动化了 Docker安装和设置过程，并提供了一个直观的图形用户接口（GUI）来在Windows/Mac上运行 Docker。Kitematic集成了Docker Machine来在Windows/Mac上分发一个虚拟机并安装 Docker引擎。 在Kitematic上可以在DockerHub上查询Docker镜像、并用之创建容器。也可以对特定Docker容器进行环境变量、Volume和端口等配置。对记不住Docker命令的懒人是一个福利。
参考 Kitematic官网
Github：Kitematic
DOCKER ONLINE MEETUP: KITEMATIC IN ACTION</description>
    </item>
    
    <item>
      <title>安装Gerrit的commit-msg钩子</title>
      <link>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85gerrit%E7%9A%84commit-msg%E9%92%A9%E5%AD%90/</link>
      <pubDate>Wed, 19 Aug 2015 05:34:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85gerrit%E7%9A%84commit-msg%E9%92%A9%E5%AD%90/</guid>
      <description>对Gerrit进行首次提交前需要安装commit-msg钩子，每次总忘，每次都总是搜邮件，还是记博客里方便些。
gitdir=$(git rev-parse --git-dir); scp -p -P 29418 [your username]@[your Gerrit review server]:hooks/commit-msg {gitdir}/hooks/  参考
Gerrit：commit-msg Hook
Gerrit工作流</description>
    </item>
    
    <item>
      <title>在Ubuntu中安装rpm包</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85rpm%E5%8C%85/</link>
      <pubDate>Fri, 07 Aug 2015 05:46:42 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85rpm%E5%8C%85/</guid>
      <description>RPM(RPM Package Manager，原Red Hat PackageManager)是基于RedHat的Linux分发版的包管理系统，用于rpm包的管理（诸如安装、卸载、升级等），其原始设计理念是开放式的，现在包括OpenLinux、Mandrake、SuSE以及TurboLinux等Linux分发版都有采用。 APT软件管理系统是Debian 系统(包含Debian和 Ubuntu)的包管理系统，用于deb包的的管理（诸如安装、卸载、升级等）。deb格式是Debian系统专属安装包格式，进入2.x时代之后由Cydia作者JayFreeman（saurik）将其与APT软件管理系统一起移植到iPhone平台上。 Alien是一个将不同Linux包分发文件转换成deb的程序，支持Linux标准规范, RPM、deb、Stampede(.slp)和Slackware (tgz)包之间的转换。 Alien工具安装： 在Ubuntu下，alien已经添加在源中,可以使用sudo apt-get install alien命令进行安装。
Alien使用： - rpm转deb：sudo alien --script (filename).rpm - Debian系统直接安装rpm：sudo alien -i --script(filename).rpm - deb转rpm：sudo alien --to-rpm (filename).deb - tar.gz转deb：sudo alien -k (filename).tar.gz - tar.bz2转deb：sudo alien -d (filename).tar.bz2 - tgz转deb：sudo alien --to-deb ~/(filename).tgz
由于Teradata数据库的安装文件仅支持Redhat、SUSE和IBM s390xLinux，而我的docker容器是基于Debian系统的，所以今天尝试了一下Alien。但是效果不佳：ttu14中的rpm可以转换成deb，但是直接安装失败；ttu15中的rpm直接安装失败，但是转换deb失败。</description>
    </item>
    
    <item>
      <title>Consul服务设置实践</title>
      <link>https://mryqu.github.io/post/consul%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 04 Aug 2015 05:54:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/consul%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/</guid>
      <description>在向Consul注册/注销外部服务节点中，我实践对Consul节点注册和注销，本帖我实践一些对Consul服务的查看和注销。
查看当前数据中心所有注册的服务：
curl http://localhost:8500/v1/catalog/services  查看当前数据中心注册的服务foo的信息：
curl http://localhost:8500/v1/catalog/service/foo  注销服务节点foo上关联的检查service:foo-192-168-0-123：
curl -X PUT -H &#39;application/json&#39; -d &#39;{&amp;quot;Node&amp;quot;: &amp;quot;kexiao&amp;quot;, &amp;quot;CheckID&amp;quot;: &amp;quot;service:foo-192-168-0-123&amp;quot;}&#39; http://localhost:8500/v1/catalog/deregister  注销服务节点foo上关联的服务foo-192-168-0-123：
curl -X PUT -H &#39;application/json&#39; -d &#39;{&amp;quot;Node&amp;quot;: &amp;quot;kexiao&amp;quot;, &amp;quot;ServiceID&amp;quot;: &amp;quot;foo-192-168-0-123&amp;quot;}&#39; http://localhost:8500/v1/catalog/deregister  参考 Consul - Catalog HTTP Endpoint</description>
    </item>
    
    <item>
      <title>向Consul注册/注销外部服务节点</title>
      <link>https://mryqu.github.io/post/%E5%90%91consul%E6%B3%A8%E5%86%8C%E6%88%96%E6%B3%A8%E9%94%80%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sat, 01 Aug 2015 07:00:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%90%91consul%E6%B3%A8%E5%86%8C%E6%88%96%E6%B3%A8%E9%94%80%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9/</guid>
      <description>已有一个docker上的微服务节点foo，但是有可能需要使用系统外部的foo服务集群。 切换到系统外部的foo服务集群的操作过程如下：
docker-compose stop foo docker-compose rm foo curl -X PUT -H &#39;application/json&#39; -d &#39;{&amp;quot;Node&amp;quot;: &amp;quot;foo&amp;quot;, &amp;quot;Address&amp;quot;: &amp;quot;foo.cluster.yqu.com&amp;quot;, &amp;quot;Service&amp;quot;: {&amp;quot;Service&amp;quot;:&amp;quot;foo&amp;quot;, &amp;quot;tags&amp;quot;: [&amp;quot;controller&amp;quot;], &amp;quot;port&amp;quot;: 12221}}&#39; http://localhost:8500/v1/catalog/register docker-compose restart consul  切换回系统内部过程的foo服务节点操作过程如下：
curl -X PUT -H &#39;application/json&#39; -d &#39;{&amp;quot;Node&amp;quot;: &amp;quot;foo&amp;quot;}&#39; http://localhost:8500/v1/catalog/deregister docker-compose up -d foo docker-compose restart consul  注销foo服务节点操作过程如下：
curl -X PUT -H &#39;application/json&#39; -d &#39;{&amp;quot;Node&amp;quot;: &amp;quot;foo&amp;quot;}&#39; http://localhost:8500/v1/catalog/deregister docker-compose stop foo docker-compose rm foo docker-compose restart consul  参考 Consul Guide：Registering An External Service</description>
    </item>
    
    <item>
      <title>[Gradle] 列举插件</title>
      <link>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 27 Jul 2015 06:17:30 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</guid>
      <description>下列方法可以列举出当前build.gradle牵涉的插件:
project.plugins.each { println it }  </description>
    </item>
    
    <item>
      <title>为Artifactory设置proxy和remote repository</title>
      <link>https://mryqu.github.io/post/%E4%B8%BAartifactory%E8%AE%BE%E7%BD%AEproxy%E5%92%8Cremote_repository/</link>
      <pubDate>Sun, 19 Jul 2015 00:09:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%B8%BAartifactory%E8%AE%BE%E7%BD%AEproxy%E5%92%8Cremote_repository/</guid>
      <description>设置proxy 我一上来先设置代理，否则连不上远程仓库呀。 设置remote repository 远程仓库已经默认设置了jcenter，估计很少需要其他仓库了。 但不管三七二十一，还是把mavenCentral和gradlePlugins加上吧。全部勾选了Suppress POMConsistency Checks，取消勾选Handle Snapshots。 - mavenCentral: http://repo1.maven.org/maven2/ - gradlePlugins: https://plugins.gradle.org/m2/
测试结果显示，所需构件实际上都是从jcenter下载的，其他两个暂时还没用到。</description>
    </item>
    
    <item>
      <title>整理贴：八卦一下CoreOS</title>
      <link>https://mryqu.github.io/post/%E6%95%B4%E7%90%86%E8%B4%B4%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bcoreos/</link>
      <pubDate>Fri, 17 Jul 2015 06:10:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%95%B4%E7%90%86%E8%B4%B4%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bcoreos/</guid>
      <description>CoreOS是一个轻量级容器化Linux发行版，专为大型数据中心而设计，旨在通过轻量的系统架构和灵活的应用程序部署能力简化数据中心的维护成本和复杂度。
CoreOS的历史 2013年2月，美国的dotCloud公司发布了一款新型的Linux容器软件Docker，并建立了一个网站发布它的首个演示版本（见Docker第一篇官方博客）。而几乎同时，2013年3月，美国加州，年轻的帅小伙Alex Polvi正在自己的车库开始他的第二次创业。此前，他的首个创业公司Cloudkick卖给了云计算巨头Rackspcace（就是OpenStack的东家）。 有了第一桶金的Alex这次准备干一票大的，他计划开发一个足以颠覆传统的服务器系统的Linux发行版。为了提供能够从任意操作系统版本稳定无缝地升级到最新版系统的能力，Alex急需解决应用程序与操作系统之间的耦合问题。因此，当时还名不见经传的Docker容器引起了他的注意，凭着敏锐直觉，Alex预见了这个项目的价值，当仁不让地将Docker做为了这个系统支持的第一套应用程序隔离方案。不久以后，他们成立了以自己的系统发行版命名的组织：CoreOS。事实证明，采用Docker这个决定，后来很大程度上成就了CoreOS的生态系统。 CoreOS特点 首先，CoreOS没有提供包管理工具，而是通过容器化的运算环境向应用程序提供运算资源。应用程序之间共享系统内核和资源，但是彼此之间又互不可见。这样就意味着应用程序将不会再被直接安装到操作系统中，而是通过Docker 运行在容器中。这种方式使得操作系统、应用程序及运行环境之间的耦合度大大降低。相对于传统的部署方式而言，在 CoreOS集群中部署应用程序更加灵活便捷，应用程序运行环境之间的干扰更少，而且操作系统自身的维护也更加容易。 其次， CoreOS 采用双系统分区 (dual root partition)设计。两个分区分别被设置成主动模式和被动模式并在系统运行期间各司其职。主动分区负责系统运行，被动分区负责系统升级。一旦新版本的操作系统被发布，一个完整的系统文件将被下载至被动分区，并在系统下一次重启时从新版本分区启动，原来的被动分区将切换为主动分区，而之前的主动分区则被切换为被动分区，两个分区扮演的角色将相互对调。同时在系统运行期间系统分区被设置成只读状态，这样也确保了CoreOS 的安全性。CoreOS 的升级过程在默认条件下将自动完成，并且通过 cgroup对升级过程中使用到的网络和磁盘资源进行限制，将系统升级所带来的影响降至最低。 另外，CoreOS 使用 Systemd 取代 SysV 作为系统和服务的管理工具。与 SysV 相比，Systemd不但可以更好的追踪系统进程，而且也具备优秀的并行化处理能力，加之按需启动等特点，并结合 Docker 的快速启动能力，在 CoreOS集群中大规模部署 Docker容器与使用其他操作系统相比在性能上的优势将更加明显。Systemd 的另一个特点是引入了“target” 的概念，每个 target 应用于一个特定的服务，并且可以通过继承一个已有的 target扩展额外的功能，这样使得操作系统对系统上运行的服务拥有更好的控制力。 通过对系统结构的重新设计，CoreOS剔除了任何不必要的软件和服务。在一定程度上减轻了维护一个服务器集群的复杂度，帮助用户从繁琐的系统及软件维护工作中解脱出来。虽然CoreOS最初源自于Google ChromeOS，但是从一开始就决定了 CoreOS更加适合应用于一个集群环境而不是一个传统的服务器操作系统。 CoreOS相关工具 除了操作系统之外，CoreOS 团队和其他团队还提供了若干工具帮助用户管理 CoreOS 集群以及部署Docker容器。
etcd 在CoreOS 集群中处于骨架地位的是 etcd。 etcd 是一个分布式 key/value存储服务，CoreOS 集群中的程序和服务可以通过 etcd 共享信息或做服务发现 。etcd 基于非常著名的 raft一致性算法：通过选举形式在服务器之中选举 Lead 来同步数据，并以此确保集群之内信息始终一致和可用。etcd 以默认的形式安装于每个CoreOS 系统之中。在默认的配置下，etcd使用系统中的两个端口：4001和7001，其中4001提供给外部应用程序以HTTP+Json的形式读写数据，而7001则用作在每个etcd 之间进行数据同步。用户更可以通过配置 CA Cert让 etcd 以 HTTPS的方式读写及同步数据，进一步确保数据信息的安全性。
fleet fleet 是一个通过Systemd对CoreOS 集群中进行控制和管理的工具。fleet 与 Systemd 之间通过 D-Bus API 进行交互，每个fleet agent 之间通过 etcd 服务来注册和同步数据。fleet提供的功能非常丰富，包括查看集群中服务器的状态、启动或终止 Docker容器、读取日志内容等。更为重要的是 fleet可以确保集群中的服务一直处于可用状态。当出现某个通过 fleet创建的服务在集群中不可用时，如由于某台主机因为硬件或网络故障从集群中脱离时，原本运行在这台服务器中的一系列服务将通过fleet被重新分配到其他可用服务器中。虽然当前 fleet 还处于非常早期的状态，但是其管理 CoreOS集群的能力是非常有效的，并且仍然有很大的扩展空间，目前已提供简单的 API 接口供用户集成。</description>
    </item>
    
    <item>
      <title>Gradle Docker Plugin介绍</title>
      <link>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 14 Jul 2015 05:57:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</guid>
      <description>gradle-docker-plugin gradle-docker-plugin是由《Gradle实战》作者BenjaminMuschko实现的Gradle插件，用来管理Docker镜像和容器。gradle-docker-plugin实际上包括两个插件： - com.bmuschko.docker-remote-api:提供通过远程API与Docker进行交互的定制任务- com.bmuschko.docker-java-application:为Java应用创建和上传Docker镜像build.gradle buildscript { repositories { jcenter() } dependencies { classpath &#39;com.bmuschko:gradle-docker-plugin:2.4.1&#39; } } apply plugin: &#39;java&#39; apply plugin: &#39;application&#39; apply plugin: &#39;com.bmuschko.docker-java-application&#39; apply plugin: &#39;com.bmuschko.docker-remote-api&#39;  参考 GitHub：bmuschko/gradle-docker-plugin</description>
    </item>
    
    <item>
      <title>执行Gradle artifactoryPublish任务时碰到HTTP 409 Conflict错误</title>
      <link>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 13 Jul 2015 06:10:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</guid>
      <description>这篇博文算是《尝试Artifactory》的姐妹篇。我打算将《尝试Artifactory》中的&amp;rsquo;libs-snapshot-local&amp;rsquo;和&amp;rsquo;libs-snapshot&amp;rsquo;换成&amp;rsquo;libs-release-local&amp;rsquo;和&amp;rsquo;libs-release&amp;rsquo;，以便将我的构件发布到发布版仓库里。结果遭遇如下错误：
C:\test123\HelloArtifactory&amp;gt;gradlew artifactoryPublish [buildinfo] Not using buildInfo properties file for this build. :generatePomFileForMavenJavaPublication :compileJava  查看Artifactory日志，才知道根本原因在于创建的是SNAPSHOT而libs-release-local只处理发布版构建。The repository &amp;lsquo;libs-release-local&amp;rsquo; rejected the artifact&amp;rsquo;libs-release-local:com/yqu/HelloArtifactory/0.1.0-SNAPSHOT/HelloArtifactory-0.1.0-SNAPSHOT.jar&amp;rsquo;due to its snapshot/release handling policy。 解决方案有如下两种： - 修改libs-release-local属性，勾选Handle Snapshots选择框（工作流不正规啦） - 将gradle.properties中的version由0.1.0-SNAPSHOT改成0.1.0即可</description>
    </item>
    
    <item>
      <title>Gradle Git Plugin介绍</title>
      <link>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 12 Jul 2015 21:15:17 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</guid>
      <description>Grgit和gradle-git Git是一个很流行的分布式版本管理工具。能在构建过程中与Git进行交互，可以提供更强大和更一致的结果。
JGit提供了与Git仓库交互的强大JavaAPI。然而，在Groovy上下本使用它会笨重，需要在所要执行的表达式包一堆换七八糟的东东。Grgit是Andre wOberstar实现的JGit封装器，为基于Groovy的工具与Git仓库交互提供了更简洁流畅的API。 gradle-git同样是由Andrew Oberstar实现的一系列Gradle插件： - org.ajoberstar.grgit - 提供一个Grgit实例，允许与Gradle项目所在的Git仓库交互 - org.ajoberstar.github-pages - 向Github仓库的gh-pages分支发布文件 - org.ajoberstar.release-base -提供用于从项目状态和所在Git仓库推断当前项目版本和创建新版本的通用结构 - org.ajoberstar.release-opinion -用于org.ajoberstar.release-base的默认选项，遵从语义版本控制（Semantic Versioning）下面是一个Gradle任务示例，用于从Git仓库克隆项目。
build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath &#39;org.ajoberstar:gradle-git:1.2.0&#39; } } import org.ajoberstar.gradle.git.tasks.* task cloneGitRepo(type: GitClone) { def destination = file(&amp;quot;destination_folder&amp;quot;) uri = &amp;quot;your_git_repo_uri&amp;quot; destinationPath = destination bare = false enabled = !destination.exists() //to clone only once }  参考 GitHub：ajoberstar/gradle-git
GitHub：ajoberstar/grgit</description>
    </item>
    
    <item>
      <title>apt-get在基于Ubuntu基础镜像Dockerfile中的常见用法</title>
      <link>https://mryqu.github.io/post/apt-get%E5%9C%A8%E5%9F%BA%E4%BA%8Eubuntu%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8Fdockerfile%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 05 Jul 2015 21:32:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/apt-get%E5%9C%A8%E5%9F%BA%E4%BA%8Eubuntu%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8Fdockerfile%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</guid>
      <description>首先，在Ubuntu的Docker官方镜像中是没有缓存Apt的软件包列表的。因此在做其他任何基础软件的安装前，都需要至少先做一次apt-get update。 有时为了加快apt-get安装软件的速度，还需要修改Apt源的列表文件/etc/apt/sources.list。相应的操作用命令表示如下：
# 使用Ubuntu官方的Apt源，也可以根据实际需要修改为国内源的地址 echo &amp;quot;deb http://archive.ubuntu.com/ubuntu trusty main universe\n&amp;quot; &amp;gt; /etc/apt/sources.list echo &amp;quot;deb http://archive.ubuntu.com/ubuntu trusty-updates main universe\n&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list  在容器构建时，为了避免使用apt-get install安装基础软件的过程中需要进行的交互操作，使用-y参数来避免安装非必须的文件，从而减小镜像的体积。
apt-get -y --no-install-recommends install  使用apt-get autoremove命令移除为了满足包依赖而安装的、但不再需要的包；使用apt-get clean命令清除所获得包文件的本地仓库。 DEBIAN_FRONTEND这个环境变量，告知操作系统应该从哪儿获得用户输入。如果设置为&amp;rdquo;noninteractive&amp;rdquo;，你就可以直接运行命令，而无需向用户请求输入（所有操作都是非交互式的）。这在运行apt-get命令的时候格外有用，因为它会不停的提示用户进行到了哪步并且需要不断确认。非交互模式会选择默认的选项并以最快的速度完成构建。请确保只在Dockerfile中调用的RUN命令中设置了该选项，而不是使用ENV命令进行全局的设置。因为ENV命令在整个容器运行过程中都会生效，所以当你通过BASH和容器进行交互时，如果进行了全局设置那就会出问题。
# 正确的做法 - 只为这个命令设置ENV变量 RUN DEBIAN_FRONTEND=noninteractive apt-get install -y python3 # 错误地做法 - 为接下来的任何命令都设置ENV变量，包括正在运行地容器 ENV DEBIAN_FRONTEND noninteractive RUN apt-get install -y python3  我的示例如下：
FROM ubuntu:trusty MAINTAINER mryqu RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get clean  参考 Ubuntu manuals: apt-get man page</description>
    </item>
    
    <item>
      <title>Docker的镜像存储在哪里和长什么样子</title>
      <link>https://mryqu.github.io/post/docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%92%8C%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</link>
      <pubDate>Sun, 05 Jul 2015 00:27:30 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%92%8C%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</guid>
      <description>接触docker后，我就有个疑问：我们用docker pull镜像后，该镜像是存储在哪里的？是以一个特俗的二进制类型存储的么？后来阅读了Docker的镜像存储在哪里这篇博文，得以解惑，并进行了验证。 Docker的镜像存储在/var/lib/docker目录下，存储方式有点像Git那样有reference和实际的objects，并且是实际内容是diff那样的增量存放。 Docker的镜像存储在哪里 有个疑问就是我们用docker pull镜像后，该镜像是存储在哪里的？ 当你仅仅是使用docker启动一个实例的时候，是超级简单的，但是当你制作自己的Dockerfile时，可能会有一些迷惑，那就是我的docker镜像存储在哪里了。这个听起来让我感觉有点一筹莫展，对于dockerimage的存储我还是一无所知。最后你只能把镜像发布到公共DockerIndex上面，但是，在过去一段时间内你是无法删除它的，但是现在你可以通过官方的WEB界面来删除它了。
Image VS Dockerfile 这个看起来有点混淆，但是它们是有差别的，docke使用images运行你的代码，而不是Dockerfile。Dockerfile是你用dockerbuild命令来构建image的。如果你在浏览器中浏览DockerIndex，你会发现有很多images显示在上面，但是你不能看见构建它们的Dockerfile。当你使用dockerpush命令发布image时，它不会发布你的源代码，它只会发布从你源代码构建出来的镜像。
Registry VS Index 下一个混淆的是Registry和Index，它们是怎么样区分的？index是管理公共web接口上的accounts、permission、search、tagging和所有精细的方面的。而registry是存储和提供实际image的，它委托index进行身份验证。当你运行dockersearch命令的时候，它搜索的是index，而不是registry。实际上，它可能搜索的是index知道的多个registry。当你运行dockerpush或者dockerpull命令时，index决定你是否有权限访问和修改images，当index同意你操作后，registry是提供images存储的地方，index会计算出哪个registry有你需要的镜像，并把请求转发过去。当你在本地运行dockerimages命令时，你可能是同时和index和registry进行交互。
Repository docker&amp;rsquo;s使用镜像就像使用GitHub一样容易，但是有三个混淆的地方： - repository和registry之间的区别 - repository和image之间的区别 - repository和index username之间的区别
其实repository并不是其中任何一个组件，而是指所有的组件。当你运行dockerimages命令时，你会看到如下： images列表看起来像repositories列表？实际上images是GUIDs，但这并不是如何和他们交互。当你执行dockerbuild或者dockercommit命令时，你可以指定image的名称，这个名称的格式是username/image_name，但这并不一定，它可以是任何形式的，他甚至可以是你已经知道的发布的镜像名称。当你执行dockerpush的时候，index会查看镜像名称，检查该镜像是否在repository中，如果在，接着检查你是否有权限访问该repository，如果有权限，则允许你push新版本的image到该repository上。因此，一个registry保留了它收集到的repository的名称，它本身跟踪收集到的images的GUIDs。thisis also where tags comein，你可以tag一个image，并且存储多个版本使用不同的GUIDs在同一个repository中，访问不同的标记的版本image，可以使用username/image_name:tag。 从上图中你可以看到我们有三个不同版本的image叫ubuntu12，每个的tag都是不同的，repository使用ubuntu12的名称来保存这些，因此，当我们看到ubuntu12的时候，它像一个image名称，但是实际上它使repository名称，repository名称有特殊的设计架构，index可以从第一部分解析出username，并且找出他在哪里。因此，当出现一个guol/ubuntu时会产生混淆，官方的repository名称是类似username/image_name这样的，我们想当然的认为repository名称是image_name，但是根据docker的文档发现repository的名称有时指的是全部的名称，有时指的是image_name。比如就像ubuntu，它就没有username，是不是有点乱了&amp;hellip;&amp;hellip;&amp;hellip;
Local Storage on the Docker Host 我们已经了解完如何和远程存储进行交互了，但是当你运行dockerimages的时候，仅仅给你看到的是你的机器上有哪些image。这些镜像在哪里呢？第一个要查看的地方是/var/lib/docker/。 查看repositories-aufs文件的内容，它的内容是在你本机上的repositories。 看看，它完全匹配了docker images的输出内容。 现在我们来看看/var/lib/docker/graph/的内容。 我倒，显示的非常不友好啊，看看docker是怎样跟踪这些镜像的，是基于repositories-aufs文件，构建了一个映射到repository名称和tag的关系表。我们看看ubuntu12的仓库，它有三个镜像，标记分别是12.04、precise、latest。采用的是IDd431f556799d35dfae1278a1ee41a393db70058dedb9a7fc554b0506b5b241cb，我们看看这个目录里面有什么。 只有两个文件： - json：保存image的metadata - layersize：只是一个数字，表明layer的大小
主要镜像的差异在/var/lib/docker/aufs/diff/目录下，每次都会把镜像改变的部分存储在该目录下的相关ID目录里面。 参考：Where are Docker images stored?</description>
    </item>
    
    <item>
      <title>聊聊mavenCenter和JCenter</title>
      <link>https://mryqu.github.io/post/%E8%81%8A%E8%81%8Amavencenter%E5%92%8Cjcenter/</link>
      <pubDate>Fri, 03 Jul 2015 06:22:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%81%8A%E8%81%8Amavencenter%E5%92%8Cjcenter/</guid>
      <description>Gradle支持从maven中央仓库和JCenter上获取构件，那这两者有什么区别呢？
maven中央仓库（http://repo1.maven.org/maven2/）是由Sonatype公司提供的服务，它是ApacheMaven、SBT和其他构建系统的默认仓库，并能很容易被ApacheAnt/Ivy、Gradle和其他工具所使用。开源组织例如Apache软件基金会、Eclipse基金会、JBoss和很多个人开源项目都将构件发布到中央仓库。maven中央仓库已经将内容浏览功能禁掉了，可在http://search.maven.org/查询构件。
https://jcenter.bintray.com）是由JFrog公司提供的Bintray中的Java仓库。它是当前世界上最大的Java和Android开源软件构件仓库。所有内容都通过内容分发网络（CDN）使用加密https连接获取。JCenter是Goovy Grape内的默认仓库，Gradle内建支持（jcenter()仓库），非常易于在（可能除了Maven之外的）其他构建工具内进行配置。
JCenter相比mavenCenter构件更多，性能也更好。但还是有些构件仅存在mavenCenter中。</description>
    </item>
    
    <item>
      <title>在线工具</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 30 Jun 2015 12:36:32 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</guid>
      <description>smallpdf 坛子里提到一个PDF工具网站http://smallpdf.com/cn，有人试用了说不错。支持如下功能： - PDF压缩:大幅压缩PDF文件大小 - JPG转PDF:将图片转换成如您所需的PDF文件 - PDF转JPG:将页面转换成图片，或从PDF文件提取图片 - PDF转Word:将PDF转换成具有最佳质量的Word文件 - PDF转Excel:将PDF格式的电子表格转成可编辑的Excel文件 - PDF转PPT:将PDF格式的幻灯片转成Powerpoint演示文件 - Word转PDF:WORD文件转PDF格式 - Excel转PDF:Excel表格转PDF - PPT转PDF:PPT演示文件转PDF文件 - 合并PDF:将数个PDF文件合并为一个文件 - PDF分割:从所选页面创建新文件 - PDF解密:针对受密码保护的文件进行解密
新浪微博.短网址 http://sina.lt/提供如下功能： - 网址压缩 - 短网址还原 - 外链图库
LaTeX 编译器 JaxEdit</description>
    </item>
    
    <item>
      <title>尝试Artifactory</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95artifactory/</link>
      <pubDate>Tue, 30 Jun 2015 06:28:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95artifactory/</guid>
      <description>Artifactory简介 首先，JFrogArtifactory是统一构件仓库管理器，全面支持任何语言或技术创建的软件包。Artifactory是一个适合企业的仓库管理器，支持安全、集群和高可用的Docker注册。与所有主流CI/CD和DevOps工具进行集成，Artifactory提供了端到端的自动化的解决方案用以追踪从开发阶段到生产环境阶段中的构件。 安装Artifactory 在https://www.jfrog.com/open-source/下载开源版的jFrogArtifactory，按照JFrog Artifactory用户指南即可轻松安装和使用。 发布构件 使用Gradle构建脚本生成器 gradle.properties artifactory_contextUrl=http://localhost:8081/artifactory artifactory_user=admin artifactory_password=password group = com.yqu version = 0.1.0-SNAPSHOT description = Hello artifactory  build.gradle buildscript { repositories { maven { url &amp;quot;https://plugins.gradle.org/m2/&amp;quot; } } dependencies { //Check for the latest version here: // http://plugins.gradle.org/plugin/com.jfrog.artifactory classpath &amp;quot;org.jfrog.buildinfo:build-info-extractor-gradle:+&amp;quot; } } apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;maven-publish&#39; apply plugin: &amp;quot;com.jfrog.artifactory&amp;quot; jar { baseName = &#39;HelloArtifactory&#39; } artifacts { archives jar } publishing { publications { maven { from components.</description>
    </item>
    
    <item>
      <title>[Gradle] buildScript块与allprojects块及根级别的repositories区别</title>
      <link>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 29 Jun 2015 00:03:59 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</guid>
      <description>一直对为什么buildScript块里定义了repositories而allprojects段或根还定义repositories没有思考过，偶然有了念头想要探究一下。
build.gradle： buildscript {
repositories { &amp;hellip; } dependencies { &amp;hellip; } } allprojects { repositories { &amp;hellip; } dependencies { &amp;hellip; } }repositories { &amp;hellip; } dependencies { &amp;hellip; }
buildScript块主要是为了Gradle脚本自身的执行，获取脚本依赖插件。我在写的一篇博客《尝试Artifactory》中Gradle脚本需要com.jfrog.artifactory插件才能执行成功，而这个插件是从URL为https://plugins.gradle.org/m2/的Maven仓库获得。 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。 allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。
参考 What&amp;rsquo;s the difference between buildscript and allprojects in build.gradle?
Gradle buildscript dependencies
Gradle: Project</description>
    </item>
    
    <item>
      <title>制作JavaSE8的chm版本JavaDoc</title>
      <link>https://mryqu.github.io/post/%E5%88%B6%E4%BD%9Cjavase8%E7%9A%84chm%E7%89%88%E6%9C%ACjavadoc/</link>
      <pubDate>Thu, 25 Jun 2015 05:50:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%88%B6%E4%BD%9Cjavase8%E7%9A%84chm%E7%89%88%E6%9C%ACjavadoc/</guid>
      <description> Java8文档 在线版Java8文档: http://docs.oracle.com/javase/8/docs/ 下载版Java文档链接：http://www.oracle.com/technetwork/java/javase/downloads/index.html#docs - JavaSE6文档下载链接: http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u25-doc-download-355137.html - JavaSE7文档下载链接: http://www.oracle.com/technetwork/java/javase/documentation/java-se-7-doc-download-435117.html - JavaSE8文档下载链接: http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html
工具 Github：subchen/javadoc.chm
制作过程  将javadoc.chm-master.zip的javadoc.chm-2.1.0.jar和lib目录解压缩到当前目录 将jdk-8u45-docs-all.zip的docs目录解压缩到当前目录  java -Xms256m -Xmx512m -cp javadoc.chm-2.1.0.jar;lib/commons-lang-2.6.jar;lib/commons-io-2.4.jar;lib/commons-collections-3.2.1.jar;lib/commons-logging-1.1.1.jar;lib/log4j-1.2.17.jar;lib/velocity-1.7.jar jerbrick.tools.chm.Application docs/api  执行docs/api/build.bat生成chm文件   </description>
    </item>
    
    <item>
      <title>了解Registrator</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3registrator/</link>
      <pubDate>Thu, 18 Jun 2015 05:50:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3registrator/</guid>
      <description>支持 DNS和基于HTTP发现机制的服务发现工具Consul让我们印象深刻。它提供了定制化的注册服务健康检查并标记不健康实例的功能远胜于其他类似的工具。更多时兴的工具与Consul的集成使其功能更加强大。在使用Docker的场景里，有了Registrator的帮助，只需要很小的工作量就可以自动化地向Consul注册Docker容器，使得管理基于容器技术的配置更加容易。 Registrator通过检查Docker容器是否上线，自动为Docker容器注册/注销服务。Registrator支持可插拔服务注册中心，当前包括Consul、etcd和SkyDNS 2。
用法  运行Consul容器  $ docker run -d --name=consul --net=host consul-server -bootstrap  运行Registrator容器 Registrator被设计为在每个主机运行一次。也可以在每个集群仅运行一个Registrator，但是通过确保Registrator运行在每个主机上可以获得更好的伸缩性和更简化的配置。假定使用某种程度的自动化，在所有地方都运行反而讽刺性地比某个地方运行更简单。  $ docker run -d \ --name=registrator \ --net=host \ --volume=/var/run/docker.sock:/tmp/docker.sock \ gliderlabs/registrator:latest \ consul://localhost:8500  &amp;ndash;volume=/var/run/docker.sock:/tmp/docker.sock可以让Registrator访问DockerAPI； &amp;ndash;net=host有助于Registrator获得主机级IP和主机名； consul://localhost:8500是服务注册中心URI。 运行其他服务的容器 $ docker run -d -P --name=redis redis Registrator通过Docker API可以监听Docker容器的启动/关闭，并自动注册/注销服务: ``` $ curl $(boot2docker ip):8500/v1/catalog/services {&amp;ldquo;consul&amp;rdquo;:[],&amp;ldquo;redis&amp;rdquo;:[]}   $ curl $(boot2docker ip):8500/v1/catalog/service/redis [{&amp;ldquo;Node&amp;rdquo;:&amp;ldquo;boot2docker&amp;rdquo;,&amp;ldquo;Address&amp;rdquo;:&amp;ldquo;10.0.2.15&amp;rdquo;,&amp;ldquo;ServiceID&amp;rdquo;:&amp;ldquo;boot2docker:redis:6379&amp;rdquo;,&amp;ldquo;ServiceName&amp;rdquo;:&amp;ldquo;redis&amp;rdquo;,&amp;ldquo;ServiceTags&amp;rdquo;:null,&amp;ldquo;ServiceAddress&amp;rdquo;:&amp;ldquo;&amp;rdquo;,&amp;ldquo;ServicePort&amp;rdquo;:32768}] ```
参考 Github：gliderlabs/registrator
Registrator Quickstart
Docker Hub：gliderlabs/registrator
Scalable Architecture DR CoN: Docker, Registrator, Consul, Consul Template and Nginx</description>
    </item>
    
    <item>
      <title>了解Consul template</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3consul_template/</link>
      <pubDate>Wed, 17 Jun 2015 06:22:19 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3consul_template/</guid>
      <description>支持 DNS 和基于HTTP发现机制的服务发现工具Consul让我们印象深刻。它提供了定制化的注册服务健康检查并标记不健康实例的功能远胜于其他类似的工具。更多时兴的工具与Consul的集成使其功能更加强大。ConsulTemplate守护进程提供了一个便捷方式直接使用Consul的信息来填充配置文件。 consul-template 查询一个Consul实例并对文件系统任意数量模板进行更新。此外，consul-template 在更新过程结束后可选地执行任意多个命令。 consul-template 项目提供了一些例子，通过Consul信息生成负载均衡器HAProxy、缓存引擎Varnish和web服务器Apachehttpd的配置文件。
参考 Github：hashicorp/consul-template
Scalable Architecture DR CoN: Docker, Registrator, Consul, Consul Template and Nginx</description>
    </item>
    
    <item>
      <title>使用Consul的十二要素应用（Twelve-Factor App）</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</link>
      <pubDate>Tue, 16 Jun 2015 05:36:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</guid>
      <description>十二要素应用（The Twelve-Factor App）主张web应用应该从环境变量里获取其配置。这一实践很快被现代PaaS服务采用以用于允许简单的配置变更。 使用Consul，很容易将这一实践用于你自己的数据中心。如果你基础架构的某些方面部分使用PaaS，Consul是配置数据中心化的一个很好的方式。 在这篇文章中，我们将展示Consul和envconsul如何在不修改应用程序的情况下被用于设置配置值和在配置变更时触发自动重启。
为什么使用环境变量? 根据十二要素应用，web应用配置应该使用环境变量。跟配置文件或Java系统属性这样的机制比，环境变量有很多优点： - 环境变量是一个与开发语言和操作系统无关的标准。 - 环境变量更难被意外提交到代码库。 - 环境变量跟易于在development、staging、QA这样不同的环境之间改变。 - 无论如何部署，环境变量易于设置和更新。
例如Heroku这样的完整PaaS解决方案公开一些有用的API以用于为应用自动设置/读取环境变量。 当手动部署应用时，以往这样的事会更复杂一些。而使用Consul，程序员就可以很容易地设置和读取配置，运营工程师就可以很容易地提供支持和维护。
Consul键值对和Envconsul Consul能够存储键值对数据。对于设置和获取键值对数据，Consul拥有简单的API和美丽且直观的web界面。对于存储配置数据来说，它是完美的。 很容易看到如何设置和读取配置数据，但是对于配置数据如何变成应用的环境变量还不是很清楚。envconsul是一个解决该类问题的轻量级解决方案。 使用envconsul，环境变量存储在ConsulKV中并具有某些（以&amp;rdquo;/&amp;ldquo;分割的）前缀。例如，为了配置服务&amp;rdquo;foo&amp;rdquo;，我们可能存储如下配置：
$ curl -X PUT -d &#39;false&#39; http://localhost:8500/v1/kv/foo/enabled true  这会在键foo/enabled中存储值false。 之后，使用envconsul, 我们可以将这些键转换为环境变量：
$ envconsul foo env ENABLED=false  envconsul是一个对UNIX非常友好的应用。他有两个必需的参数：一个用于查找数据的KV前缀和一个应用及其可选参数。在上例中，我们告诉envconsul配置位于前缀foo下，且我们想运行应用env，该应用仅仅是输出环境变量。 在示例结果中，我们可以清楚地看到ENABLED如我们在ConsulKV中所设置的false。
如果将env改成你自己的应用，那么环境变量将暴露给你的应用。例如，为了运行一个Rails服务器你可能做如下操作。注意在真实生产场景中，你可能不直接运行Rails内建服务器，但是它不失为一个好案例：
$ envconsul foo bin/rails server ...  自动重载 使用PaaS，当你修改任何配置时你的应用将自动重启。我们可以以最小的代价通过Consul和Envconsul实现相同效果。 通过对envconsul添加-reload标志，一旦配置键发生增删改，envconsul将中断(SIGTERM)并重启你的应用：
$ envconsul -reload foo bin/rails server ...  注：该功能已经在0.4.0版本移除。 Consul HTTP API支持对给定前缀KV中的变更进行长轮询。一旦KV中发生变更，Envconsul通过这种方式可以高效地进行检测。
改良流程 对应用配置使用Consul和envconsul可以将PaaS化应用配置易用性带入你自己的原生环境。 对于开发者而言，他们可以无需跟运营工程师沟通或重新部署应用就可以设置配置。 对于运营来说，Consul对整个基础架构的服务发现和配置提供了统一的解决方案。Consul自动复制数据并存储在磁盘上以方便备份，运营工程师也可以高枕无忧了。
我的实践 Envconsul获取的环境变量既可以直接给启动服务器的命令使用（例如上面启动Rails内建服务器的bin/rails命令）；也可以通过python之类的脚本存成Java系统属性文件，通过chpst这样可以加载环境变量/系统属性文件的命令间接给Java命令使用。</description>
    </item>
    
    <item>
      <title>Vagrant运行Docker的几种方法</title>
      <link>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 15 Jun 2015 06:15:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>Vagrant的docker provisioner能够自动安装Docker、下载Docker容器、随着vagrant up命令自动运行容器。 Vagrantfile Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.provision &amp;quot;docker&amp;quot; do |d| d.pull_images &amp;quot;consul&amp;quot; d.run &amp;quot;consul&amp;quot; d.pull_images &amp;quot;rabbitmq&amp;quot; d.run &amp;quot;rabbitmq&amp;quot; end end  仅使用Vagrant的docker provisioner安装Docker，使用脚本下载并运行Docker容器 Vagrantfile # Install Docker config.vm.provision &amp;quot;docker&amp;quot; # Download Docker images, create and start containers config.vm.provision :shell, :path =&amp;gt; &amp;quot;runMyDockers.sh&amp;quot;  runMyDockers.sh #!/bin/bash docker rm -f consul 2&amp;gt;/dev/null docker create --hostname consul --name consul -v /data/consul1:/data --dns 127.0.0.1 --restart always -p 8500:8500 --env CONSUL_OPTIONS=-bootstrap consul:dev docker start consul docker rm -f rabbitmq 2&amp;gt;/dev/null docker create --name rabbitmq --hostname rabbitmq -p 5672:5672 -v /data/rabbitmq:/data --dns 127.</description>
    </item>
    
    <item>
      <title>Consul实践</title>
      <link>https://mryqu.github.io/post/consul%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 14 Jun 2015 23:08:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/consul%E5%AE%9E%E8%B7%B5/</guid>
      <description>Consul简介 最近除了在用Hashicorp公司的Vagrant，也使用了Consul。Consul是一款以跨数据中心、高可用的方式提供服务注册、发现、配置和编排的工具。Consul可以用来回答一个企业的基础设施中，诸如下列这些问题：
 “服务X在哪里” “服务Y的实例是否健康” “当前正在运行的服务是什么” “服务Z的配置是怎样的” “在我的平台上是否还有其他人在执行操作A？”  Consul通过DNS或HTTP API提供服务发现功能，同时支持跨数据中心的内部服务或外部服务的发现。使用shell脚本实现了健康检查，并允许创建自定义的服务验证协议。Consul还提供了高可用的键值对存储，由此可以暴露一致的存储值，用于配置参数的调优，而不必非要执行配置管理工具。可调优的操动实例包括指定服务的位置、指明系统处于维护模式，或者设置服务的QoS参数。Consul还提供了一套编排原语、通过UDP协议跨数据中心广播异步“事件”、通过TCP协议让指定的计算机同步执行“exec”指令，以及通过实现长轮询、react、事件机制或者其他操作实现定制化的监控。
安装Consul echo Installing dependencies... sudo apt-get install -y unzip curl echo Fetching Consul... cd /tmp/ wget https://dl.bintray.com/mitchellh/consul/0.5.2_linux_amd64.zip -O consul.zip echo Installing Consul... unzip consul.zip sudo chmod +x consul sudo mv consul /usr/mryqu/consul echo Fetching Consul UI... cd /tmp/ wget https://dl.bintray.com/mitchellh/consul/0.5.2_web_ui.zip -O dist.zip echo Installing Consul UI... unzip dist.zip sudo chmod +x dist sudo mv dist /usr/mryqu/consul/dist  引导一个数据中心 首先以服务器模式运行第一个Consul代理。Consul需要使用-bootstrap-expect指定集群节点个数，使用-data-dirparameter指定一个数据目录名，使用-ui-dir参数指定Consul UI目录:</description>
    </item>
    
    <item>
      <title>使用Vagrant创建开发环境</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8vagrant%E5%88%9B%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Fri, 12 Jun 2015 22:46:10 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8vagrant%E5%88%9B%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>用思维导图写了一篇[Packt Publishing] Creating Development Environments with Vagrant读书笔记。 </description>
    </item>
    
    <item>
      <title>通过环境变量修改VAGRANT BOX参数</title>
      <link>https://mryqu.github.io/post/%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9vagrant_box%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 12 Jun 2015 06:14:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9vagrant_box%E5%8F%82%E6%95%B0/</guid>
      <description>在如下示例Vagrantfile文件片段，VAGRANTBOX的内存和CPU核数首先查询环境变量，如果没有设相关环境变量的话则使用默认值。
config.vm.provider &amp;quot;virtualbox&amp;quot; do |v| v.memory = ENV.has_key?(&#39;VAGRANTBOX_MEM&#39;) ? ENV[&#39;VAGRANTBOX_MEM&#39;].to_i : 1024 v.cpus = ENV.has_key?(&#39;VAGRANTBOX_CPUS&#39;) ? ENV[&#39;VAGRANTBOX_CPUS&#39;].to_i : 2 v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--natdnshostresolver1&amp;quot;, &amp;quot;on&amp;quot;] v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--cpuexecutioncap&amp;quot;, &amp;quot;75&amp;quot;] end  参考 Vagrant VirtualBox Configuration</description>
    </item>
    
    <item>
      <title>cAdvisor实践</title>
      <link>https://mryqu.github.io/post/cadvisor%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 11 Jun 2015 00:40:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cadvisor%E5%AE%9E%E8%B7%B5/</guid>
      <description>cAdvisor (Container Advisor)为运行容器的用户提供出色的资源使用和性能特征。这是一个运行守护进程，能够搜集、集料、处理和导出运行中的容器的信息。特别需要指出，每个容器都有资源隔离参数、历史资源使用、以及完整历史数据的柱状图。 cAdvisor目前支持Docker容器和lmctfy容器。
运行cAdvisor容器 配置boot2docker与宿主机之间的端口转移 查看cAdvisor 参考 GitHub：cAdvisor</description>
    </item>
    
    <item>
      <title>DockerUI实践</title>
      <link>https://mryqu.github.io/post/dockerui%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 10 Jun 2015 06:08:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/dockerui%E5%AE%9E%E8%B7%B5/</guid>
      <description>DockerUI是Docker远程API的Web接口,它是由下列技术栈构成的纯客户端，因此很容易连接和管理Docker。 - Angular.js - Bootstrap - Gritter - Spin.js - Golang - Vis.js
运行DockerUI容器 配置boot2docker与宿主机之间的端口转移 另一种方式是在启动容器之前执行：
boot2docker ssh -L 9000:localhost:9000  查看DockerUI 直接使用Docker远程API 参考 GitHub：crosbymichael/dockerui
Docker Remote API</description>
    </item>
    
    <item>
      <title>Docker Compose笔记</title>
      <link>https://mryqu.github.io/post/docker_compose%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 06 Jun 2015 05:33:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/docker_compose%E7%AC%94%E8%AE%B0/</guid>
      <description>Docker Compose概述 DockerCompose
前身 Fig
 Compose是用于在Docker内定义和运行多容器应用程序的工具。使用Compose，可以在一个文件内定义多容器应用程序，然后使用一个命令运行应用。 Compose对开发环境、交付准备服务器（stagingservers）和持续集成（CI）很有帮助，不建议用于生产环境。 使用Compose基本上是三步流程： - 通过一个Dockerfile定义应用环境，以便在其他地方复制； - 在docker-compose.yml中定义组成应用的服务，因此他们可以在一个隔离的环境一起运行； - 最后，运行docker-compose up，Compose将启动并运行整个应用。
docker-compose.yml大概是这个样子的:
web: build: . ports: - &amp;quot;5000:5000&amp;quot; volumes: - .:/code links: - redis redis: image: redis  Compose包含管理应用整个生命周期的命令: - 启动、停止和重建服务 - 查看运行的服务状态 - 对运行的服务的日志输出生成数据流 - 对一个服务运行一次性命令
Docker Compose安装 curl -L https://github.com/docker/compose/releases/download/VERSION_NUM/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose  Docker Compose命令 更新整个应用 mryqu$ docker-compose stop # stop the containers mryqu$ docker-compose pull # download updated images mryqu# docker-compose up -d # creates new containers and starts them  更新单个服务 mryqu$ docker-compose stop foo # stop the foo service mryqu$ docker-compose pull foo # download foo service mryqu$ docker-compose up -d foo # start the new foo service  参考 Overview of Docker Compose</description>
    </item>
    
    <item>
      <title>使用Docker的现代十二要素应用</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 04 Jun 2015 05:26:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</guid>
      <description>【编者的话】“十二要素应用”为开发SaaS应用提供了方法上的指导，而Docker能够提供打包依赖，解耦后端服务等特性，使得两者非常吻合。这篇文章介绍了Docker特性怎样满足了开发“十二要素应用”的对应要点。Docker非常适合开发“十二要素应用”。
“十二要素应用”为构建SaaS应用提供了方法论，是由知名PaaS云计算平台Heroku的创始人AdamWiggins提出的。请参考这篇[文章](http://www.infoq.com/cn/news/2012/09/12-factor-app)。  Dockerfile与docker-compose.yml正在成为用代码定义服务的标准，通过它们可以定义服务的所有内容：依赖、环境、端口、各种进程以及后端服务。Docker镜像和容器为操作系统提供了保证，使得开发环境和生产环境可以有效地保持一致。这篇文章简单地介绍了Docker是怎样满足“十二要素应用”的核心要点的。它解释了用Docker开发一个典型的“Rails/Postgres/Redis/web/worker”所应用的技术。后续文章将通过代码深入介绍如何应用这些技术。
II. 依赖—显示地声明和隔离依赖关系 Docker镜像基于显示的Dockerfile构建，而Docker容器作为独立的运行环境。Dockerfile提供了显示声明基础操作系统的方法（FROM）,而且通过运行命令来安装附加的系统包以及应用的依赖包（RUN）。通过这些方法，你可以声明你需要ubuntu 14.04、Ruby 2.2.2、Node 0.11，然后一次性安装。
III. 配置—在环境中储存配置 Docker容器非常依赖Linux的环境变量进行配置。docker-compose.yml有一个环境变量的哈希表，你可以通过它显示的定义容器的环境变量。这些默认的或者未定义的值将在运行时从主机中继承。另外，还有Dokckerfile的ENV命令以及『docker run –env=[]』和『docker run–env-file=[]』运行选项可以设置环境变量。通过这些方法，你可以声明你的应用需要环境变量GITHUB_AUTH_TOKEN。 VII. 端口绑定—通过端口绑定来提供服务 Docker非常依赖端口绑定。docker-compose.yml有一个端口阵列，可以通过它显示的定义“主机:容器”的端口绑定。『docker run –pHOST:CONTAINER』让你可以在运行时定义端口绑定。通过这些方法，你可以声明你的应用的网络服务器将监听端口5000，而且你可以通过主机的端口5000获取服务。
IV. 后端服务—把后端服务当作附加资源 Docker容器与其它容器几乎完全隔离，所以需要通过网络与后端服务进行通信。docker-compse.yml有一个链接哈希表，你可以通过它指定你的应用所需要依赖的其他容器服务。‘docker-composeup’命令将首先开启这些后端服务，然后配置应用容器中网络连接信息的环境变量。通过这些方法，你可以声明你的应用需要Postgres 9.4和Redis3.0服务，让你的应用通过主机名和端口号与他们建立连接。
VI. 进程—以一个或者多个无状态进程运行应用 默认情况下，Docker容器是不带储存的进程。docker-compose.yml定义了一系列服务，每一个服务都有自己的镜像或者构建文件(Dockerfile)以及命令。通过这些方法，你可以声明你的应用同时有一个网络进程和工作进程。
XII. 管理进程—后台管理任务当做一次性进程运行 Docker镜像可以很容易地运行一次性进程。‘docker run myapp CMD’可以在与你的网络进程一致的环境中运行任意命令。通过这些方法，你可以基于你的Postgres数据库运行交互式的bash或者运行一次性的’rakedb:migrate’进程。
现有技术 若没有Docker，OS X的开发工具链是这样的：Homebrew作为系统依赖包， Postgres和Redis作为开发服务,Ruby的Bundler作为跨平台开发依赖，一系列的Shell脚本和foreman让所有工具在本地同时运行起来，以及一个独立的基于Linux的构建服务负责将应用打包到生产环境。这样的工作流并没有错误，但是Docker提供一个更简洁的方式。有了Dockerfile和docker-compose.yml文件，我们将不再需要任何OSX系统依赖，服务包或者跨平台的语言依赖。一个简单的“dicker-composeup”命令可以提供一个完整的Linux开发环境，并且能够轻易地将“十二要素应用”移植到生产机器。
原英文链接：Modern Twelve-Factor Apps With Docker
原译文链接：现代“十二要素应用”与Docker</description>
    </item>
    
    <item>
      <title>读八种Docker开发模式</title>
      <link>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Jun 2015 06:22:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</guid>
      <description>Eight Docker Development Patterns（原文）
八种Docker开发模式（译文）
八种Docker开发模式（介绍）
目前，我对可重用的基础容器和支持共享文件夹的开发容器这两种模式接触的多一些。</description>
    </item>
    
    <item>
      <title>Docker速查笔记</title>
      <link>https://mryqu.github.io/post/docker%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 02 Jun 2015 22:16:06 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/docker%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/</guid>
      <description>常用命令 登入运行的docker容器内 docker exec -it $dockerContainerName /bin/bash  查看docker日志 docker logs --tail=&amp;quot;5&amp;quot; -f $dockerContainerName  清除容器及镜像 docker stop $(docker ps -a -q) #停止所有容器 docker rm $(docker ps -a -q) #删除所有容器 docker rmi $(docker images -q) #删除所有镜像  参考 Docker Cheat Sheet
Docker Command Line
Dockerfile reference
The Docker Book</description>
    </item>
    
    <item>
      <title>Vagrant base box列表</title>
      <link>https://mryqu.github.io/post/vagrant_base_box%E5%88%97%E8%A1%A8/</link>
      <pubDate>Thu, 28 May 2015 05:28:59 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant_base_box%E5%88%97%E8%A1%A8/</guid>
      <description>Vagrant的basebox都是打包了最小安装版操作系统(仅有一些跟Vagrant通讯必需的工具)的虚拟机镜像。vagrantbox.es列出了很多Vagrant的basebox，其中既有官方的box也有很多非官方的box。 有的box名是lucid32.box、lucid64.box、precise32.box、precise64.box，一开始不明白怎么回事，后来知道用的是Ubuntu的英文代码。
Ubuntu各种版本的英文代码 |版本|英文代号|中译 |&amp;mdash;&amp;ndash; |Ubuntu 4.10|Warty Warthog|多疣的疣猪 |Ubuntu 5.04|Hoary Hedgehog|白发的刺猬 |Ubuntu 5.10|Breezy Badger|活泼的獾 |Ubuntu 6.06|Dapper Drake|整洁的公鸭 |Ubuntu 6.10|Edgy Eft|尖利的小蜥蜴 |Ubuntu 7.04|Feisty Fawn|烦躁不安的鹿 |Ubuntu 7.10|Gutsy Gibbon|胆大的长臂猿 |Ubuntu 8.04|Hardy Heron|坚强的鹭 |Ubuntu 8.10|Intrepid Ibex|无畏的羱羊 |Ubuntu 9.04|Jaunty Jackalope|活泼的鹿角兔 |Ubuntu 9.10|Karmic Koala|幸运的树袋熊 |Ubuntu 10.04|Lucid Lynx|清醒的猞猁 |Ubuntu 10.10|Maverick Meerkat|标新立异的的狐獴 |Ubuntu 11.04|Natty Narwhal|敏捷的独角鲸 |Ubuntu 11.10|Oneiric Ocelot|有梦的虎猫 |Ubuntu 12.04|Precise Pangolin|精准的穿山甲 |Ubuntu 12.10|Quantal Quetzal|量子的格查尔鸟 |Ubuntu 13.04|Raring Ringtail|铆足了劲的环尾猫熊 |Ubuntu 13.10|Saucy Salamander|活泼的蝾螈 |Ubuntu 14.04|Trusty Tahr|可靠的塔尔羊 |Ubuntu 14.10|Utopic Unicorn|乌托邦的独角兽 |Ubuntu 15.</description>
    </item>
    
    <item>
      <title>玩一下gradle-jvmsrc-plugin</title>
      <link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</link>
      <pubDate>Wed, 27 May 2015 05:51:01 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</guid>
      <description>玩了一下gradle-jvmsrc-plugin插件，使用这个插件后执行gradlecreateJvmSrcDirs可以根据Gradle项目的JVM语言插件（(java、groovy、scala、android等），自动创建默认的源代码、测试和资源包目录。例如： - src/main/resources - src/main/java/ - src/main/groovy/ - src/test/java/ - src/test/groovy/ - src/test/resources
刚上手总是报错，看了一下CreateJvmSourceDirs.groovy，定位到packageToDirectoryPath方法：
* What went wrong: Execution failed for task &#39;:HelloJvmsrc:createJvmSrcDirs&#39;. &amp;gt; character to be escaped is missing  按照如下gradle-jvmsrc-plugin的说明，要配置基础包名。可是真按它介绍的带有.分割的包名就会出错，简单改成&amp;rdquo;com&amp;rdquo;这种没有.分割的包名就可以避免错误。
jvmsrc { packageName &amp;quot;com.mycompany.myproject.mymodule&amp;quot; }  此外，gradle-jvmsrc-plugin对空目录默认生成.gitkeep文件。 总体来说，用处不是很大，可以偷点懒！</description>
    </item>
    
    <item>
      <title>winrar中文版免费了</title>
      <link>https://mryqu.github.io/post/winrar%E4%B8%AD%E6%96%87%E7%89%88%E5%85%8D%E8%B4%B9%E4%BA%86/</link>
      <pubDate>Sun, 24 May 2015 22:45:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/winrar%E4%B8%AD%E6%96%87%E7%89%88%E5%85%8D%E8%B4%B9%E4%BA%86/</guid>
      <description>5月21日，软众信息宣布中国WinRAR完全免费。以下是新闻稿全文：我们很荣幸地宣布，经过15年多的时间，现在终于向中国的个人用户提供一款完全免费的WinRAR简体中文版了。这是因为WinRAR 的全球独家发行商 win.rar GmbH 和 www.winrar.com.cn 希望藉此来感谢数亿中国用户长久以来对WinRAR的信任。许多公司曾试图复制类似WinRAR的产品，但是我们的用户始终相信我们并坚持使用原版软件，即使这意味着不得不在同一台计算机上运行两种压缩工具。 随着全新的 WinRAR免费非商用个人版本的发布，我们为中国的每一个用户提供当今市面上安全、可靠、出色的压缩软件。您现在可以正式从www.winrar.com.cn 完全免费地下载和使用WinRAR，无需搜索或下载破解产品，也不必寻找非法版本，或冒着安全风险从不安全的网站进行下载。WinRAR 现在还包含最佳的RAR5 压缩算法，该软件可以从www.winrar.com.cn 获取官方版本。 现在，您完全可以享受始终使用 WinRAR 的最新版本。 我们已经与中国实力雄厚、值得信赖的公司展开合作，来为您实现这一目标。www.winrar.com.cn 能够以对用户极其友好的方式，提供我们本地中国合作伙伴的产品。如果您不喜欢我们合作伙伴的产品，您只需点击取消即可。不存在任何秘密跟踪、监视或隐藏的安装！我们在未来将继续与中国最大的互联网和软件公司建立良好关系，由此来为您提供可以信赖的其他优秀产品和服务。我们已与 360和百度等互联网公司建立合作伙伴关系来推进在中国和国外的合作，而且我们期望持续完善这些业务，并与其他值得信任的知名公司建立新的合作伙伴关系。在2012 年，win.rar GmbH（德国总部）的创始人兼总裁 Burak Canboy已决定迁居中国，其后便一直住在我们这个美好的国家，亲自协调我们已在中国建立的合作伙伴关系，尤其要表达他对众多中国用户长久以来信赖WinRAR 软件的敬意。 “我们知道中国已经有4亿多用户在使用 WinRAR，我们十分高兴并感谢您如今仍然深爱WinRAR。非常感谢您信任我们的产品！”
http://www.winrar.com.cn/download.htm 中国个人免费版（64位）官网下载：http://www.winrar.com.cn/download/winrarx64-521scp.exe （数字签名：UTC+8，2015.05.20，16:09:31） 中国个人免费版（32位）官网下载：http://www.winrar.com.cn/download/winrar521scp.exe</description>
    </item>
    
    <item>
      <title>[Gradle] 在子项目中共享项目属性</title>
      <link>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Fri, 22 May 2015 06:09:34 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</guid>
      <description>build.gradle:
buildscript { repositories { mavenCentral() } } subprojects { apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 ext { HadoopVersion = &#39;2.7.x&#39; JUnitVersion = &#39;4.11&#39; ...... } }  HelloHadoopClient/build.gradle：
jar { baseName = &#39;hello-hadoopclient&#39; version = &#39;0.1.0&#39; } dependencies { compile &amp;quot;org.apache.hadoop:hadoop-common:${HadoopVersion}&amp;quot; testCompile &amp;quot;junit:junit:${JUnitVersion}&amp;quot; }  HelloMapReduce/build.gradle：
jar { baseName = &#39;hello-mapreduce&#39; version = &#39;0.1.0&#39; } dependencies { compile &amp;quot;org.</description>
    </item>
    
    <item>
      <title>Apt-get代理配置</title>
      <link>https://mryqu.github.io/post/apt-get%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 20 May 2015 00:03:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/apt-get%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid>
      <description>在公司安装Ubuntu docker后使用apt-get update总是失败，经历了一番周折才成功。
DNS？ 一开始怀疑是DNS问题，可以学习了下面几个帖子： - Docker apt-get update fails - Docker - Network calls fail during image build on corporate network - How do I set my DNS on Ubuntu 14.04?
检查我ubuntu配置：
 cat /etc/resolv.conf  确认DNS没有问题。
Ubuntu官方服务器？ 是不是我的机器连不上欧美的Ubuntu官方服务器，换成中国服务器试试。尝试了Ubuntu 14.04服务器列表上的中国服务器还是不成。
Apt-get代理？ 照着how to install packages with apt-get on a system connected via proxy?设置一番，成功了
设置/etc/apt/apt.conf：
Acquire::http::proxy &amp;quot;http://yourServer:yourPort/&amp;quot;; Acquire::ftp::proxy &amp;quot;ftp://yourServer:yourPort/&amp;quot;; Acquire::https::proxy &amp;quot;https://yourServer:yourPort/&amp;quot;;  如需用户名、密码，则作如下修改：
Acquire::http::proxy &amp;quot;http://yourUsr:yourPwd@yourServer:yourPort/&amp;quot;; Acquire::ftp::proxy &amp;quot;ftp://yourUsr:yourPwd@yourServer:yourPort/&amp;quot;; Acquire::https::proxy &amp;quot;https://yourUsr:yourPwd@yourServer:yourPort/&amp;quot;;  最好将上述配置也存入/etc/apt/apt.</description>
    </item>
    
    <item>
      <title>在Ubuntu中强制Apt-get使用IPv4或IPv6</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E5%BC%BA%E5%88%B6apt-get%E4%BD%BF%E7%94%A8ipv4%E6%88%96ipv6/</link>
      <pubDate>Mon, 18 May 2015 06:14:43 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E5%BC%BA%E5%88%B6apt-get%E4%BD%BF%E7%94%A8ipv4%E6%88%96ipv6/</guid>
      <description>快速命令行选项 如果只想一次使apt-get使用IPv4或IPv6，使用下列步骤。该功能尽在apt-get的0.9.7.9~exp1版本后可用。首先，通过如下命令确认apt-get版本高于0.9.7.9~exp1：
apt-get --version  结果近似于:
apt 1.0.1ubuntu2 for amd64 compiled on Oct 28 2014 20:55:14  版本核实后，可以通过如下命令强制使用IPv4:
apt-get -o Acquire::ForceIPv4=true update  或IPv6:
apt-get -o Acquire::ForceIPv6=true update  这会将_sources.list_中的URL仅解析成IPv4并更新仓库。
持久化的选项 为了让设置持久化，在/etc/apt/apt.conf.d/下创建99force-ipv4文件。
sudoedit /etc/apt/apt.conf.d/99force-ipv4  在该文件放入如下内容：
Acquire::ForceIPv4 &amp;quot;true&amp;quot;;  保存文件即可。如果相反想强制使用IPv6，将文件名及其内容中的4改成6即可。
原文: https://www.vultr.com/docs/force-apt-get-to-ipv4-or-ipv6-on-ubuntu-or-debian</description>
    </item>
    
    <item>
      <title>尝试boot2docker和Vagrant-boot2docker box</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95boot2docker%E5%92%8Cvagrant-boot2docker_box/</link>
      <pubDate>Sun, 17 May 2015 20:40:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95boot2docker%E5%92%8Cvagrant-boot2docker_box/</guid>
      <description>boot2docker boot2docker是基于Tiny Core Linux的轻量级Linux发布版本虚拟机，专用于运行Docker容器。 功能如下： - 3.18.5内核及AUFS文件系统、Docker 1.5.0 - 容器通过磁盘自动加载在/var/lib/docker目录持久化 - SSH密钥通过磁盘自动加载进行持久化 - 容易访问Docker映射端口的主机模式（Host-only）
Vagrant兼容的boot2docker box Vagrant创始人Mitchell Hashimoto使用boot2docker虚拟机创建了一个可被VirtualBox和VMware提供者支持的Vagrant box。当Vagrant被运行于Linux之外的操作系统时，Vagrant的Docker提供者默认使用boot2dockerbox提供Docker功能。 参考 boot2docker官网
GitHub:boot2docker
GitHub:boot2docker-cli
GitHub:mitchellh/boot2docker-vagrant-box
yungsang/boot2docker
GitHub:yungsang/boot2docker
Using Docker with Vagrant
Setting up a development environment using Docker and Vagrant
Docker in OSX via boot2docker or Vagrant: getting over the hump</description>
    </item>
    
    <item>
      <title>了解一下Gerrit与BitBucket集成</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bgerrit%E4%B8%8Ebitbucket%E9%9B%86%E6%88%90/</link>
      <pubDate>Sun, 17 May 2015 00:18:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bgerrit%E4%B8%8Ebitbucket%E9%9B%86%E6%88%90/</guid>
      <description>在《Gerrit插件配置》中没有找到有关BitBucket的信息。 通过https://marketplace.atlassian.com/search?q=Gerrit在Atlassian市场搜到几个跟Gerrit相关的控件，不过都是为JIRA/BitBucket/Bambooserve增加类似Gerrit的工作流的功能。 结论就是：目前没法用Gerrit为BitBucket进行代码审查。</description>
    </item>
    
    <item>
      <title>了解用于Gerrit代码审查的GitHub插件</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E7%94%A8%E4%BA%8Egerrit%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84github%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 16 May 2015 07:28:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E7%94%A8%E4%BA%8Egerrit%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84github%E6%8F%92%E4%BB%B6/</guid>
      <description>在网上看到了GitHub plugin for Gerrit，学习一下。
对比GitHub与Gerrit的代码审查机制 GitHub一派的代码审查机制主要通过fork一个远程分支，进行本地修改并提交到远程分支，然后通过PULL REQUEST来请求代码审查及合并回原上游远程分支。 Gerrit一派的代码审查机制主要通过checkout一个分支(refs/for/master)。从Gerrit克隆获得本地分支，进行修改并提交到Gerrit的refs/for/master分支，中间还可以通过Amend commit修改之前的提交，经过评审人批准后，代码会提交到&amp;rdquo;权威&amp;rdquo;仓库。 GitHub BitBucket GitLab Gitorious阵营 这一派的PULL REQUEST基于两个分支的合并，注释可能会乱一点，有点惹人烦。不考虑将所有原子/相关修改作为一个提交。除了写注释无法知道审查打分情况。 Gerrit GitBlit阵营 这一派的每个提交有其审查结果，可以清晰查看以往历史。Gerrit审查可以强制成仅接受快进（fast-worward）或可rebase的提交。 用于Gerrit代码审查的GitHub插件 https://gerrit-review.googlesource.com/#/admin/projects/plugins/github 优点： - 引入Pull Requests -&amp;gt;Gerrit改动/主题 - 使用Gerrit认证规则重用GitHub账户 - 复制: 代码继续存在于http://github.com 仓库 - 防止不可管理的fork激增 - 避免GitHub垃圾邮件 -&amp;gt;每个改动一封电邮
第一步：为Gerrit在GitHub上注册新的OAUTH应用 第二步：获取Client ID和Client Secret 第三步：下载并安装Gerrit 下载地址：https://gerrit-releases.storage.googleapis.com/index.html 为了确保安装成功，首先使用DEVELOPMENT_BECOME_ANY_ACCOUNT作为认证方式确保能登录进Gerrit。 使用Git Bash启动Gerrit。 登陆后，可以查看到当前安装的插件。 第四步：构建GitHub插件 git clone https://gerrit.googlesource.com/plugins/github &amp;amp;&amp;amp; cd github mvn install  第五步：安装OAUTH过滤器和GitHub插件 第六步：重新配置Gerrit 第七步：完成GitHub认证 参考 GitHub plugin for Gerrit
Gerrit vs Github: for code review and codebase management</description>
    </item>
    
    <item>
      <title>了解构件仓库管理器Artifactory和Nexus</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E6%9E%84%E4%BB%B6%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%99%A8artifactory%E5%92%8Cnexus/</link>
      <pubDate>Wed, 13 May 2015 06:07:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E6%9E%84%E4%BB%B6%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%99%A8artifactory%E5%92%8Cnexus/</guid>
      <description>使用Maven，可以从Maven中央仓库下载所需要的构件（artifact），但这通常不是一个好的做法，一般是在企业内部架设一个Maven仓库服务器，在代理远程仓库的同时维护本地仓库，以节省带宽和时间。企业仓库管理器一般可以提供高并发访问、浏览和查询、报表、访问控制、备份、对其他仓库进行代理、RESTAPI等特性 了解一下构件仓库管理器，市场上最好的是JFrog的Artifactory和Sonatype的Nexus，而且这两个产品既有商业版也有免费社区版。 以Artifactory为例，Ant+Ivy、Maven和Gradle这些构建工具都可以自动下载Artifactory里的构件（artifact），此外Jenkins、Bamboo等CI工具也可以通过构建工具将生成的构件（artifact）部署到Artifactory上。 如果将构建结果部署到Artifactory，需要对Maven构建增加如下选项：
deploy -DaltDeploymentRepository=snapshots::default::http://svcartifact.yqu.com:8081/artifactory/snapshots  如果将release构建结果部署到Artifactory，需要对Maven构建增加如下选项：
deploy -DaltDeploymentRepository=release::default::http://svcartifact.yqu.com:8081/artifactory/release  或者在pom.xml中内嵌distributionManagement： 最近网上有一个不错的帖子 Maven Repository Manager Feature Matrix，对比了Archiva、Artifactory和Nexus的功能和价格，可供有需要做Maven仓库管理器技术选型的同学借鉴。
参考 JFrog Artifactory官网
Sonatype Nexus官网
Artifactory – 1 Min Setup
Apache Maven Deploy Plugin</description>
    </item>
    
    <item>
      <title>定制Vagrant box主机</title>
      <link>https://mryqu.github.io/post/%E5%AE%9A%E5%88%B6vagrant_box%E4%B8%BB%E6%9C%BA/</link>
      <pubDate>Thu, 07 May 2015 21:34:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AE%9A%E5%88%B6vagrant_box%E4%B8%BB%E6%9C%BA/</guid>
      <description>做个笔记，记录一下如何定制Vagrant box主机。 - 在Vagrantfile中通过一个Vagrant基础box定制box。 - 启动该定制box后，通过Vagrant package命令输出box文件 - 编写JSON格式的box元数据文件 - 将定制box文件及其元数据文件放到web服务器中 - 将此定制box作为基础box的Vagrantfile中，设置如下 - config.vm.box用于匹配上述定制box的名称 - config.vm.box_url为box文件的URL或box元数据文件的URL当config.vm.box_url为box文件的URL，该box文件即为基础box；当config.vm.box_url为box元数据文件的URL，可以使用config.vm.box指定名称的某一版本box文件（有config.vm.box_version参数，即使用其约束的特定版本；否则，使用最新版本box文件）作为基础box。 - config.vm.box_version指定box的特定版本。
参考 Custom Vagrant Cloud Versioned Box Host
Vagrant: CREATING A BASE BOX
Vagrant: MACHINE SETTINGS</description>
    </item>
    
    <item>
      <title>找不到TTY而导致的Vagrant destroy失败</title>
      <link>https://mryqu.github.io/post/%E6%89%BE%E4%B8%8D%E5%88%B0tty%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_destroy%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Wed, 06 May 2015 05:50:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%89%BE%E4%B8%8D%E5%88%B0tty%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_destroy%E5%A4%B1%E8%B4%A5/</guid>
      <description>在Windows的Git Bash上想要够过vagrant destroy命令删除一个Vagrant虚拟机，结果碰到了这个错误：  Vagrant is attempting to interface with the UI in a way that requires a TTY. Most actions in Vagrant that require a TTY have configuration switches to disable this requirement. Please do that or run Vagrant with TTY. 
据说Windows上的Cygwin以一种奇怪的方式处理stdin导致Ruby以为没有TTY，没想到Git Bash所基于的MinGW也有这样的问题。 权变措施是使用vagrant destroy --force。
[](http://stackoverflow.com/questions/23633276/vagrant-is-attempting-to-interface-with-the-ui-in-a-way-that-requires-a-tty)
[](https://groups.google.com/forum/#!msg/vagrant-up/ExFet5jMomU/T9FiZluf4ggJ)</description>
    </item>
    
    <item>
      <title>遭遇由VT-x设置导致的vagrant up失败</title>
      <link>https://mryqu.github.io/post/%E9%81%AD%E9%81%87%E7%94%B1vt-x%E8%AE%BE%E7%BD%AE%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_up%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Tue, 05 May 2015 06:06:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%81%AD%E9%81%87%E7%94%B1vt-x%E8%AE%BE%E7%BD%AE%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_up%E5%A4%B1%E8%B4%A5/</guid>
      <description>我在同事申请的一台机器上安装Vagrant box，结果vagrant up失败，报如下错误：  The guest machine entered an invalid state while waiting for it to boot. Valid states are &amp;lsquo;starting, running&amp;rsquo;. The machine is in the &amp;lsquo;poweroff&amp;rsquo; state. Please verify everything is configured properly and try again. If the provider you&amp;rsquo;re using has a GUI that comes with it, it is often helpful to open that and watch the machine, since the GUI often has more helpful error messages than Vagrant can retrieve.</description>
    </item>
    
    <item>
      <title>非技术视角八卦一下docker</title>
      <link>https://mryqu.github.io/post/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%A7%86%E8%A7%92%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bdocker/</link>
      <pubDate>Fri, 01 May 2015 10:03:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%A7%86%E8%A7%92%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bdocker/</guid>
      <description>2010年，几个大胡子年轻人在旧金山成立了一家做 PaaS平台的公司，起名为dotCloud。dotCloud是YCombinator（创投公司） S10的毕业生。创始人：Solomon Hykes - 2006年毕业于EPITECH - European Institute of Technology(硕士) - 2003-2004年做过个人IT教师 - 2006年曾经在SmartJog担任售后工程师 - 2010-2013年担任dotCloud的CEO - 2013年至今担任dotCloud的CTO
dotCloud主要是基于 PaaS 平台为开发者或开发商提供技术服务。PaaS的概念虽好，但是由于认知、理念和技术的局限性，市场的接受度并不高，市场的规模也不够大。除 此之外，还有巨头不断进场搅局，IBM的蓝云，微软的 Azure，Amazon 的 EC2，Google 的 GAE，VMware 的 Cloud Foundry等等，可谓强敌环伺，而且强敌都不差钱，想玩多久就玩多久，想玩多大玩多大。在这种情况下，虽然 dotCloud在2011年初拿到了1000万美元的融资，但依然举步维艰。 Solomon Hykes在这种情况下，决定将自己的核心引擎开源，并让团队的核心成员参与开源项目。这个引擎的名字叫做Docker，以Go语言写成。Docker一经开源立刻得到了「业界」的热烈吹捧。这个容器管理引擎大大降低了容器技术的使用门槛，轻量级，可移植，虚拟化，语言无关，写了程序扔上去做成镜像可以随处部署和运行，Docker迅速从单纯的云端虚机限定资源环境转变成新的代码或应用发布形式，方便有集成开发、快速迭代需求的用户实现多次更新的回退和版本管理，开发、测试和生产环境彻底统一了，还能进行资源管控和虚拟化。 从此以后，他们开始专心研发 Docker 产品和维护相关社区。2013年10月 dotCloud公司更名为Docker股份有限公司，2014年8月Docker宣布把PAAS的业务「dotCloud」出售给位于德国柏林的平台即服务提供商「cloudControl」，dotCloud的历史告一段落。同年8月，Docker内部员工 James Turnbull 发布了面向开发者、运维和系统管理员的 Docker电子书《The DockerBook》。2014年9月，Docker 宣布已获 4000 万美元的 C 轮融资。 2014年6月，Microsoft Open Technology （微软开放技术）宣布 Azure开始支持Docker部署；2014年10月，微软宣布下一个版本的WindowsServer将原生支持Docker；2014年11月，AWS加码押注Docker，推出了高性能容器管理服务EC2Container服务，用户可以在AWS上使用容器轻松地运行和管理分布式应用；2014年12月，Docker宣布发布跨容器的分布式应用编排服务，编排服务可以帮助开发者创建并管理新一代的可移植的分布式应用程序。 Docker的竞争对手是CoreOS公司的容器技术Rocket，现在Rocket得到谷歌、Red Hat以及 VMware等一批大公司的支持。
参考 Docker 传奇之 dotCloud
Docker，云时代的程序交付方式
Docker项目研究
Docker之父Solomon Hykes谈项目开发的初衷和挑战
解读2014之Docker篇：才气、勇气、运气
八个Docker的真实应用场景
Google支持Docker的竞争对手，云计算恩怨又起</description>
    </item>
    
    <item>
      <title>cURL速查表</title>
      <link>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Thu, 30 Apr 2015 06:16:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通訊协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。
请求多个资源curl http://api.test.com/pp/[123-321]
curl http://api.test.com/pp/{abc,def,ghi}/status允许重定向-L如果服务器返回3XX响应，使用-L选项可以让curl向新新地址发送请求。Cookies-b --cookie {name=data}发送原始Cookies或文件中的Cookies
范例：-b &#39;n1=v1; n2=v2&#39;-c / --cookie-jar {file name}将Cookies存入文件发送数据-d / --data {data}-d {data} 发送原始数据
-d {@filename} 发送文件中的数据。
如果不想对@进行解析，可以使用--data-raw。
JSON范例：
-d &#39;{&#34;firstName&#34;:&#34;yd&#34;, &#34;lastName&#34;:&#34;q&#34;}&#39;
原始数据范例：
-d &#39;name=yqu&#39; -d &#39;sex=male&#39;--data-ascii {data}等同于--data
--data-raw {data}几乎等同于--data，除了不对@进行解析。--data-binary {data}--data-binary {data} 发送原始二进制数据
--data-binary {@filename} 发送文件中的二进制数据。
在发送前对数据不做任何处理。发送表单-F / --form {name=content}以Content-Type: multipart/form-data方式发送数据
范例：
curl -F password=@/etc/passwd www.mypasswords.com允许&#34;不安全&#34;SSL-k / --insecure所有的SSL连接使用默认安装的CA证书捆绑试图保障其安全。除非使用-k/--insecure，否则所有被认为是“不安全”的连接将会失败。认证-u / --user {user:password}服务器认证
-U / --proxy-user {user:password}代理认证
代理-x / --proxyHTTP方法-X / --request {request}可以指定的方法为：POST、HEAD、PUT、GET、DELETE输出至文件-o / --output {file}输出到文件而不是标准输出输出至与远端文件同名的本地文件-O / --remote-name上传文件-T / --upload-file {file}curl -T &#34;</description>
    </item>
    
    <item>
      <title>Git&#43;Gerrit&#43;Gradle&#43;Jenkins持续集成</title>
      <link>https://mryqu.github.io/post/git&#43;gerrit&#43;gradle&#43;jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link>
      <pubDate>Sun, 26 Apr 2015 07:45:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git&#43;gerrit&#43;gradle&#43;jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid>
      <description>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile）在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。
Gerrit Gerrit是基于GWT web应用的开源代码审查系统，为使用Git版本控制系统的项目提供在线代码审查。安卓开源项目（AOSP）用其来管理多代码库的庞大项目。Gerrit通过在自身代码库跟踪提交的Git变更集来提供代码审查的。它并排显示新旧文件，让审查者更容易对变更进行审查，并允许审查者添加内嵌注释。 提交的变更既可以被Jenkins这样的自动系统进行审查，也可以由同事进行审查。每个审查者检查代码变更、添加注释，然后将变更标记为“在我看来代码不错”(“没有打分”或“我期望你不要提交代码”)。验证者(例如Jenkins或其他人)通过构建和测试代码来验证变更。如果他们认为代码可行，则设置“在我看来代码不错”标记，Gerrit将尝试将变更合并到公开的“权威”代码库。文章Life of a Patch描述了这一工作流: Gradle 在Java构建工具的世界里，先有了Ant，然后有了Maven。Maven的CoC（约定优于配置）、依赖管理以及项目构建规则重用性等特点，让Maven几乎成为Java构建工具的事实标准。然而，冗余的依赖管理配置、复杂并且难以扩展的构建生命周期，都成为使用Maven的困扰。Gradle作为新的构建工具，是基于Groovy语言的构建工具，既保持了Maven的优点，又通过使用Groovy定义的DSL克服了Maven中使用XML繁冗以及不灵活等缺点，支持依赖管理和多项目，而且它有非常完善的说明文档。目前，SpringSource、Hibernate等都采用Gradle来构建。
Jenkins Jenkins，之前叫做Hudson，是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时Jenkins能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins通过Gerrit触发器插件可在新的Gerrit补丁集创建时开始使用Gerrit代码库中的代码进行构建项目，通过Gradle插件调用Gradle构建脚本，以帮助变更验证。
参考 Git权威指南-第5篇-第32章 Gerrit 代码审核服务器
Git+Gerrit+Gradle+Jenkins持续集成设置</description>
    </item>
    
    <item>
      <title>Jenkins超时设置</title>
      <link>https://mryqu.github.io/post/jenkins%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Tue, 21 Apr 2015 05:15:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/jenkins%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</guid>
      <description>Jenkins在构建部署镜像时发生超时：
Build timed out (after 10 minutes). Marking the build as aborted. Build was aborted Finished: ABORTED  解决方法是在Jenkins当前项目下点击Configure菜单后，在BuildEnvironment配置项里修改超时策略。我把超时绝对值改大点就好了。 </description>
    </item>
    
    <item>
      <title>使用Vagrant Box</title>
      <link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8vagrant_box/</link>
      <pubDate>Mon, 20 Apr 2015 06:07:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8vagrant_box/</guid>
      <description>//Download a box to local disk $ vagrant box add my-box /path/to/the/new.box ... $ vagrant init my-box ... $ vagrant up ...  </description>
    </item>
    
    <item>
      <title>[Gradle] 输出依赖包</title>
      <link>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</link>
      <pubDate>Thu, 16 Apr 2015 06:13:52 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</guid>
      <description>下面我以https://spring.io/guides/gs/spring-boot/中的gs-spring-boot项目为例，使用Gradle输出依赖包。
首先对build.gradle做如下修改：
buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;quot;org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE&amp;quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;spring-boot&#39; jar { baseName = &#39;gs-spring-boot&#39; version = &#39;0.1.0&#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 task copyToLib(type: Copy) { print configurations into &amp;quot;$buildDir/dep-libs&amp;quot; from configurations.runtime } build.dependsOn(copyToLib) dependencies { compile(&amp;quot;org.springframework.boot:spring-boot-starter-web&amp;quot;) // tag::actuator[] compile(&amp;quot;org.springframework.boot:spring-boot-starter-actuator&amp;quot;) // end::actuator[] // tag::tests[] testCompile(&amp;quot;org.springframework.boot:spring-boot-starter-test&amp;quot;) // end::tests[] }  首先可以在命令行中看到：  [configuration &amp;lsquo;:archives&amp;rsquo;, configuration &amp;lsquo;:compile&amp;rsquo;, configuration &amp;lsquo;:default&amp;rsquo;, configuration &amp;lsquo;:runtime&amp;rsquo;, configuration &amp;lsquo;:testCompile&amp;rsquo;, configur:clean&amp;rsquo;:testRuntime&amp;rsquo;, configuration &amp;lsquo;:versionManagement&amp;rsquo;]</description>
    </item>
    
    <item>
      <title>[Gradle] 执行Java类</title>
      <link>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</link>
      <pubDate>Wed, 15 Apr 2015 18:32:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</guid>
      <description>需求 我想用Gradle脚本执行下列Java类Hello123.java：
import java.util.Arrays; public class Hello123 { public static void main(String[] args) { System.out.println(&amp;quot;args:&amp;quot;+ Arrays.toString(args)); } }  测试一：创建execute任务 build.gralde apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; task execute(type: { main = System.getProperty(&amp;quot;exec.mainClass&amp;quot;) classpath = sourceSets.main.runtimeClasspath systemProperties System.getProperties() if(System.getProperty(&amp;quot;exec.args&amp;quot;)) args System.getProperty(&amp;quot;exec.args&amp;quot;).split() } sourceCompatibility = 1.8 targetCompatibility = 1.8  测试结果 测试二：重写run任务 build.gralde apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; apply plugin: &amp;quot;application&amp;quot; mainClassName = &amp;quot;NonExistentClass&amp;quot; task run (type: { main = System.</description>
    </item>
    
    <item>
      <title>[Gradle] 阻止build任务执行测试任务</title>
      <link>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Tue, 14 Apr 2015 05:53:30 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</guid>
      <description>在执行gradle build时想要阻止执行测试任务，方法如下：
 第一种方法：如Gradle用户指南的14.8 Skipping tasks所说，在build.gradle里设置&amp;rdquo;test.enabled=false&amp;rdquo;，执行gradle build 第二种方法：在build.gradle里设置&amp;rdquo;check.dependsOn.remove(test)&amp;ldquo;，执行gradle build 第三种方法：执行gradle build -x test  </description>
    </item>
    
    <item>
      <title>[Gradle] 强制重新下载依赖</title>
      <link>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Mon, 13 Apr 2015 05:49:35 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</guid>
      <description>强制Gradle重新下载依赖的方式有两种： - 在Gradle命令中加入&amp;ndash;refresh-dependencies选项。该选项会让Gradle忽略已解析模块和构件的所有缓存项，对所配置的仓库重新进行解析，动态计算版本、更新模块和下载构件。 - 删除Gralde的缓存目录~/.gradle/caches。这个有点过于粗暴。
示例：
gradlew clean --refresh-dependencies build bootRun  </description>
    </item>
    
    <item>
      <title>学习Gradle</title>
      <link>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</link>
      <pubDate>Sun, 12 Apr 2015 00:08:35 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</guid>
      <description>当前参与的SAS Workflow2.0原型开发项目，美国那边的项目组经营将代码编译脚本从Ant切换成Gradle了。此外我司已经在去年就将Gradle列入了技术雷达的正式采用象限，感觉有必要学习一下Gradle，扩充自己的开发能力。 Gradle官网上提供的图书信息链接中有两本免费O&amp;rsquo;Reilly出版社图书： - Building and Testing With Gradle - Gradle Beyond the Basics一般软件官网文档质量不错的情况下，我优先阅读最新的官网文档，所以我先看了《Gradle入门》和《Gradle用户指南》。
参考 Gradle官网
Gradle文档
Spring提供的Gradle入门
Gradle用户指南
Groovy官网
Groovy++
Java Build Tools: Ant vs Maven vs Gradle</description>
    </item>
    
    <item>
      <title>[Gradle] 设置项目属性的三种方式</title>
      <link>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 07 Apr 2015 05:36:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description> 命令行 gradle bootRun -PyquPropKey=yquPropValue  build.properties yquPropKey=yquPropValue  gradle.properties 添加ext块：
ext { yquPropKey=yquPropValue }  </description>
    </item>
    
    <item>
      <title>在Ubuntu中禁掉IPv6</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E7%A6%81%E6%8E%89ipv6/</link>
      <pubDate>Fri, 20 Mar 2015 08:38:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%AD%E7%A6%81%E6%8E%89ipv6/</guid>
      <description>为了禁止掉IPv6，需要在/etc/sysctl.conf做如下修改：
net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1  如果IPv6仍没有禁掉，是由于sysctl.conf没有激活造成的。为了解决上述问题，执行下面的命令：
sudo sysctl -p  之后，运行:
$ cat /proc/sys/net/ipv6/conf/all/disable_ipv6  它将返回1，这表示IPv6被成功禁止掉。 </description>
    </item>
    
    <item>
      <title>[Git] Create patch with untracked files</title>
      <link>https://mryqu.github.io/post/git_create_patch_with_untracked_files/</link>
      <pubDate>Tue, 27 Jan 2015 20:10:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_create_patch_with_untracked_files/</guid>
      <description>前一博文Create patch with untracked files using Git format-patch/diff/stash中的方案比较绕，今天有了一个更好一点的法子:
git add . git diff --cached &amp;gt; yqu.patch git reset origin/master  </description>
    </item>
    
    <item>
      <title>[Git] Create patch with untracked files using Git format-patch/diff/stash</title>
      <link>https://mryqu.github.io/post/git_create_patch_with_untracked_files_using_git_format-patch_diff_stash/</link>
      <pubDate>Mon, 26 Jan 2015 20:03:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_create_patch_with_untracked_files_using_git_format-patch_diff_stash/</guid>
      <description>Setup testing environment I created 123.txt at branch master, then modified 123.txt and added321.txt at branch yqu
C:\test&amp;gt;mkdir GitTest C:\test&amp;gt;cd GitTest C:\test\GitTest&amp;gt;git init Initialized empty Git repository in C:/test/GitTest/.git/ C:\test\GitTest&amp;gt;echo &amp;quot;this is a file at mast branch&amp;quot; &amp;gt; 123.txt C:\test\GitTest&amp;gt;git add 123.txt C:\test\GitTest&amp;gt;git commit -m &amp;quot;initial commit&amp;quot; [master (root-commit) f140825] initial commit 1 file changed, 1 insertion(+) create mode 100644 123.txt C:\test\GitTest&amp;gt;git push origin HEAD:master C:\test\GitTest&amp;gt;git checkout -b yqu Switched to a new branch &#39;yqu&#39; C:\test\GitTest&amp;gt;echo &amp;quot;bye&amp;quot; &amp;gt;&amp;gt; 123.</description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse的Back/Forward等同功能</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E7%9A%84back%E5%92%8Cforward%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 19 Dec 2014 05:55:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E7%9A%84back%E5%92%8Cforward%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</guid>
      <description>当查找一个方法的调用者后，可能还想退回到该方法进行研究，Eclipse的Back/Forward功能相应快捷键Alt + Left 和 Alt + Right是很便利的。
使用IntelliJ IDEA进行开发时，可以使用Navigate | Back和Navigate |Forward菜单或快捷键Ctrl + Alt + Left 和 Ctrl + Alt + Right实现相同的功能。 不过在我的机器中存在热键冲突，Intel显卡控制面板也使用相同的快捷键，禁掉Intel显卡控制面板的快捷键就好了。 </description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse Open Type Hierarchy等同功能</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_open_type_hierarchy%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 18 Dec 2014 06:08:03 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_open_type_hierarchy%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</guid>
      <description>使用Eclipse进行开发时，我喜欢用F4快捷键打开类型层次视图查看类层次关系，或者用Ctrl + T快捷键打开快速类型层次对话框查看类层次关系。 使用IntelliJ IDEA进行开发时，可以使用Navigate | Type Hierarchy菜单或Ctrl + H快捷键打开类层次视图，此外使能了“UMLSupport”插件后还可以使用Ctrl + Alt + U快捷键打开类型层次关系UML图。</description>
    </item>
    
    <item>
      <title>[IntelliJ] 导入项目</title>
      <link>https://mryqu.github.io/post/intellij_%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 17 Dec 2014 06:15:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE/</guid>
      <description>如果在IntelliJ IDEA没有打开任何项目的话，欢迎界面里有Import Project和Check out fromVersion Control两个菜单。
有一段时间为了导入新项目，我都老老实实关闭所有已打开的项目，去欢迎界面里操作。终于有一天觉得自己太老土，才搜了搜，发现原来这两个功能当有项目打开的时候是二级菜单而已。
 File | New | Project from Existing Sources File | New | Project from Version Control   </description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse Organize Imports等同功能</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_organize_imports%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Tue, 16 Dec 2014 05:30:48 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_organize_imports%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</guid>
      <description>使用Eclipse进行开发时，我喜欢用Ctrl+ Shift + O快捷键管理Java类的导入，它可以导入所需的Java类，去除不需要的Java类。 Eclipse的Organize Imports偏好配置： 使用IntelliJ IDEA进行开发时，可以使用Code | OptimizeImports菜单或 Ctrl + Alt + O快捷键优化Java类的导入。它仅能去除不需要的Java类，无法像Eclipse那样自动导入所需的Java类。 IntelliJ IDEA的Optimize Imports偏好配置： </description>
    </item>
    
    <item>
      <title>[IntelliJ] 处理Unhandled Exception</title>
      <link>https://mryqu.github.io/post/intellij_%E5%A4%84%E7%90%86unhandled_exception/</link>
      <pubDate>Mon, 15 Dec 2014 05:23:32 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E5%A4%84%E7%90%86unhandled_exception/</guid>
      <description>当在IntelliJ IDEA出现&amp;rdquo;Unhandled Exception&amp;rdquo;时，处理方法很简单。在有问题的代码行按下快捷键Ctrl+ ANTER即会出现下列处理选项： - Add exception to method signature - Surround with try/catch</description>
    </item>
    
    <item>
      <title>[IntelljJ] 文件修改提示和自动保存功能</title>
      <link>https://mryqu.github.io/post/intelljj_%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%8F%90%E7%A4%BA%E5%92%8C%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 14 Dec 2014 15:22:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intelljj_%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%8F%90%E7%A4%BA%E5%92%8C%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E5%8A%9F%E8%83%BD/</guid>
      <description>Eclipse中文件修改后没有保存前文件都会有星号提示，IntelljJ IDEA默认没有提示，但是可以通过如下设置完成：Settings -&amp;gt; Editor -&amp;gt; General -&amp;gt; Editor Tabs: Check &amp;ldquo;Markmodified tabs with asterisk&amp;rdquo;IntelljJ IDEA关于文件自动保存功能主要有两种方式： - 切换到其他应用时保存变化（默认使能）设置路径：Settings -&amp;gt; Apperance &amp;amp; Behavior -&amp;gt; Save files onframe deactivation - 如果应用空闲则自动保存变化（默认禁止）设置路径：Settings -&amp;gt; Apperance &amp;amp; Behavior -&amp;gt; Save filesautomatically if application is idle for &amp;hellip; sec.</description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse工作集近似的功能</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E5%B7%A5%E4%BD%9C%E9%9B%86%E8%BF%91%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 13 Dec 2014 12:02:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E5%B7%A5%E4%BD%9C%E9%9B%86%E8%BF%91%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD/</guid>
      <description>Eclipse鼓励将不同的功能模块划分为独立的项目存在，这样不但结构清晰，组织起来还非常灵活，因为我们可以用feature对这些项目进行不同的组合，输出后得到具有不同功能的产品。 不过这样一来项目浏览器里的项目会以更快的速度增加，当你面对几十上百个项目时，工作效率必然大打折扣。幸好Eclipse提供了工作集（WorkingSet）的功能，它可以用来对项目进行分组，并且可以项目浏览器里指定显示所有项目或者特定工作集下的项目。 具体操作可以参考Eclipse帮助文档工作集概念和项目浏览器显示/隐藏文件。
IntelliJ IDEA与Eclipse术语对比如下：
|Eclipse|IntelliJ IDEA |&amp;mdash;&amp;ndash; |A number of projects, a workspace|Project |Project|Module |Project-specific JRE|Module SDK |User library|Global library |Classpath variable|Path variable |Project dependency|Module dependency |Library|Module library
由此可知在IntelliJ IDEA中近似功能应该在module一层，就我查找的资料来看最近似的功能就是模块组（modulegroup）了。 具体操作可以参考IntelliJ IDEA帮助文档对模块分组。Eclipse可选择对某个工作集下的所有项目进行集中编译；同样IntelliJ IDEA也可选择对模块组下的所有模块集中编译。Eclipse可以显示工作空间下所有项目，或仅显示某个工作集下的项目以隐藏其他项目；IntelliJIDEA只能对模块组进行折叠来隐藏其下的模块。这一点两者的行为有一定差异。</description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse Quick Outline等同功能</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_quick_outline%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 12 Dec 2014 20:34:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_quick_outline%E7%AD%89%E5%90%8C%E5%8A%9F%E8%83%BD/</guid>
      <description>使用Eclipse进行开发时，我喜欢用Ctrl+ O快捷键打开快速概要对话框查找或浏览当前类变量和方法。
使用IntelliJ IDEA进行开发时，可以使用Navigate | FileStructure菜单或Ctrl + F12快捷键打开文件结构视图查找或浏览当前类的变量或方法。 此外如果在整个项目内查找变量或方法，可以使用Navigate | Symbol菜单或 Ctrl + Alt + Shift + N快捷键打开符号查找对话框进行查找。</description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse关于Call Hierarchy和Find Reference功能比较</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E5%85%B3%E4%BA%8Ecall_hierarchy%E5%92%8Cfind_reference%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83/</link>
      <pubDate>Thu, 11 Dec 2014 19:46:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse%E5%85%B3%E4%BA%8Ecall_hierarchy%E5%92%8Cfind_reference%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83/</guid>
      <description>&amp;ldquo;Call Hierarchy&amp;rdquo;功能比较 Eclipse的&amp;rdquo;CallHierarchy&amp;rdquo;可以查看一个Java方法或类成员变量的调用树（caller和callee两个方向）。 IntelliJ IDEA中可以在主菜单中选择Navigate | CallHierarchy命令查看一个Java方法调用树（caller和callee两个方向），但是不像Eclipse那样可以查看类成员变量的调用树。 IntelliJ IDEA中可以在主菜单中选择Analyze | Dataflow from/toHere两个命令查看表达式、变量和方法参数的传递关系树。 Eclipse的&amp;rdquo;Call Hierarchy&amp;rdquo;命令的功能，在IntelliJIDEA中被划分到了三个命令，增加了一点点记忆成本，不过IntelliJ IDEA中的处理范围更广，相对功能更强一些。
&amp;ldquo;Find Reference&amp;rdquo;功能比较 Eclipse的&amp;rdquo;Find Reference&amp;rdquo;可以查看一个Java类、方法或变量的直接使用情况。 IntelliJ IDEA的&amp;rdquo;Find Usage&amp;rdquo;具有相同的功能。在我的体验中，IntelliJIDEA中的功能更强一些，可以分析Sping配置文件中对Java类或方法的使用情况。
参考 https://www.jetbrains.com/idea/help/building-call-hierarchy.html
https://www.jetbrains.com/idea/help/analyzing-data-flow.html</description>
    </item>
    
    <item>
      <title>[IntelliJ] Javascript code inspection</title>
      <link>https://mryqu.github.io/post/intellij_javascript_code_inspection/</link>
      <pubDate>Wed, 10 Dec 2014 19:34:48 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_javascript_code_inspection/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[IntelliJ] 与Eclipse Link with Editor等价功能设置</title>
      <link>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_link_with_editor%E7%AD%89%E4%BB%B7%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 07 Dec 2014 13:35:19 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E4%B8%8Eeclipse_link_with_editor%E7%AD%89%E4%BB%B7%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE/</guid>
      <description>Link With Editor是Eclipse内置功能中十分小巧，但却异常实用的一个功能。这个开关按钮 (ToggleButton) 出现在各式导航器视图 ( 例如 Resource Explorer, Package Explorer 等 )的右上角。点击时能根据当前打开的文件，相应地展开导航器视图，并迅速关联到该结点。 IntelliJ IDEA中也有等价功能，即项目视图中&amp;rdquo;Autoscroll from source&amp;rdquo;设置。 </description>
    </item>
    
    <item>
      <title>WebStorm与IntelliJ IDEA的区别</title>
      <link>https://mryqu.github.io/post/webstorm%E4%B8%8Eintellij_idea%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 06 Dec 2014 16:35:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/webstorm%E4%B8%8Eintellij_idea%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>WebStorm与IntelliJ IDEA都被很多JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScriptIDE”等，用了一点IntelliJ IDEA，还真不知道两者有什么联系和区别。网上搜了一下，WebStorm FAQ和PhpStorm FAQ解答了我的疑问。JetBrains旗下的产品： - IntelliJ IDEA偏重于Java开发，旗舰产品，它可以通过（捆绑的或可下载的）插件的方式提供WebStorm和PhpStorm所有的功能。支持Scala和Groovy开发，也可以通过插件支持Ruby和Python语言。 - PhpStorm侧重于PHP开发 - WebStorm侧重于JS开发 - RubyMine侧重于Ruby和Rails开发 - PyCharm侧重于Python和Djanjo开发WebStorm与IntelliJ IDEA相比，功能少，集中于JS开发这一块，更加轻量级，新项目配置起来更简单。
下面两个链接是WebStorm和IntelliJ IDEA的官方报价，WebStorm的价格大概是IntelliJIDEA的五分之一。 - https://www.jetbrains.com/webstorm/buy/ - https://www.jetbrains.com/idea/buy/</description>
    </item>
    
    <item>
      <title>[IntelliJ] 添加Plugin更新URL并安装</title>
      <link>https://mryqu.github.io/post/intellij_%E6%B7%BB%E5%8A%A0plugin%E6%9B%B4%E6%96%B0url%E5%B9%B6%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 05 Dec 2014 18:50:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E6%B7%BB%E5%8A%A0plugin%E6%9B%B4%E6%96%B0url%E5%B9%B6%E5%AE%89%E8%A3%85/</guid>
      <description>1) 选择菜单 File -&amp;gt; Setting2) Setting对话框内选择plugins，点击Browse Repositories -&amp;gt; ManageRepositories -&amp;gt; Add Repository添加完所要安装的插件更新URL，然后就可以安装了。</description>
    </item>
    
    <item>
      <title>[IntelliJ] 格式化代码</title>
      <link>https://mryqu.github.io/post/intellij_%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 03 Dec 2014 19:52:39 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/intellij_%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>用了多年的Eclipse后，转而用IntelliJ IDEA，觉得很多简单的功能都不会了，感觉是一个囧呀。 刚碰到的就是不知道如何去格式化代码。
作为一个非快捷键达人的码农，在Eclipse中都是右键菜单，然后找Source-&amp;gt;Format。
但是在IntelliJ中，右键菜单里面真没这功能。后来还是找了一会，终于在菜单里发现了！</description>
    </item>
    
    <item>
      <title>我的IntelliJ IDEA配置</title>
      <link>https://mryqu.github.io/post/%E6%88%91%E7%9A%84intellij_idea%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 29 Nov 2014 20:19:20 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%88%91%E7%9A%84intellij_idea%E9%85%8D%E7%BD%AE/</guid>
      <description> 安装完IntelliJIDEA，我首先切换到64位模式： 安装文件生成的快捷方式默认指向的是idea.exe，更改为idea64.exe。 更改默认内存配置：修改IntelliJ&amp;rdquo;bin&amp;rdquo;目录下的idea64.exe.vmoptions文件。 &amp;ldquo;-Xms&amp;rdquo;和&amp;rdquo;-Xmx&amp;rdquo;定义了Java分配给IntelliJ的最小和最大堆空间，将其更改为&amp;rdquo;-Xms256m&amp;rdquo;和&amp;rdquo;-Xmx1600m&amp;rdquo; 启动IntelliJ IDEA，通过File-&amp;gt;Setting菜单做如下修改：  更改编译器的构建过程堆大小为1024 设置代理为总动检测   </description>
    </item>
    
    <item>
      <title>Eclipse用户IntelliJ IDEA入门指南</title>
      <link>https://mryqu.github.io/post/eclipse%E7%94%A8%E6%88%B7intellij_idea%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 29 Nov 2014 10:50:26 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse%E7%94%A8%E6%88%B7intellij_idea%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>除了IntelliJ IDEA帮助文档 （https://www.jetbrains.com/idea/help/intellij-idea.html），发现一个IntelliJIDEA不错的入门教程： Getting Started with IntelliJ IDEA as an Eclipse User（http://zeroturnaround.com/rebellabs/getting-started-with-intellij-idea-as-an-eclipse-user/） - Introduction: Why IntelliJ IDEA? - Chapter I: Getting your first IntelliJ IDEA project set up - Chapter II: Getting comfortable with IDEA’s Keymap, Navigation and Settings - Chapter III: Getting productive with Tests, Deployments and Artifacts - Chapter IV: Summary, Conclusion and Goodbye Comic ;-)
其他参考: IntelliJ Idea 常用快捷键列表</description>
    </item>
    
    <item>
      <title>将Ultraedit集成到Windows文件资源管理器</title>
      <link>https://mryqu.github.io/post/%E5%B0%86ultraedit%E9%9B%86%E6%88%90%E5%88%B0windows%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Wed, 10 Sep 2014 20:58:18 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%86ultraedit%E9%9B%86%E6%88%90%E5%88%B0windows%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>最近自己的公司电脑换新的了，IT同事给装好了Ultraedit，可是安装时没有在Windows文件资源管理器的菜单加入Ultraedit项，使用起来不便。在配置里设一下，搞定！ </description>
    </item>
    
    <item>
      <title>从TortoiseGit切换到Git Extensions</title>
      <link>https://mryqu.github.io/post/%E4%BB%8Etortoisegit%E5%88%87%E6%8D%A2%E5%88%B0git_extensions/</link>
      <pubDate>Sun, 07 Sep 2014 12:13:06 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BB%8Etortoisegit%E5%88%87%E6%8D%A2%E5%88%B0git_extensions/</guid>
      <description>一开始使用GitHub的服务，除了安装了msysGit&amp;rsquo;s Git for Windows，GUI客户端就是GitHub的Web界面。后来使用bitbucket的服务时，想要安装一个好使又通用的GUI客户端。由于使用TortoiseCVS和TortoiseSVN，自然就选择了TortoiseGit。由于三者界面风格一致，使用无障碍上手。最近开始使用公司的git仓库，公司指定的是Git Extensions。好吧，Bye， TortoiseGit。 好奇了一下，上网搜了两者的对比。貌似相当一部分人使用TortoiseGit的理由跟我一样，不过有一些人更推荐Git Extensions。此外还有一个商业产品SmartGit，但貌似使用的人更少。搜索结果：What is the Best Git GUI (Client) for Windows?TortoiseGit vs Git ExtensionsAsk HN: Best Git GUI For Windows?</description>
    </item>
    
    <item>
      <title>磁盘分区管理工具</title>
      <link>https://mryqu.github.io/post/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 21 Jul 2014 21:15:21 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>一直以来都用PQMagic硬盘分区大师8.0，忽然有一天意识到它在Win7上不好使了，然后就想升级，结果发现PQMagic这款软件早就over了。根据维基百科的说法，Symantec收购由PowerQuest公司推出的PQMagic于2009年12月8日退役。 搜了一下资料： - 目前比较好的商业分区工具是Acronis Disk Director - 目前比较好的免费分区工具是AOMEI Partition Assistant Standard - 简单情况下，可以Win7自带小工具调整分区大小</description>
    </item>
    
    <item>
      <title>QuickEdit mode of command prompt</title>
      <link>https://mryqu.github.io/post/quickedit_mode_of_command_prompt/</link>
      <pubDate>Sat, 17 May 2014 09:37:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/quickedit_mode_of_command_prompt/</guid>
      <description>从Windows命令行复制内容每次都需要点击Edit菜单中的Mark子菜单项，颇为不便。
原来这个行为可以通过属性对话框中的QuickEdit mode改变： </description>
    </item>
    
    <item>
      <title>[Gradle] 在build.gradle中添加本地包依赖</title>
      <link>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Wed, 16 Apr 2014 22:17:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</guid>
      <description>一直在Gradle中用的依赖包都是来自仓库，头一次添加本地包依赖。
buildscript { repositories { mavenCentral() } } apply plugin: &#39;java&#39; apply plugin: &#39;eclipse&#39; apply plugin: &#39;idea&#39; jar { baseName = &#39;HelloAlgs&#39; version = &#39;0.1.0&#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { runtime files(&#39;libs/algs4.jar&#39;) } task wrapper(type: Wrapper) { gradleVersion = &#39;2.3&#39; }  </description>
    </item>
    
    <item>
      <title>谷歌拼音输入法-笔划/组件输入</title>
      <link>https://mryqu.github.io/post/%E8%B0%B7%E6%AD%8C%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95-%E7%AC%94%E5%88%92%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5/</link>
      <pubDate>Thu, 10 Apr 2014 22:14:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%B0%B7%E6%AD%8C%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95-%E7%AC%94%E5%88%92%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5/</guid>
      <description>有些工具用法总不使就记不住了，到处搜还不如搜自己的博客。 对于某些生僻字，您有可能并不清楚它的拼音。这时，您可以尝试使用谷歌拼音提供的笔划/组件输入功能。例如：先按&amp;rdquo;u&amp;rdquo;进入笔划输入模式，然后用使用代码h(横),s(竖),p(撇),n(捺),z(折),d(点)依次输入该字的各个笔划。其中，n和d是相同的。例如，您希望输入&amp;rdquo;谷&amp;rdquo;，则可以依次按下&amp;rdquo;upnpnszh&amp;rdquo;。 除了笔划以外，你也可以用拼音直接输入组成该汉字的可读部件，例如，输入&amp;rdquo;ucaowei&amp;rdquo;可以输入&amp;rdquo;莅&amp;rdquo;，输入&amp;rdquo;ujinxing&amp;rdquo;可以输入&amp;rdquo;鍟&amp;rdquo;。输入部件时，直接使用该部件的读音，或近似汉字的读音即可，例如，提手旁可以用&amp;rdquo;shou&amp;rdquo;来输入。</description>
    </item>
    
    <item>
      <title>Outlook2013中日历的天气设置</title>
      <link>https://mryqu.github.io/post/outlook2013%E4%B8%AD%E6%97%A5%E5%8E%86%E7%9A%84%E5%A4%A9%E6%B0%94%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Wed, 09 Apr 2014 23:04:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/outlook2013%E4%B8%AD%E6%97%A5%E5%8E%86%E7%9A%84%E5%A4%A9%E6%B0%94%E8%AE%BE%E7%BD%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GitHub fork操作</title>
      <link>https://mryqu.github.io/post/github_fork%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 17 Mar 2014 22:37:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/github_fork%E6%93%8D%E4%BD%9C/</guid>
      <description>Fork（分支）操作不是Git实现的一部分，仅是GitHub独有的一个在服务器端克隆代码库的操作。假定我作为GitHub用户usr2，对用户usr1的github.com/usr1/demo代码库有兴趣。我可以通过clone命令将该代码库克隆到本机，并且可以通过pull命令获得该代码库的更新。但是除非用户usr1将我（用户usr2）设为该代码库的贡献者，否则我无法将我提交的修改通过push命令推送到该代码库。但是通过fork操作，我就可以将github.com/usr1/demo代码库完整复制到我的GitHub帐号下（包括代码库中的文件、提交历史、问题等等），例如下图的github.com/usr2/demo。我可通过clone命令将自己的github.com/usr2/demo代码库克隆到本机，我完全有权限将本机提交的修改通过push命令推送到上述自己的代码库。如果我希望我的修改被usr1采纳，我可以发送一个pullrequest通知usr1。至于usr1是否接收我的修改，决定权在usr1。克隆代码库的时候，所使用的远程代码库地址自动被Git命名为origin。其效果类似于：
git remote add origin git://github.com/usr2/demo.git  github.com/usr2/demo代码库在fork操作之后就不再获得github.com/usr1/demo的后继更新了。可以手工添加github.com/usr1/demo为上游代码库地址：
git remote add upstream git://github.com/usr1/demo.git  我可通过fetch命令获取上游代码库的更新，在本机合并后，通过push命令推送到自己的远程代码库。
参考 GitHub help: Fork A Repo
GitHub help: Syncing a fork
GitHub help: Adding collaborators to a personal repository
Simple guide to forks in GitHub and Git
stackOverflow: Git fork is git clone?
stackOverflow: What is the difference between origin and upstream in github</description>
    </item>
    
    <item>
      <title>手工修改Chrome配置文件</title>
      <link>https://mryqu.github.io/post/%E6%89%8B%E5%B7%A5%E4%BF%AE%E6%94%B9chrome%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 02 Mar 2014 19:57:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%89%8B%E5%B7%A5%E4%BF%AE%E6%94%B9chrome%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>当初装Chrome，g.cn上死活下载不了，随便装了一个澳洲版的。结果访问taobao、weibo被认成了澳洲用户，都被推到了海外入口。 一开始折腾Chrome的配置菜单，没找到。后来直接修改C:\Users\AppData\Local\Google\Chrome\UserData\Default\Preferences搞定了。 原始值：
 &amp;quot;last_known_google_url&amp;quot;: &amp;quot;https://www.google.com.au/&amp;quot;, &amp;quot;last_prompted_google_url&amp;quot;: &amp;quot;https://www.google.com.au/&amp;quot;,  修改后：
 &amp;quot;last_known_google_url&amp;quot;: &amp;quot;https://www.google.com.hk/&amp;quot;, &amp;quot;last_prompted_google_url&amp;quot;: &amp;quot;https://www.google.com.hk/&amp;quot;,  </description>
    </item>
    
    <item>
      <title>[Git] 裸代码仓库和镜像代码仓库</title>
      <link>https://mryqu.github.io/post/git_%E8%A3%B8%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E5%92%8C%E9%95%9C%E5%83%8F%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</link>
      <pubDate>Sat, 15 Feb 2014 00:38:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E8%A3%B8%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E5%92%8C%E9%95%9C%E5%83%8F%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</guid>
      <description>注：本文中操作都没有设置$GIT_DIR环境变量。
Git init和clone命令对bare和mirror参数的支持 ||&amp;ndash;bare参数|&amp;ndash;mirror参数 |&amp;mdash;&amp;ndash; |git init命令|支持|/ |git clone命令|支持|支持
裸代码仓库与普通代码仓库的区别 普通代码仓库裸代码仓库git init命令git init命令会创建一个空的Git代码仓库，一个在当前目录下包含hooks、info、objects和refs子目录和config、description和HEAD文件的.git目录。当前目录下可以创建工作树（工作文件和目录）。
config文件内容如下：
 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnlygit init --bare命令会创建一个空的裸Git代码仓库，当前目录下直接创建hooks、info、objects和refs子目录和config、description和HEAD文件。裸Git代码仓库只包含版本控制信息而不包含工作树。
config文件内容如下：
 [core] repositoryformatversion = 0 filemode = false bare = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly git clone命令git clone命令会创建的一个包含.git子目录的目录，其中.git目录包含branches、hooks、info、logs、objects和refs子目录和config、description、HEAD、index和packed-refs文件。git clone命令所创建的目录中包含克隆的工作树（工作文件和目录）。
config文件内容如下：
 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly [remote &#34;</description>
    </item>
    
    <item>
      <title>VirtualBox镜像资源</title>
      <link>https://mryqu.github.io/post/virtualbox%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90/</link>
      <pubDate>Wed, 05 Feb 2014 09:25:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/virtualbox%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90/</guid>
      <description>VirtualBox镜像资源: http://virtualboxes.org/images/</description>
    </item>
    
    <item>
      <title>MinGW安装和使用</title>
      <link>https://mryqu.github.io/post/mingw%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 04 Feb 2014 18:17:07 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/mingw%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>MinGW简介 MinGW全称Minimalist GNU For Windows，，是将GCC编译器和GNUBinutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。MinGW是从Cygwin1.3基础上发展而来，相比Cygwin而言体积更小、使用更方便。MinGW分两个分支，MinGW（即MinGW32）和MinGW-w64。 MinGW包括： - GNU编译器套件，包括C/C++、ADA语言和Fortran语言编译器 - 用于生成Windows二进制文件的GNU工具（编译器、链接器和档案管理器） - 用于Windows平台安装和部署MinGW和MSYS的命令行安装器（mingw-get） - 用于命令行安装器的GUI打包器（mingw-get-inst）
MinGW安装和使用 我只想使用C/C++，所以仅安装mingw32-base、mingw32-gcc-g++。msys-base其实也是可以不用安装的，因为我可以使用已有的GitBash。 我选择了默认的安装路径c:\MinGW，可以将c:\MinGW\bin加入环境变量以便使用。 参考 MinGW 官方网站
SourceForge.net：MinGW - Minimalist GNU for Windows
SourceForge.net：MinGW-w64 - for 32 and 64 bit Windows</description>
    </item>
    
    <item>
      <title>免费私有代码托管平台</title>
      <link>https://mryqu.github.io/post/%E5%85%8D%E8%B4%B9%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Sat, 01 Feb 2014 17:35:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%85%8D%E8%B4%B9%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/</guid>
      <description>SourceForge、GitHub免费版、Gitorious免费版和GoogleCode等源代码仓库都要求项目必须开源。这里做一下免费私有代码托管平台资料汇总。 - GitLab:支持Git库。首页说可以创建无限个私有或公开的库。使用时提示可以创建100000个级别为私有、GitLab内访问或公开的项目。 - Atlassian公司的Bitbucket:支持Git库。公有和私有仓库都可以无限制创建，支持在线协作。免费版限制为5个用户。 - Assembla:支持SVN/Git/Perforce库，支持在线协作。免费版限制为2个用户，一个私有库和500M存储。 - beanstalk：支持SVN/Git库，支持在线协作。免费版限制为1个用户，一个私有库和100M存储。 - unfuddle：有帖子说有免费帐户，但是没有找到。 - 开源中国的Git@OSC：支持Git库。最多可以创建 1000个项目，不限私有或者公开。 - CSDN的CODE：支持Git库，支持在线协作。支持私有库和公开库。 - 京东的京东代码库：支持Git库。支持私有库和公开库。
参考 免费的Git私有代码托管服务
如何在“Google Code 代码托管”上建立私有代码版本库
Tortoisegit+BitBucket创造私有代码托管仓库</description>
    </item>
    
    <item>
      <title>[Chrome插件] 一键保存当前打开的所有标签页</title>
      <link>https://mryqu.github.io/post/chrome%E6%8F%92%E4%BB%B6_%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E6%89%93%E5%BC%80%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%87%E7%AD%BE%E9%A1%B5/</link>
      <pubDate>Wed, 22 Jan 2014 21:08:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/chrome%E6%8F%92%E4%BB%B6_%E4%B8%80%E9%94%AE%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E6%89%93%E5%BC%80%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%87%E7%AD%BE%E9%A1%B5/</guid>
      <description>经常是用Chrome打开一堆网页，但是由于某种原因必须重启机器，不想将这些页面存入书签，但是又想保存下来开机后继续浏览。
在网上搜了一下，下列Chrome插件可以满足这个需求： - OneTab - Session Buddy - PanicButton - Stash - Read Later - VIEW LATER - Save For Later
其中OneTab和Session Buddy都是五星插件，并且用户众多，最终我选择了OneTab。</description>
    </item>
    
    <item>
      <title>安装和卸载JRE或JDK时出现Error 1723的解决办法</title>
      <link>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BDjre%E6%88%96jdk%E6%97%B6%E5%87%BA%E7%8E%B0error_1723%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Wed, 15 Jan 2014 20:54:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BDjre%E6%88%96jdk%E6%97%B6%E5%87%BA%E7%8E%B0error_1723%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>卸载JDK和JRE时失败，报错“Error 1723:java dll missing”。 网上的很多攻略都不管用，最后还是从微软网站找到fix程序。 Fix problems that programs cannot be installed or uninstalled</description>
    </item>
    
    <item>
      <title>ClusterShell实践</title>
      <link>https://mryqu.github.io/post/clustershell%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 07 Jan 2014 20:47:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/clustershell%E5%AE%9E%E8%B7%B5/</guid>
      <description>ClusterShell介绍 ClusterShell提供了一个轻量级、统一和健壮的命令执行Python框架，非常适于减轻Linux集群日常管理任务负担。ClusterShell的好处如下： - 提供高效、并行和高可扩展的Python命令执行引擎。 - 提供统一节点组语法和对外部组的访问 - 当使用clush和nodeset等工具可有效提升集群创建和日常管理任务的效率
ClusterShell实践 安装 首先在集群内节点配置无密钥ssh访问。然后在主/工作节点上安装ClusterShell。
apt-get install clustershell  配置和实践 ClusterShell工具 ClusterShell包含如下工具： - clush帮助文档 - clubak帮助文档 - nodesetcluset帮助文档
ClusterShell在线文档为http://clustershell.readthedocs.io/。</description>
    </item>
    
    <item>
      <title>*nux中的Here documents和Here strings</title>
      <link>https://mryqu.github.io/post/linux%E4%B8%AD%E7%9A%84here_documents%E5%92%8Chere_strings/</link>
      <pubDate>Wed, 01 Jan 2014 21:09:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux%E4%B8%AD%E7%9A%84here_documents%E5%92%8Chere_strings/</guid>
      <description>介绍 here document(又称之为here-document、here-text、heredoc、hereis、here-string或here-script)，是shell中的一种特殊重定向方式，用来将输入重定向到一个交互式的shell脚本或程序。格式如下：
command &amp;lt;&amp;lt; [-]delimiter here-document delimiter  here documents始于Unixshell的最通用语法，在&amp;lt;&amp;lt;紧跟一个分割标识符（通常为EOF或END），跟随一堆多行字符，最后一行用分割标识符收尾。
注意： - 结尾的分割标识符一定要顶格写，前后不能有任何字符，包括空格和tab缩进。 - 开始的分割标识符前后的空格会被省略掉。 - 开始的分割标识符前如果使用-的话，内容部分每行前面的 tab (制表符)将会被删除掉。这种用法是为了编写HereDocument的时候可以将内容部分进行缩进，方便代码阅读。
here strings语法跟here documents类似。格式如下：
command &amp;lt;&amp;lt;&amp;lt; word  实践及测试 Here documents简单测试 Here documents中变量替换和执行命令测试 通常，Heredocuments中内容会进行变量替换，反勾号中的命令也会执行。可以通过在开始的分割标识符上加单引号禁掉这种行为。 Here string简单测试 在shell文件中使用Here documents 参考 Here document
Bash Reference Manual - Here Documents
Bash Reference Manual - Here Strings
Java 的多行字符串 Here Document 的实现
[](http://stackoverflow.com/questions/2500436/how-does-cat-eof-work-in-bash)</description>
    </item>
    
    <item>
      <title>在Ubuntu Linux上安装netstat</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu_linux%E4%B8%8A%E5%AE%89%E8%A3%85netstat/</link>
      <pubDate>Wed, 01 Jan 2014 13:52:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu_linux%E4%B8%8A%E5%AE%89%E8%A3%85netstat/</guid>
      <description>在UbuntuLinux上安装netstat，apt-get其实是找不到netstat包的，需要用apt-get安装net-tools。net-tools是Linux平台NET-3网络分发包，包括arp、hostname、ifconfig、netstat、rarp、route、plipconfig、slattach、mii-tool、iptunnel和ipmaddr工具。
apt-get install net-tools  </description>
    </item>
    
    <item>
      <title>Windows常用命令汇总</title>
      <link>https://mryqu.github.io/post/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sun, 22 Dec 2013 13:12:02 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
      <description>windows命令现在也就sysdm.cpl和mstsc用的比较多，很多还真不熟悉，搜了一篇备查。
 appwiz.cpl：程序和功能  calc：启动计算器  certmgr.msc：证书管理实用程序  charmap：启动字符映射表  chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）  cleanmgr: 打开磁盘清理工具  cliconfg：SQL SERVER 客户端网络实用工具  cmstp：连接管理器配置文件安装程序  cmd.exe：CMD命令提示符  自动关机命令 Shutdown -s -t600：表示600秒后自动关机 shutdown -a：可取消定时关机 Shutdown -r -t600：表示600秒后自动重启 rundll32user32.dll,LockWorkStation：表示锁定计算机  colorcpl：颜色管理，配置显示器和打印机等中的色彩  CompMgmtLauncher：计算机管理  compmgmt.msc：计算机管理  credwiz：备份或还原储存的用户名和密码  comexp.msc：打开系统组件服务  control：控制面版  dcomcnfg：打开系统组件服务  Dccw：显示颜色校准  devmgmt.msc：设备管理器  desk.cpl：屏幕分辨率  dfrgui：优化驱动器 Windows7→dfrg.msc：磁盘碎片整理程序  dialer：电话拨号程序  diskmgmt.msc：磁盘管理  dvdplay：DVD播放器  dxdiag：检查DirectX信息  eudcedit：造字程序  eventvwr：事件查看器  explorer：打开资源管理器  Firewall.</description>
    </item>
    
    <item>
      <title>Chrome浏览器离线安装包下载地址</title>
      <link>https://mryqu.github.io/post/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Thu, 12 Dec 2013 20:57:46 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</guid>
      <description>http://www.google.com/chrome/eula.html?standalone=1&amp;amp;hl=zh-CN</description>
    </item>
    
    <item>
      <title>[Git] Git代理配置</title>
      <link>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 01 Dec 2013 22:00:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid>
      <description> 设置Git的http和https代理 git config --global http.proxy http://proxyUser:proxyPwd@proxyServer:proxyPort git config --global https.proxy https://proxyUser:proxyPwd@proxyServer:proxyPort  查询Git的http和https代理 git config --global --get http.proxy git config --global --get https.proxy  移除Git的http和https代理 git config --global --unset http.proxy git config --global --unset https.proxy  </description>
    </item>
    
    <item>
      <title>Wget笔记</title>
      <link>https://mryqu.github.io/post/wget%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 01 Dec 2013 08:35:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/wget%E7%AC%94%E8%AE%B0/</guid>
      <description>介绍 GNU Wget是一个命令行的下载工具，支持HTTP、HTTPS、FTP协议，支持断点续传。在宽带状态不佳的情况下，Wget能表现出很强的稳定性。
常用命令速查表 |操作|命令 |&amp;mdash;&amp;ndash; |下载文件|wget URL |恢复下载|wget -c URL |递归下载|以最大深度10级递归下载某链接：wget -r -l 10 URL |下载整个网站|wget -m URL-m等同于-r -N -l inf &amp;ndash;no-remove-listing |下载某个页面特定类型文件|仅下载pdf和mp3文件：wget -A &amp;ldquo;.pdf,.mp3&amp;rdquo; -r -l 1 -nd –np URL |下载某个页面特定类型之外的其他文件|下载pdf以外的文件：wget -R.pdf -r -l 1 -nd –np URL |忽略 robots.txt|wget -e robots=off URL |限制下载速率|wget –-limit-rate=20 URL |模拟firefox下载|wget -U Mozilla URL |不下载仅检查链接是否存在|wget &amp;ndash;spider &amp;ndash;force-html -i bookmarks.html |将输出写入文件|wget -O filepath URL |下载FTP文件|wget &amp;ndash;ftp-­use­r=yqu&amp;ndash;ftp-­pas­swo­rd=yqu URL |下载多个连接|wget URL1 URL2 URL3 |配置接收数据的限额大小|对单文件下载无效，对递归下载或从输入文件获取连接下载有效wget -Q2m -i URL当下载量超过限额后下载中断</description>
    </item>
    
    <item>
      <title>以管理员权限执行命令行</title>
      <link>https://mryqu.github.io/post/%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C/</link>
      <pubDate>Tue, 19 Nov 2013 13:20:02 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid>
      <description>以管理员权限执行命令行，只需点击出Command Prompt的右键菜单，选择&amp;rdquo;Run asadministrator&amp;rdquo;即可。 </description>
    </item>
    
    <item>
      <title>[Git] 查看某文件历史记录</title>
      <link>https://mryqu.github.io/post/git_%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 09 Nov 2013 06:38:12 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>在Git中查看某个文件历史记录，方式如下： - git log [filename]：显示对该文件的提交记录 - git log -p [filename]：显示对该文件的提交记录及每次提交增量内容 - gitk [filename]：图形显示对该文件的提交记录及每次提交增量内容</description>
    </item>
    
    <item>
      <title>[Eclipse] 确认Eclipse是32/64bit的方法</title>
      <link>https://mryqu.github.io/post/eclipse_%E7%A1%AE%E8%AE%A4eclipse%E6%98%AF32%E6%88%9664bit%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2013 22:19:41 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse_%E7%A1%AE%E8%AE%A4eclipse%E6%98%AF32%E6%88%9664bit%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>两种方法：
 打开Eclipse界面：Help -&amp;gt; About Eclipse -&amp;gt; Installation Details -&amp;gt; Configuration，若看到x86字样说明Eclipse是32bit的，若看到x86_64或x64字样则说明Eclipse是64bit的。 查看Eclipse安装目录下的eclipse.ini文件，如果launcher.library设置的值中写的是X86就说明Eclipse是32bit的，如果写的是x86_64或x64则说明Eclipse是64bit的。  </description>
    </item>
    
    <item>
      <title>nohup命令笔记</title>
      <link>https://mryqu.github.io/post/nohup%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 26 Oct 2013 11:24:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/nohup%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</guid>
      <description>Unix/Linux下一般比如想让某个程序在后台运行，很多都是使用 &amp;amp;在程序结尾来让程序自动运行。比如我们要运行mysql在后台：
/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;amp;  但是很多程序并不象mysqld一样做成守护进程，一般普通程序使用 &amp;amp;结尾在后台运行，如果终端关闭了，普通程序还是会被关闭。如果想要在退出帐户/关闭终端之后继续运行相应的普通进程。我们就可以使用nohup这个命令，nohup就是不挂起的意思(nohang up)。
nohup COMMAND [ARG]...  nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加&amp;amp;到命令的尾部。
如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。
nohup command &amp;gt; myout.file 2&amp;gt;&amp;amp;1  该命令返回下列出口值：
 126：可以查找但不能调用 Command 参数指定的命令。 127：nohup 命令发生错误或不能查找由 Command 参数指定的命令。 其他：Command 参数指定命令的退出状态。 使用jobs查看任务。使用fg %n关闭。  </description>
    </item>
    
    <item>
      <title>[Eclipse] Find the override method implementation in subclasses</title>
      <link>https://mryqu.github.io/post/eclipse_find_the_override_method_implementation_in_subclasses/</link>
      <pubDate>Sat, 26 Oct 2013 00:00:39 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse_find_the_override_method_implementation_in_subclasses/</guid>
      <description>已知当前对象为org.apache.hadoop.hdfs.client.HdfsDataInputStream实例，调用其祖宗抽象类java.io.InputStream的publicint read(byte b[], int off, int len) throwsIOException方法，究竟最后使用的是那个类的实现呢？ 由如上类继承图可知，应该从对象类往上依次查找方法实现：HdfsDataInputStream、FSDataInputStream、&amp;hellip;&amp;hellip;。工作很繁琐，挑战眼力！
一个快捷的方式就是进入java.io.InputStream类，选中read(byte b[], int off, intlen) 方法，按住CTRL键后点击鼠标左键，这样会出现一个菜单： 选择OpenImplementation菜单，输入HdfsDataInputStream、FSDataInputStream、&amp;hellip;&amp;hellip;，可以更轻松的找到重写该方法的子类。 最终可知使用的是java.io.DataInputStream类中的实现：
public final int read(byte b[], int off, int len) throws IOException { return in.read(b, off, len); }  </description>
    </item>
    
    <item>
      <title>[Linux] 判断可执行文件或动态库是否包含符号表</title>
      <link>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link>
      <pubDate>Thu, 24 Oct 2013 22:48:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid>
      <description>在Linux下生成一个可执行文件或动态库，可以使用gcc/g++的&amp;rdquo;-g&amp;rdquo;选项使文件包含调试符号表。 要在Linux下判断一个第三方的可执行文件或动态库是否包含调试符号表，可以通过file命令实现：
srv01&amp;gt; file libcurl.so.6 libcurl.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (FreeBSD), dynamically linked, not stripped srv01&amp;gt; file /usr/bin/X11/curl /usr/bin/X11/curl: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked (uses shared libs), for FreeBSD 8.0 (800107), stripped  显示not stripped，表明文件带调试符号表；而显示stripped，表明文件已去除符号表。
如果文件包含调试符号表，可以通过objdump -t命令及选项打印文件的符号表：
srv01&amp;gt; objdump -t libcurl.so.6 libcurl.so.6: file format elf64-x86-64 SYMBOL TABLE: 0000000000000120 l d .hash 0000000000000000 00000000000012b0 l d .dynsym 0000000000000000 0000000000004b08 l d .dynstr 0000000000000000 0000000000006f36 l d .</description>
    </item>
    
    <item>
      <title>[C] GCC对UTF8 BOM的支持</title>
      <link>https://mryqu.github.io/post/c_gcc%E5%AF%B9utf8_bom%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Thu, 24 Oct 2013 20:31:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_gcc%E5%AF%B9utf8_bom%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>最近玩些特俗字符，结果对yqutest.cpp源码文件编译时先碰到error:converting to execution character set: Illegal bytesequence错误。GCC的源码字符集与执行字符集默认是UTF-8编码，为了避免源码文件乱码，最好也是采用UTF-8编码来存储源码文件。将源码编码转成UTF-8，问题得以解决。 但是否需要UTF-8 BOM(byte-order mark)呢？ 我一时兴起添加了BOM，十六进制为EF BB BF，即对应八进制的357 273 277，编译结果如下：
mryqu&amp;gt; g++ yqutest.cpp -o yqutst123 yqutest.cpp:1: error: stray &#39;\357&#39; in program yqutest.cpp:1: error: stray &#39;\273&#39; in program yqutest.cpp:1: error: stray &#39;\277&#39; in program yqutest.cpp:1: error: stray &#39;#&#39; in program yqutest.cpp:1: error: expected constructor, destructor, or type conversion before &#39;&amp;lt;&#39; token mryqu&amp;gt; g++ -v Using built-in specs. Target: amd64-undermydesk-freebsd Configured with: FreeBSD/amd64 system compiler Thread model: posix gcc version 4.</description>
    </item>
    
    <item>
      <title>*nux下导出文件16进制内容的命令xxd</title>
      <link>https://mryqu.github.io/post/linux%E4%B8%8B%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B616%E8%BF%9B%E5%88%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%91%BD%E4%BB%A4xxd/</link>
      <pubDate>Thu, 24 Oct 2013 19:16:18 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux%E4%B8%8B%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B616%E8%BF%9B%E5%88%B6%E5%86%85%E5%AE%B9%E7%9A%84%E5%91%BD%E4%BB%A4xxd/</guid>
      <description>xxd命令可以导出文件的16进制内容，也能将16进制内容转换成2进制，还可以将内容导出成C语言变量，很不错的一个工具！ 参考 xxd(1) - Linux man page
5 Unix Commands I Wish I’d Discovered Years Earlier</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 从静态库获取GCC版本和编译平台</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BB%8E%E9%9D%99%E6%80%81%E5%BA%93%E8%8E%B7%E5%8F%96gcc%E7%89%88%E6%9C%AC%E5%92%8C%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Thu, 24 Oct 2013 07:43:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BB%8E%E9%9D%99%E6%80%81%E5%BA%93%E8%8E%B7%E5%8F%96gcc%E7%89%88%E6%9C%AC%E5%92%8C%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</guid>
      <description>获取GCC版本：strings -a {library} | grep &amp;ldquo;GCC: (&amp;rdquo;
mryqu&amp;gt; strings -a libcurl.a | grep &amp;quot;GCC: (&amp;quot; GCC: (GNU) 4.4.5 20110214 (Red Hat 4.4.5-6)  获取编译平台信息：ar -x {library}file *.o
mryqu&amp;gt; ar -x libcurl.a mryqu&amp;gt;file libcurl_la-url.o libcurl_la-url.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped  参考 How to retrieve the GCC version used to compile a given ELF executable?
How to see the compilation platform of a static library file</description>
    </item>
    
    <item>
      <title>用find和grep搜索特定目录下特定文件中的特定关键字</title>
      <link>https://mryqu.github.io/post/%E7%94%A8find%E5%92%8Cgrep%E6%90%9C%E7%B4%A2%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Wed, 23 Oct 2013 19:58:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%94%A8find%E5%92%8Cgrep%E6%90%9C%E7%B4%A2%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>下例为递归搜索当前目录下所有以yqu为后缀的文件中的关键字123：
find . -name &amp;quot;*.yqu&amp;quot; | xargs grep -H &amp;quot;123&amp;quot;  </description>
    </item>
    
    <item>
      <title>cut命令笔记</title>
      <link>https://mryqu.github.io/post/cut%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 22 Oct 2013 23:22:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cut%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</guid>
      <description> cut命令比较简单，但是也没测试过所有的选项，这里试一下没有细扣过的选项。
命令名 cut -- 对文件每一行的选定部分进行裁剪 概要 cut -b list [-n] [file ...] cut -c list [file ...] cut -f list [-d delim] [-s] [file ...] 描述 cut工具会从每个文件每一行裁剪出选定部分并写入标准输出。如果没有指定file参数，或file参数为单个破折号(&#39;-&#39;)，cut将从标准输入进行读取。list指定可以是列位置或特定字符分隔的字段序号，起始值为1。 list选项参数为逗号或空白字符分隔的数字或数字范围集合。数字范围可由数字+破折号（&#39;-&#39;）+第二个数字组成内包含范围。 数字和数字范围可以重复、重叠，但字段或列如果多次被选中，则仅显示一次。输入中没有选定的字段或列，不会报错。 N- 从第N个开始到所在行结束的所有字节、字符或列 N-M 从第N个开始到第M个之间(包括第M个)的所有字节、字符或列 -M 从第1个开始到第M个之间(包括第M个)的所有字节、字符或列 命令选项如下： -b list list指定字节位置。 -c list list指定字符位置。 -d delim 使用delim而不是制表符作为字段分隔符。 -f list list指定由字段分隔符(见-d选项)对输入分割后的字段。 输出字段由单个字段分隔符分开。 -n 不拆分多字节字符。 仅在多字节字符全部选中的情况下，字符才会被输出。 -s 抑制没有字段分隔符的行。如果没指定该选项的话，没有分隔符的行会原封不动地输出。 环境 环境变量LANG、LC_ALL和LC_CTYPE将影响cut的执行结果。 退出码 cut工具执行成功时返回0，执行出错时返回值大于0。 示例 从系统passwd文件抽取用户登录名和Shell(5)，显示成&#39;&#39;name:shell&#39;&#39;对: cut -d : -f 1,7 /etc/passwd 显示当前登录用户的名称和登录时间: who | cut -c 1-16,26-38  个人体会  cut命令在unix/mac和linux/MinGW上实现并不一样。 cut命令在linux/MinGW上的实现忽略-n选项，此外通过GNU CoreUtils中的cut源码可知-b和-c选项实现是一样的，operating_mode变量都是枚举byte_mode，走的是cut_bytes函数。而unix/mac上的实现通过-n选项可以同时是否输出多字节字符的部分字节码。 cut命令在linux/MinGW上的实现还有&amp;ndash;output-delimiter=STRING选项控制输出字符分隔符。  </description>
    </item>
    
    <item>
      <title>grep命令笔记</title>
      <link>https://mryqu.github.io/post/grep%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 22 Oct 2013 22:52:04 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/grep%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</guid>
      <description> 使用grep时一直没有使用什么命令选项，这里过一遍grep帮助，试一遍不明白的选项。
grep简介 grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
grep命令帮助 示例: grep -i &#39;hello world&#39; menu.h main.c 正则选择和解释: -E, --extended-regexp PATTERN为扩展正则表达式（ERE） -F, --fixed-strings PATTERN是一套新行分割字符串 -G, --basic-regexp PATTERN为基本正则表达式（BRE） -P, --perl-regexp PATTERN为Perl正则表达式 -e, --regexp=PATTERN 使用PATTERN作为正则表达式 -f, --file=FILE 从文件中获得PATTERN -i, --ignore-case 忽略大小写 -w, --word-regexp 强制PATTERN仅匹配整个单词 -x, --line-regexp 强制PATTERN仅匹配整行 -z, --null-data 数据行以0字节而不是新行截至（打印整个文件了） 杂项: -s, --no-messages 抑制错误消息 -v, --invert-match 选择非匹配行 -V, --version 显示版本信息并退出 --help 显示该帮助并退出 -J, --bz2decompress 在进行搜索前解压缩bzip压缩输入 -Z, --decompress 在进行搜索前解压缩输入(HAVE_LIBZ=1) --mmap 如可能使用内存映射输入 输出控制: -m, --max-count=NUM 在NUM个匹配后停止工作 -b, --byte-offset 在输出行显示字节偏移 -n, --line-number 显示行号 --line-buffered 对每行都清除缓存强制输出 -H, --with-filename 对每个匹配结果显示文件名 -h, --no-filename 抑制输出中前缀的文件名 --label=LABEL 将LABEL作为标准输入的文件名显示（输入为管道有用） -o, --only-matching 仅显示行匹配PATTERN部分 -q, --quiet, --silent 抑制所有正常输出。通常用于脚本条件语句中，判断匹配结果是1还是0 --binary-files=TYPE 将二进制文件假定为类型，分别为&#39;binary&#39;、&#39;text&#39;或 &#39;without-match&#39;。默认为&#39;binary&#39;，对二进制文件进行搜索 而不显示；&#39;text&#39;，一概视为文本文件，搜索并显示； &#39;without-match&#39;，对二进制文件直接忽略，不搜索不显示。 -a, --text 等同于--binary-files=text -I 等同于--binary-files=without-match -d, --directories=ACTION 如何处理目录的操作项，分别为&#39;read&#39;、&#39;recurse&#39;或&#39;skip&#39;。 -D, --devices=ACTION 如何处理设备、FIFO和socket的操作项，分别为&#39;read&#39;或&#39;skip&#39;。 -R, -r, --recursive 等同于--directories=recurse --include=PATTERN 匹配PATTERN的文件将被检查 --exclude=PATTERN 匹配PATTERN的文件将被忽略 --exclude-from=FILE 匹配模式文件中PATTERN的文件将被忽略 -L, --files-without-match 仅显示不包含匹配的文件名 -l, --files-with-matches 仅显示包含匹配的文件名 -c, --count 仅显示每个文件匹配行数 --null 在文件名后显示0字节（跟不带这个选项就少一个冒号？） 上下文控制: -B, --before-context=NUM 输出匹配结果及其前NUM行 -A, --after-context=NUM 输出匹配结果及其后NUM行 -C, --context=NUM 输出匹配结果及其前后各NUM行 -NUM 等同--context=NUM --color[=WHEN], --colour[=WHEN] 使用标记突显匹配字符串，WHEN可为&#39;always&#39;、&#39;never&#39;或&#39;auto&#39; 默认项为&#39;never&#39;，&#39;always&#39;总是使用标记，而&#39;auto&#39;仅输出 在没有被管道到其他命令或重定向到文件时才使用标记。 -U, --binary 在行结尾EOL不除去回车换行CR字符(MSDOS) -u, --unix-byte-offsets 如果没有回车换行则报告字节偏移(MSDOS)  </description>
    </item>
    
    <item>
      <title>Xterm DISPLAY变量</title>
      <link>https://mryqu.github.io/post/xterm_display%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 21 Oct 2013 20:49:10 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/xterm_display%E5%8F%98%E9%87%8F/</guid>
      <description>DISPLAY变量的格式为[host]:&amp;lt;display&amp;gt;[.screen] host 指网络主机名，空缺则指本机。 每个主机可以有多个显示，每个显示可以有多个屏幕。因此，DISPLAY=:0通常指本机内的所有GPU，DISPLAY=:0.0指本机内的第一个配置屏幕/GPU，DISPLAY=:0.1指本机内的第二个配置屏幕/GPU。</description>
    </item>
    
    <item>
      <title>Xming使用笔记</title>
      <link>https://mryqu.github.io/post/xming%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 21 Oct 2013 20:20:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/xming%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>XWindow系统里有一个统一的Server来负责各个程序与显示器、键盘和鼠标等输入输出设备的交互，每个有GUI的应用程序都通过网络协议与Server进行交互。所以对于任何一个应用程序，本地运行和远程运行的差别仅仅是XServer的地址不同，别的没有差别。所以在Windows运行一个XServer，就可以很方便的远程运行有GUI的Linux应用了。 Xming是一个在Microsoft Windows操作系统上运行XWindow系统的服务器。它非常简单易用，搭配强大。一般搭配putty的下列配置，就可以在Windows平台上远程运行有GUI的Linux应用了：
Connection-SSH-X11-Enable X11 forwarding  Xming操作笔记如下： - 选择单词：双击鼠标左键 - 选择一行：三击鼠标左键 - 选择特定文本：鼠标左键点击文本起点，然后按住鼠标右键选择。 - 复制文本：Alt + Shift + C</description>
    </item>
    
    <item>
      <title>[C] Exec format error</title>
      <link>https://mryqu.github.io/post/c_exec_format_error/</link>
      <pubDate>Sun, 20 Oct 2013 17:28:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_exec_format_error/</guid>
      <description>很久没用g++了，结果编个小程序还出错。
mryqu:~/ctest$ g++ -g -c wvc.cpp -o wvc mryqu:~/ctest$ chmod a+x wvc mryqu:~/ctest$ ./wvc -bash: ./wvc: cannot execute binary file: Exec format error mryqu:~/ctest$ file wvc wvc: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped  查了查gcc的帮助，才发现用了-c选项后其实是只编译不链接的：
-c Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</description>
    </item>
    
    <item>
      <title>Ubuntu下显示本机IP</title>
      <link>https://mryqu.github.io/post/ubuntu%E4%B8%8B%E6%98%BE%E7%A4%BA%E6%9C%AC%E6%9C%BAip/</link>
      <pubDate>Sun, 20 Oct 2013 12:05:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/ubuntu%E4%B8%8B%E6%98%BE%E7%A4%BA%E6%9C%AC%E6%9C%BAip/</guid>
      <description>命令为：ip addr show 感觉比ifconfig eth0更通用些！</description>
    </item>
    
    <item>
      <title>在Vi中搜索多字节unicode字符</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8vi%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%A4%9A%E5%AD%97%E8%8A%82unicode%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Sun, 20 Oct 2013 09:00:49 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8vi%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%A4%9A%E5%AD%97%E8%8A%82unicode%E5%AD%97%E7%AC%A6/</guid>
      <description>使用Vi编辑unicode字符文本文件时，可以通过下列方式搜索和替换字符：
\%d 匹配特定十进制字符 (例如 \%d 123) \%x 匹配特定十六进制字符 (例如 \%x2a) \%o 匹配特定八进制字符 (例如 \%o040) \%u 匹配特定多字节字符 (例如 \%u20ac) \%U 匹配特定大的多字节字符(例如 \%U12345678)  为了在文本中查看任何字符的unicode或十六机制格式内容，将光标置于该字符上之后输入ga 命令。这会以十进制、十六机制和八进制显示显示字符值： </description>
    </item>
    
    <item>
      <title>host笔记</title>
      <link>https://mryqu.github.io/post/host%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 23:45:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/host%E7%AC%94%E8%AE%B0/</guid>
      <description> host命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。
host参数 -a等价于使用“-v -t ANY”-c Class当搜索非网际数据时要指定要查找的类。有效类为:
IN网际类CHAOSChaos类HESIODMIT AlthenaHesiod类ANY通配符-C在需要认证的域名服务器上查找SOA记录-d等价于使用“-v”-l列出一个域内所有的主机-i反向查找-N改变点数-r禁用递归处理。-R指定UDP包数-t Type指定要查询的记录类型。常用类型为:
A主机的网际地址CNAME别名的规范名称HINFO主机CPU与操作系统类型KEY安全密钥记录MINFO邮箱或邮件列表信息MX邮件交换器NS指定范围的名称服务器PTR如果查询的是一个网际地址则为主机名；否则，为其他信息的指针SIG签名记录SOA域的&#34;授权开始&#34;信息TXT文本信息UINFO用户信息WKS所支持的众所周知的服务。-T支持TCP/IP模式-v运行时显示详细的处理信息-w永远等待DNS服务器的一个回答。-W Waite指定等待回复的时间-4用于IPv4的查询-6用于IPv6的查询-m设置内存调试标志 host使用 </description>
    </item>
    
    <item>
      <title>清除Chrome中特定网站的所有历史记录</title>
      <link>https://mryqu.github.io/post/%E6%B8%85%E9%99%A4chrome%E4%B8%AD%E7%89%B9%E5%AE%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 19 Oct 2013 21:15:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E6%B8%85%E9%99%A4chrome%E4%B8%AD%E7%89%B9%E5%AE%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>想要Chrome中特定网站的所有历史记录，可是搜出特定网站的所有历史记录后必须对每一项进行选择，然后才能删除。终于在网上搜出一个妙招来： - 进入Chrome历史记录页面； - 搜索想要删除的URL； - 为了删除所搜结果的所有记录，将第一个待删项的checkbox勾选上，接着滚动页面到最后一个待删项，按住SHIFT键将最后一个待删项的checkbox勾选上，这样所有待删项都会被勾选上； - 点击&amp;rdquo;Remove selected items&amp;rdquo;按钮即可。</description>
    </item>
    
    <item>
      <title>Cscope笔记</title>
      <link>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 20:20:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</guid>
      <description>Cscope简介 Cscope是一个类似Ctags的工具，但功能比ctags强大很多。Cscope是一款自带一个基于文本的用户界面的源代码浏览工具，尽管它最初是为C代码的搜索（包括lex、yacc文件）设计的，但是也可以用于对C++和Java代码的搜索。用Cscope你可以轻易地搜索到你的标识符是在哪里被定义和使用的，它可以轻而易举地解决以下问题： - 这个变量在哪里被使用？ - 这个预处理符号的值是什么？ - 这个函数都在哪些源代码文件中出现过？ - 都有哪些函数调用了这个函数？ - &amp;ldquo;out of space&amp;rdquo;的消息是从哪里来的？ - 这个源文件在在目录结构中的位置？ - 都有哪些源文件包含了这个头文件？
Cscope是由Santa Cruz Operation, Inc发布的，它遵循BSD开源协议。
安装 Cscope项目仅提供源代码，不提供二进制文件。cscope-win32项目提供了使用MinGW、MSYS和Cygwin编译Windows平台Cscope的方法，此外也提供编译好好的csope.exe文件。下载cscope-15.8a-win64rev1-static.zip，将其中的cscope.exe解压缩到系统环境变量path包含的路径即可。 使用 创建符号数据库 Cscope在第一次被使用在指定的源文件时会建立一个符号的数据库。接下来调用时，Cscope仅仅重建那些被改动或者和新文件相关的数据库。那些没有被改动的文件相关的数据库会被直接复制使用。这使得重建数据库要比第一次运行快许多。 Cscope命令的参数如下： - -R: 在生成索引文件时，搜索子目录树中的代码 - -b: 只生成索引文件，不进入cscope的界面 - -q:生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度 - -k: 在生成索引文件时，不搜索/usr/include目录 - -i:如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”-“，表示由标准输入获得文件列表。 - -Idir:在-I选项指出的目录中查找头文件 - -u: 扫描所有文件，重新生成交叉索引文件 - -C: 在搜索时忽略大小写 - -Ppath:在以相对路径表示的文件前加上的path，这样，你不用切换到你数据库文件所在的目录也可以使用它了。 我针对curl项目执行cscope -Rkq ，这样会启动Cscope的文本用户界面，之后我搜索set_binmode函数： 搜索符号 在Cscope的文本界面里可以在命令模式执行:cs find或:cs f命令搜索符号，其参数为： - s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方 - g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能 - d: 查找本函数调用的函数 - c: 查找调用本函数的函数 - t: 查找指定的字符串 - e: 查找egrep模式，相当于egrep功能，但查找速度快多了 - f: 查找并打开文件，类似vim的find功能 - i: 查找包含本文件的文件</description>
    </item>
    
    <item>
      <title>Exuberant Ctags笔记</title>
      <link>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 14:46:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</guid>
      <description>Ctags简介 Ctags（Generate tag files for sourcecode）产生标记(/索引)文件以帮助在源文件中定位对象。Ctags最初支持C语言，现在已经支持C/C++/Java/JS/Python等41种语言。Vim/Emacs/SublimeText/UltraEdit等编辑器或工具都支持Ctags生成的标记文件。 对于C/C++语言来说，其生成的标记文件tags中包括这些对象的列表： - 用#define定义的宏 - 枚举型变量的值 - 函数的定义、原型和声明 - 名字空间（namespace） - 类型定义（typedefs） - 变量（包括定义和声明） - 类（class）、结构（struct）、枚举类型（enum）和联合（union） - 类、结构和联合中成员变量或函数
安装 下载ctags58.zip，将其中的ctags.exe解压缩到系统环境变量path包含的路径即可。 使用选项 如果没有指定−−language−force选项，每个源文件的语言基于文件名和语言的映射进行自动选择。该映射可用−−list−maps选项显示，它可能会被−−langmap选项改变。对于操作系统所支持的文件，如果文件名无法映射到某种语言且该文件可被执行，则会对文件第一行检查是为&amp;rdquo;#!&amp;ldquo;公认的语言脚本。默认情况下，所有其他文件名都会被忽略。由于仅文件名可匹配某种语言的文件会被扫描，这使得在单个目录对所有文件(例如&amp;rdquo;ctags*&amp;ldquo;)或对目录树的所有文件(例如&amp;rdquo;ctags −R&amp;rdquo;)执行ctags成为可能。.h扩展名即用于C++也用于C，所以Ctags将.h映射为C++，这样做不会有不良后果。
 -R：等同于&amp;ndash;recurse，递归子目录遍历 -L：从文件读取Ctags待处理文件列表并对其执行ctags  find . -name &amp;quot;*.h&amp;quot; -o -name &amp;quot;*.c&amp;quot; -o -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.bld&amp;quot; -o -name &amp;quot;*.blt&amp;quot; &amp;gt; prj.files ctags -L prj.files  --list−maps：显示文件名和语言的映射  --list−languanges：显示所有支持的语言  --langmap：设置文件名和语言的映射 如果程序中有的.c文件其实是C++程序，这该怎么办？答案是使用ctags &amp;ndash;langmap=c++:+.c。 −−language−force：强制使用特定语言，而不是通过文件名和语言的映射进行自动选择 像C++标准库stl中文件名没有后缀，怎么办？ 使用ctags−−language−force=C++这样就把所有文件当成C++来处理了。 −−fields：指定标记文件中条目的可用扩展字段（没有指明的默认关闭） a
类成员的访问属性
f
文件限制范围 [enabled]</description>
    </item>
    
    <item>
      <title>Linux包管理速查表</title>
      <link>https://mryqu.github.io/post/linux%E5%8C%85%E7%AE%A1%E7%90%86%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Fri, 18 Oct 2013 20:14:05 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux%E5%8C%85%E7%AE%A1%E7%90%86%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>管理软件包 |任务|apt (deb)|yum (rpm)|zypper (rpm) |&amp;mdash;&amp;ndash; |通过仓库安装软件包|apt-get install {pkg}|yum install {pkg}|zypper install {pkg} |更新软件包|apt-get install {pkg}|yum update {pkg}|zypper update -t package {pkg} |移除软件包|apt-get remove {pkg}|yum erase {pkg}|zypper remove {pkg} |通过文件安装软件包|dpkg -i {pkg}|yum localinstall {pkg}|zypper install {pkg}
搜索软件包 |任务|apt (deb)|yum (rpm)|zypper (rpm) |&amp;mdash;&amp;ndash; |通过包名搜索|apt-cache search {pkg}|yum list {pkg}|zypper search {pkg} |通过模式搜索|apt-cache search pattern|yum search pattern|zypper search -t pattern pattern |通过文件名搜索|apt-file search path|yum provides file|zypper wp file |列举已安装软件包|dpkg -l|rpm -qa|zypper search -is |显示软件包信息|apt-cache show pgk-name|yum info {pkg}|zypper info {pkg}</description>
    </item>
    
    <item>
      <title>Debian软件包管理速查表：dpkg、apt-get、apt-cache</title>
      <link>https://mryqu.github.io/post/debian%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E9%80%9F%E6%9F%A5%E8%A1%A8dpkgapt-getapt-cache/</link>
      <pubDate>Fri, 18 Oct 2013 19:54:39 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/debian%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E9%80%9F%E6%9F%A5%E8%A1%A8dpkgapt-getapt-cache/</guid>
      <description>dpkg是Debian系统底层包管理器，apt-get是高层包管理工具，apt-cache是高层包查询工具。
dpkg速查表 dpkg是Debian Linux用于安装/管理单个软件包的命令行工具：
语法描述示例dpkg -i {.deb package}安装软件包dpkg -i zip_2.31-3_i386.debdpkg -i {.deb package}安装新的软件包。如果软件包已安装则尝试更新到最新版本dpkg -i zip_2.31-3_i386.debdpkg -R {Directory-name}递归地安装目录下所有软件包dpkg -R /tmp/downloadsdpkg -r {package}移除一个已安装的软件包，保留配置文件dpkg -r zipdpkg -P {package}移除一个已安装的软件包及配置dpkg -P apache-perl dpkg -l列举所有安装的软件包、及包版本和简短描述dpkg -l dokg -l | less dpkg -l &#39;*apache*&#39; dpkg -l | grep -i &#39;sudo&#39;dpkg -l {package}列举单个安装的软件包、及包版本和简短描述dpkg -l apache-perldpkg -L {package}找出安装的软件包所提供的文件，例如列出安装的文件dpkg -L apache-perl dpkg -L perldpkg -c {.Deb package}列出软件包所提供的文件，例如deb包文件内的所有文件，这对找出将要安装什么文件非常有帮助dpkg -c dc_1.06-19_i386.debdpkg -S {/path/to/file}找出拥有该文件的包，例如找出该文件归属的包dpkg -S /bin/netstat
dpkg -S /sbin/ippooldpkg -p {package}显示包的详细信息，包组、版本、维护者、架构、依赖包、描述等dpkg -p lsofdpkg -s {package} | grep Status找出Debian包是否安装(状态)dpkg -s lsof | grep Status apt-get速查表 apt-get是Debian Linux用于管理软件包的命令行工具：</description>
    </item>
    
    <item>
      <title>dig笔记</title>
      <link>https://mryqu.github.io/post/dig%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 12 Oct 2013 19:51:58 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/dig%E7%AC%94%E8%AE%B0/</guid>
      <description>dig是域信息搜索器（domain informationgroper）。dig和nslookup作用有些类似，都是DNS查询工具。它与nslookup的区别在于：dig使用操作系统的解析库而nslookup使用自己的一套。Bind开发组已经宣布废弃nslookup，但Unix和Linux系统一般都安装了这两个工具。一些专业的DNS管理员在追查DNS问题时，都乐于使用dig命令，是看中了dig设置灵活、输出清晰、功能强大的特点。
如果Ubuntu下没有dig命令，可通过如下命令安装：
sudo apt-get install dnsutils  dig使用说明 dig选项 -b address设置所要询问地址的源 IP 地址。这必须是主机网络接口上的某一合法的地址。-c class缺省查询类（IN forinternet）由选项-c重设。class可以是任何合法类，比如查询Hesiod记录的HS类或查询CHAOSNET记录的CH 类。-f filename使dig在批处理模式下运行，通过从文件filename读取一系列搜索请求加以处理。文件包含许多查询；每行一个。文件中的每一项都应该以和使用命令行接口对dig的查询相同的方法来组织。-h当使用选项-h时，显示一个简短的命令行参数和选项摘要。-k filename要签署由dig发送的DNS查询以及对它们使用事务签名（TSIG）的响应，用选项-k指定TSIG密钥文件。-n缺省情况下，使用IP6.ARPA域和RFC2874定义的二进制标号搜索IPv6地址。为了使用更早的、使用IP6.INT域和nibble标签的RFC1886方法，指定选项-n（nibble）。-p port#如果需要查询一个非标准的端口号，则使用选项-p。port#是dig将发送其查询的端口号，而不是标准的DNS端口号53。该选项可用于测试已在非标准端口号上配置成侦听查询的域名服务器。-t type设置查询类型为type。可以是BIND9支持的任意有效查询类型。缺省查询类型是A，除非提供-x选项来指示一个逆向查询。通过指定AXFR的type可以请求一个区域传输。当需要增量区域传输（IXFR）时，type设置为ixfr=N。增量区域传输将包含自从区域的SOA记录中的序列号改为N之后对区域所做的更改。-x addr逆向查询（将地址映射到名称）可以通过-x选项加以简化。addr是一个以小数点为界的IPv4地址或冒号为界的IPv6地址。当使用这个选项时，无需提供name、class和type参数。dig自动运行类似11.12.13.10.in-addr.arpa的域名查询，并分别设置查询类型和类为PTR和IN。-y name:key您可以通过命令行上的-y选项指定TSIG密钥；name是TSIG密码的名称，key是实际的密码。密码是64位加密字符串，通常由dnssec-keygen（8）生成。当在多用户系统上使用选项-y时应该谨慎，因为密码在ps（1）的输出或shell 的历史文件中可能是可见的。当同时使用dig和TSCG认证时，被查询的名称服务器需要知道密码和解码规则。在BIND中，通过提供正确的密码和named.conf中的服务器声明实现。
dig的查询选项 dig提供查询选项，它影响搜索方式和结果显示。一些在查询请求报头设置或复位标志位，一部分决定显示哪些回复信息，其它的确定超时和重试战略。每个查询选项被带前缀（+）的关键字标识。一些关键字设置或复位一个选项。通常前缀是求反关键字含义的字符串no。其他关键字分配各选项的值，比如超时时间间隔。它们的格式形如+keyword=value。查询选项是： +[no]tcp查询域名服务器时使用[不使用]TCP。缺省行为是使用 UDP，除非是 AXFR 或 IXFR 请求，才使用 TCP连接。+[no]vc查询名称服务器时使用[不使用]TCP。+[no]tcp的备用语法提供了向下兼容。vc代表虚电路。+[no]ignore忽略 UDP 响应的中断，而不是用 TCP 重试。缺省情况运行 TCP 重试。+domain=somename设定包含单个域somename的搜索列表，好像被/etc/resolv.conf中的域伪指令指定，并且启用搜索列表处理，好像给定了+search选项。+[no]search使用[不使用]搜索列表或resolv.conf中的域伪指令（如果有的话）定义的搜索列表。缺省情况不使用搜索列表。+[no]defname不建议看作+[no]search的同义词。+[no]aaonly该选项不做任何事。它用来提供对设置成未实现解析器标志的dig的旧版本的兼容性。+[no]adflag在查询中设置 [不设置]AD（真实数据）位。目前AD位只在响应中有标准含义，而查询中没有，但是出于完整性考虑在查询中这种性能可以设置。+[no]cdflag在查询中设置 [不设置] CD（检查禁用）位。它请求服务器不运行响应信息的DNSSEC合法性。+[no]recursive切换查询中的 RD（要求递归）位设置。在缺省情况下设置该位，也就是说 dig正常情形下发送递归查询。当使用查询选项+nssearch或+trace时，递归自动禁用。+[no]nssearch这个选项被设置时，dig试图寻找包含待搜名称的网段的权威域名服务器，并显示网段中每台域名服务器的SOA记录。+[no]trace切换为待查询名称从根名称服务器开始的代理路径跟踪。缺省情况不使用跟踪。一旦启用跟踪，dig使用迭代查询解析待查询名称。它将按照从根服务器的参照，显示来自每台使用解析查询的服务器的应答。+[no]cmd设定在输出中显示指出dig版本及其所用的查询选项的初始注释。缺省情况下显示注释。+[no]short提供简要答复。缺省值是以冗长格式显示答复信息。+[no]identify当启用+short选项时，显示[或不显示]提供应答的IP地址和端口号。如果请求简短格式应答，缺省情况不显示提供应答的服务器的源地址和端口号。+[no]comments切换输出中的注释行显示。缺省值是显示注释。+[no]stats该查询选项设定显示统计信息：查询进行时，应答的大小等等。缺省显示查询统计信息。+[no]qr显示 [不显示] 发送的查询请求。缺省不显示。+[no]question当返回应答时，显示 [不显示] 查询请求的问题部分。缺省作为注释显示问题部分。+[no]answer显示 [不显示] 应答的回答部分。缺省显示。+[no]authority显示 [不显示] 应答的权限部分。缺省显示。+[no]additional显示 [不显示] 应答的附加部分。缺省显示。+[no]all设置或清除所有显示标志。+time=T为查询设置超时时间为T秒。缺省是5秒。如果将T设置为小于1的数，则以1秒作为查询超时时间。+tries=A设置向服务器发送 UDP 查询请求的重试次数为A，代替缺省的 3次。如果把A小于或等于 0，则采用 1 为重试次数。+ndots=D出于完全考虑，设置必须出现在名称D的点数。缺省值是使用在/etc/resolv.conf中的ndots语句定义的，或者是 1，如果没有ndots语句的话。带更少点数的名称被解释为相对名称，并通过搜索列表中的域或文件/etc/resolv.conf 中的域伪指令进行搜索。+bufsize=B设置使用 EDNS0 的 UDP消息缓冲区大小为B字节。缓冲区的最大值和最小值分别为65535和0。超出这个范围的值自动舍入到最近的有效值。+[no]multiline以详细的多行格式显示类似SOA的记录，并附带可读注释。缺省值是每单个行上显示一条记录，以便于计算机解析dig的输出。
全局查询参数（global-d-opt）和（在主机名之前的）服务器影响所有查询。局部查询参数和（在主机名之后的）服务器仅影响当前查询。
dig使用 mryqu&amp;gt; dig ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.</description>
    </item>
    
    <item>
      <title>Shell中的source和.命令</title>
      <link>https://mryqu.github.io/post/shell%E4%B8%AD%E7%9A%84source%E5%92%8C.%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 10 Oct 2013 23:11:05 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E4%B8%AD%E7%9A%84source%E5%92%8C.%E5%91%BD%E4%BB%A4/</guid>
      <description>source是csh(C Shell)的内置命令: 标识读入并执行文件中的命令。 这与执行shell脚本是不一样的./script.sh会启动一个新的shell并执行script.sh中的命令。
source [-h] filename [arguments] The shell reads and executes commands from name. The commands are not placed on the history list. If any args are given, they are placed in argv. (+) source commands may be nested; if they are nested too deeply the shell may run out of file descriptors. An error in a source at any level terminates all nested source commands. With -h, commands are placed on the history list instead of being executed, much like `history -L&#39;.</description>
    </item>
    
    <item>
      <title>[Git] 预览远程仓库与本地仓库的差异</title>
      <link>https://mryqu.github.io/post/git_%E9%A2%84%E8%A7%88%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%B7%AE%E5%BC%82/</link>
      <pubDate>Mon, 23 Sep 2013 20:19:12 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E9%A2%84%E8%A7%88%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%B7%AE%E5%BC%82/</guid>
      <description>首先使用git fetch更新远程分支的本地副本，这不会对任何本地分支造成影响。
使用git log HEAD..origin可以显示本地分支与origin远程分支之间的提交日志。
使用git log -p HEAD..origin除了显示上述提交日志外，还会显示每个提交的补丁。
使用git diff HEAD...origin显示整个补丁。此外如果有本地未提交的修改，可以使用git diff origin/master显示整个补丁。
如果不想使用git pull来合并所有远程提交，可以使用git cherry-pick接受所需要的指定远程提交。最后当准备好接受所有远程提交再使用git pull合并剩余远程提交。</description>
    </item>
    
    <item>
      <title>[Git] 获取两个版本间所有变更的文件列表</title>
      <link>https://mryqu.github.io/post/git_%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E9%97%B4%E6%89%80%E6%9C%89%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/</link>
      <pubDate>Sun, 22 Sep 2013 07:25:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git_%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E9%97%B4%E6%89%80%E6%9C%89%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/</guid>
      <description>git diff commit-SHA1 commit-SHA2 &amp;ndash;name-status返回变更的文件列表，每个文件前带有变更状态： - &amp;lsquo; &amp;rsquo; = unmodified - M = modified - A = added - D = deleted - R = renamed - C = copied - U = updated but unmergedgit diff commit-SHA1 commit-SHA2 &amp;ndash;stat返回变更的文件列表，每个文件后面带有变更统计信息。</description>
    </item>
    
    <item>
      <title>SSH keys for Git System</title>
      <link>https://mryqu.github.io/post/ssh_keys_for_git_system/</link>
      <pubDate>Wed, 18 Sep 2013 22:58:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/ssh_keys_for_git_system/</guid>
      <description>SSH keys[](http://gitlab.sas.com/help/ssh/README#ssh-keys) An SSH key allows you to establish a secure connection betweenyour computer and Git system such as GitHub, GitLab. Before generating an SSH key, check if your system already hasone by running cat ~/.ssh/id_rsa.pub . If you see a long string startingwith ssh-rsa or ssh-dsa ,you can skip the ssh-keygen step. To generate a new SSH key, just open your terminal and use codebelow. The ssh-keygen command prompts you for a location andfilename to store the key pair and for a password.</description>
    </item>
    
    <item>
      <title>在Ubuntu上修改主机名</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%8A%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</link>
      <pubDate>Mon, 05 Aug 2013 22:49:19 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8ubuntu%E4%B8%8A%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</guid>
      <description> 显示主机名 hostname -s  更多细节见hostname帮助文档。
修改主机名 sudo hostname your-new-name # Ubuntu专有 hostnamectl set-hostname new-hostname  更多细节见hostnamectl帮助文档。 上述命令重启服务器后失效。
修改主机名配置 sudo -H vi /etc/hostname sudo -H vi /etc/hosts  </description>
    </item>
    
    <item>
      <title>git资料</title>
      <link>https://mryqu.github.io/post/git%E8%B5%84%E6%96%99/</link>
      <pubDate>Sat, 13 Jul 2013 18:52:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/git%E8%B5%84%E6%96%99/</guid>
      <description>综合 Pro Git 英文版 中文版
Git Community Book 英文版 中文版
GotGitHub
Git使用详解
项目主页 Creating Project Pages manually
Setup GitHub Pages &amp;ldquo;gh-pages&amp;rdquo; branch and &amp;ldquo;master&amp;rdquo; branch as subfolders of a parent project folder (&amp;ldquo;grandmaster&amp;rdquo;).
Setup GitHub Pages &amp;ldquo;gh-pages&amp;rdquo; branch as a subfolder within the &amp;ldquo;master&amp;rdquo; project on your local checkout - a step-by-step guide.
其他 Collaborative Github Workflow
如何理解git reset 取消提交的操作？
Git Document
Atlassian Git Tutorial
版本管理svn,git,cvs比较
learnGitBranching
a successful git branching model</description>
    </item>
    
    <item>
      <title>nslookup笔记</title>
      <link>https://mryqu.github.io/post/nslookup%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 28 Jun 2013 10:02:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/nslookup%E7%AC%94%E8%AE%B0/</guid>
      <description>nslookup命令是用来查询因特网域名服务器的。该命令在Unix、Linux和Windows平台都有提供。如果在Linux平台上找不到nslookup命令，检查是否安装bind-utils。
nslookup的使用模式 nslookup有两种模式：交互式和非交互式。 - 交互式模式允许向域名服务器查询各种主机、域名或打印域内主机列表。 - 非交互式模式用于查询一个主机或域的信息。
C:\&amp;gt;nslookup /? Usage: nslookup [-opt ...] # interactive mode using default server nslookup [-opt ...] - server # interactive mode using &#39;server&#39; nslookup [-opt ...] host # just look up &#39;host&#39; using default server nslookup [-opt ...] host server # just look up &#39;host&#39; using &#39;server&#39;  制定了查询对象就进入非交互式模式，否则进入交互模式。示例如下：这两次查询百度的命令区别在于：第一次使用了默认DNS，第二次指定了Google的DNS。返回结果是非权威答案，即从上连DNS服务器的本地缓存中读取出的值，而非实际去查询到的值。
nslookup选项 - set all：列出nslookup工具的常用选项的当前设置值。 - set class=[value]：可以更改查询类
 IN：Internet类（默认） CH：Chaos类 HS：Hesiod类 ANY：通配  Chaos和Hesiod现在几乎无人使用。 - set [no]debug：可以用来设置是否进入调试模式。如果setdebug，则会进入到调试模式，查询过程中会显示完整的响应包以及其中的交互包。 - set[no]d2：开启了高级调试模式，会输出很多nslookup内部工作的信息，包括了许多函数调用信息。 - set domain=[name]：用于设置默认的域。 - set [no]search：使用域搜索列表。 - setport=[value]：众所周知，DNS默认的服务端口是53。当某些特殊情况，此端口改变时，可以通过本命令来设置。 - set type=[value]：也可以写成setquerytype=[value]，用于更改信息查询类型。默认情况下，nslookup是查询域名所对应的A记录，而如果你想查询其对应的MX记录等信息时，就需要专门设置type值了。目前常用的type值如下：</description>
    </item>
    
    <item>
      <title>Shell参数扩展</title>
      <link>https://mryqu.github.io/post/shell%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 23 Jun 2013 18:55:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95/</guid>
      <description>在hadoop-env.sh中，有如下语句：
export HADOOP_CONF_DIR=${HADOOP_CONF_DIR:-&amp;quot;/etc/hadoop&amp;quot;}  这种用法在Shell Parameter Expansion中进行了详尽的介绍，系统学习一下。 Bash中的$符号的作用是参数替换，将参数名替换为参数所代表的值。对于$来说，大括号是可选的，即$ABC和${ABC}代表同一个参数。但是它可以防止变量被错误解析，比如：${hello}world、${arr[1]}。 参数扩展 下列Bash对参数的测试项为未设置和null。如果略掉冒号，则仅测试未设置。
|表达式|含义 |&amp;mdash;&amp;ndash; |${parameter:-word}|如果parameter没有被声明或者其值为空的话，则表达式替换成word；否则替换成parameter的值。 |${parameter:=word}|如果parameter没有被声明或者其值为空的话，则parameter设为word之后表达式返回parameter的值；否则替换成parameter的值。 |${parameter?word}|如果parameter没有被声明或者其值为空的话，则word被写往标准错误输出和Shell，非可交互的情况下退出；否则替换成parameter的值。 |${parameter:+word}|如果parameter没有被声明或者其值为空的话，则不进行替换；否则替换成parameter的值。 |${!varprefix}
${!varprefix@}|匹配之前所有以varprefix开头进行声明的变量 |${!name[@]}
${!name[]}|如果name是数组对象，返回数组下标列表；如果name以设置但不为数组对象，返回0；否则返回null。
字符串操作 |表达式|含义 |&amp;mdash;&amp;ndash; |${% raw %}{#{% endraw %}parameter}|parameter的长度。 |${parameter:offset}|在parameter中，从位置offset开始提取子串。 |${parameter:offset:length}|在parameter中，从位置offset开始提取长度为length的子串。 |${parameter#word}
${parameter##word}|从头开始扫描parameter对应值，将匹配word正则表达式的字符删除掉#为最短匹配，##为最长匹配。 |${parameter%word}
${parameter%%word}|从尾开始扫描parameter对应值，将匹配word正则表达式的字符删除掉%为最短匹配，%%为最长匹配。 |${parameter/pattern/string}
${parameter//pattern/string}|将parameter对应值的pattern代替为string。/表示只替换一次，//表示全部替换。 |${parameter^pattern}
${parameter^^pattern}|如果pattern是单个字符，将parameter对应值中匹配pattern的字符转换为大写。^表示只转换匹配的首字母，^^表示全部转换。 |${parameter,pattern}
${parameter,,pattern}|如果pattern是单个字符，将parameter对应值中匹配pattern的字符转换为小写。,表示只转换匹配的首字母，,,表示全部转换。</description>
    </item>
    
    <item>
      <title>为Unix终端或Windows命令行设置UTF-8编码</title>
      <link>https://mryqu.github.io/post/%E4%B8%BAunix%E7%BB%88%E7%AB%AF%E6%88%96windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AEutf-8%E7%BC%96%E7%A0%81/</link>
      <pubDate>Tue, 14 May 2013 21:20:30 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%B8%BAunix%E7%BB%88%E7%AB%AF%E6%88%96windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AEutf-8%E7%BC%96%E7%A0%81/</guid>
      <description>Unix终端 使用“locale –a” 命令检查支持的编码 servermt&amp;gt; locale -a C POSIX ……… en_US.ISO8859-1 en_US.ISO8859-15 en_US.US-ASCII en_US.UTF-8 ………  设置环境变量 LANG= en_US.UTF-8  Windows命令行 通过chcp命令设置 Displays or sets the active code page number: CHCP [nnn] C:\&amp;gt;chcp Active code page: 437 C:\&amp;gt;chcp 65001 Active code page: 65001  通过mode con命令设置 Select code page: MODE CON[:] CP SELECT=yyy Code page status: MODE CON[:] CP [/STATUS] C:\&amp;gt;mode con cp /status Status for device CON: ---------------------- Code page: 437 C:\&amp;gt;mode con cp select=65001 Status for device CON: ---------------------- Lines: 300 Columns: 160 Keyboard rate: 31 Keyboard delay: 1 Code page: 65001  代码页代号 |Identifier|.</description>
    </item>
    
    <item>
      <title>Windows服务的创建、查询及删除操作</title>
      <link>https://mryqu.github.io/post/windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 14 May 2013 21:04:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</guid>
      <description>SC是与Windows服务管理器和服务通信的命令行程序。
查询SC帮助 创建Windows服务 示例：sc create akxService binPath= C:\Test\akxService.exe
查询Windows服务 删除Windows服务 示例：sc delete akxService 如果服务名含有空格，可在服务名上加双引号。</description>
    </item>
    
    <item>
      <title>学会了用excel制作甘特图</title>
      <link>https://mryqu.github.io/post/%E5%AD%A6%E4%BC%9A%E4%BA%86%E7%94%A8excel%E5%88%B6%E4%BD%9C%E7%94%98%E7%89%B9%E5%9B%BE/</link>
      <pubDate>Sun, 23 Sep 2012 17:00:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%AD%A6%E4%BC%9A%E4%BA%86%E7%94%A8excel%E5%88%B6%E4%BD%9C%E7%94%98%E7%89%B9%E5%9B%BE/</guid>
      <description>参考文档 http://dreamtails.pixnet.net/blog/post/22059710-用excel畫甘特圖! http://www.excel123.cn/Article/tuxinghetubiao/201201/917.html</description>
    </item>
    
    <item>
      <title>Eclipse中解决远程调试超时的设置</title>
      <link>https://mryqu.github.io/post/eclipse%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%B6%85%E6%97%B6%E7%9A%84%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Fri, 07 Sep 2012 20:55:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/eclipse%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%B6%85%E6%97%B6%E7%9A%84%E8%AE%BE%E7%BD%AE/</guid>
      <description> 主要是加大调试器超时和启动超时设置 Tomcat设置 catalina.bat中添加如下：
:doStart shift if &amp;quot;%TITLE%&amp;quot; == &amp;quot;&amp;quot; set TITLE=Tomcat set _EXECJAVA=start &amp;quot;%TITLE%&amp;quot; %_RUNJAVA% set CATALINA_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,address=5558,server=y,suspend=n if not &amp;quot;&amp;quot;%1&amp;quot;&amp;quot; == &amp;quot;&amp;quot;-security&amp;quot;&amp;quot; goto execCmd shift echo Using Security Manager set &amp;quot;SECURITY_POLICY_FILE=%CTALINA_BASE%\conf\catalina.policy&amp;quot; goto execCmd  Eclipse设置 </description>
    </item>
    
    <item>
      <title>JDK、Ant和Maven开发环境配置</title>
      <link>https://mryqu.github.io/post/jdkant%E5%92%8Cmaven%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 07 Dec 2008 00:00:04 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/jdkant%E5%92%8Cmaven%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description> JDK  下载JDK并安装到c:\tools下 设置Java环境变量：JAVA_HOME = c:\tools\Java\jdk1.x.0_xxCLASSPATH =.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;path变量 %JAVA_HOME%\bin 运行&amp;rdquo;java -version&amp;rdquo;进行验证  Ant  下载Ant并解压缩到c:\tools下 设置Ant环境变量：ANT_HOME = c:\tools\apache-ant-1.x.xpath变量 %ANT_HOME%\bin 运行&amp;rdquo;ant -version&amp;rdquo;进行验证  maven  下载Maven并解压缩到c:\tools下 设置Maven环境变量：M2_HOME = c:\tools\apache-maven-x.x.xpath变量 %M2_HOME%\bin 运行&amp;rdquo;mvn &amp;ndash;version&amp;rdquo;进行验证  m2eclipse  通过下列update site安装:http://download.eclipse.org/technology/m2e/releases 在Window - Preferences - Maven - Installations添加上一步安装的Maven  </description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MQ on Mryqu's Notes</title><link>https://mryqu.github.io/categories/mq/</link><description>Recent content in MQ on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 13 Aug 2016 06:00:17 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/categories/mq/index.xml" rel="self" type="application/rss+xml"/><item><title>[RabbitMQ] AutorecoveringConnection在连接恢复后才调用ShutdownListener</title><link>https://mryqu.github.io/post/rabbitmq_autorecoveringconnection%E5%9C%A8%E8%BF%9E%E6%8E%A5%E6%81%A2%E5%A4%8D%E5%90%8E%E6%89%8D%E8%B0%83%E7%94%A8shutdownlistener/</link><pubDate>Sat, 13 Aug 2016 06:00:17 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_autorecoveringconnection%E5%9C%A8%E8%BF%9E%E6%8E%A5%E6%81%A2%E5%A4%8D%E5%90%8E%E6%89%8D%E8%B0%83%E7%94%A8shutdownlistener/</guid><description>想玩一玩RabbitMQ中的ShutdownListener和RecoveryListener，又不想写自己的重连接逻辑，所以使用了ConnectionFactory类的setAutomaticRecoveryEnabled方法让其自动恢复连接。代码如下：
package com.yqu.rabbitmq; import com.rabbitmq.client.*; import java.io.IOException; public class AutoRecoveryRecv { private final static String QUEUE_NAME = &amp;#34;hello&amp;#34;; public static void main(String[] argv) throws Exception { try { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(ConnectionFactoryConfiguration.HOST); factory.setUsername(ConnectionFactoryConfiguration.USERNAME); factory.setPassword(ConnectionFactoryConfiguration.PASSWORD); factory.setAutomaticRecoveryEnabled(true); factory.setNetworkRecoveryInterval(10000); Connection connection = factory.newConnection(); connection.addShutdownListener(new ShutdownListener() { @Override public void shutdownCompleted(ShutdownSignalException cause) { String hardError = &amp;#34;&amp;#34;; String applInit = &amp;#34;&amp;#34;; if (cause.isHardError()) { hardError = &amp;#34;connection&amp;#34;; } else { hardError = &amp;#34;channel&amp;#34;; } if (cause.</description></item><item><title>[RabbitMQ] 了解多个同名rabbitmq-server文件</title><link>https://mryqu.github.io/post/rabbitmq_%E4%BA%86%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8Drabbitmq-server%E6%96%87%E4%BB%B6/</link><pubDate>Fri, 12 Aug 2016 06:13:28 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_%E4%BA%86%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%90%8C%E5%90%8Drabbitmq-server%E6%96%87%E4%BB%B6/</guid><description>安装完RabbitMQ后，查了查机器中多了六个rabbitmq-server文件，除了两个位于/usr/lib/rabbitmq目录下的可以不理，其他都有什么区别呢？ 下面针对这四个文件进行一下介绍：
/etc/init.d/rabbitmq-server： RabbitMQ服务器的开机自启动脚本 /usr/sbin/rabbitmq-server： init脚本所启动的主服务器程序脚本 /etc/logrotate.d/rabbitmq-server：logrotate是个十分有用的工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。该文件是针对rabbitmq-server的logrotate配置，默认情况下logrotate每周对/var/log/rabbitmq/下的log文件进行处理。 /usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server：OCF指开放集群框架（Open Clustering Framework）。当使用pacemaker配置RabbitMQHA时，作为OCF 资源代理脚本，用于操作和监控RabbitMQ节点。OCF 规范（尤其是与资源代理相关的部分）详见在Open Clustering Framework Resource Agent API。</description></item><item><title>[RabbitMQ] 强制杀死RabbitMQ进程</title><link>https://mryqu.github.io/post/rabbitmq_%E5%BC%BA%E5%88%B6%E6%9D%80%E6%AD%BBrabbitmq%E8%BF%9B%E7%A8%8B/</link><pubDate>Thu, 11 Aug 2016 05:10:09 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_%E5%BC%BA%E5%88%B6%E6%9D%80%E6%AD%BBrabbitmq%E8%BF%9B%E7%A8%8B/</guid><description> 首先，尝试使用init.d脚本优雅关闭RabbitMQ sudo /etc/init.d/rabbitmq-server stop 如果不成功的话，使用 ps -eaf | grep erl 查看进程及父进程ID。输出第三列为父进程ID。找到仍是erlang进程（而不是启动进程的shell脚本）的第一个祖先进程，杀死它，这会同样终止其他子进程。上述示例中进程1301为&amp;quot;/bin/sh -e/usr/lib/rabbitmq/bin/rabbitmq-server&amp;quot;，已经不是erlang进程了，所以杀死进程1587就可以了。对于目前的RabbitMQ版本，可直接使用： sudo pkill beam.smp</description></item><item><title>[RabbitMQ] Hello RabbitMQ Clustering</title><link>https://mryqu.github.io/post/rabbitmq_hello_rabbitmq_clustering/</link><pubDate>Mon, 08 Aug 2016 05:58:43 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_hello_rabbitmq_clustering/</guid><description>RabbitMQ集群文档的介绍是： 一个RabbitMQ代理（broker）是一或多个Erlang节点的逻辑组合，每个节点运行RabbitMQ应用并共享用户、虚拟主机、队列、交换器、绑定和运行时参数。有时我们将节点集合称之为集群。 对RabbitMQ代理操作所需的所有数据/状态都会在所有节点上复制。唯一的例外是消息队列，默认存在于创建队列的节点上，但是对所有其他节点可见并可访问。集群内节点通过主机名互相通信，所以这些主机名必须能被集群内所有节点解析。
在Ubuntu上安装RabbitMQ 我在三台Ubuntu服务器上安装了RabbitMQ，分别是node50064，node50069和node51054。
执行下列命令将APT仓库添加到/etc/apt/sources.list.d: echo &amp;#39;deb http://www.rabbitmq.com/debian/ testing main&amp;#39; | sudo tee /etc/apt/sources.list.d/rabbitmq.list (可选地)为了避免未签名包告警，使用 apt-key将RabbitMQ网站的公钥添加到信赖密钥列表： wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add - 执行下列命令更新包列表： sudo apt-get update 安装rabbitmq-server包： sudo apt-get install rabbitmq-server 配置RabbitMQ
修改/etc/rabbitmq/enabled_plugins使能管理插件： [rabbitmq_management]. 修改/etc/default/rabbitmq-server，增大每用户可打开文件数（我的系统不使用systemd，无需修改/etc/systemd/system/rabbitmq-server.service.d/limits.conf）： ulimit -S -n 4096 修改/etc/rabbitmq/rabbitmq-env.conf，激活长主机名并使用每个主机的完整域名作为本地节点名： USE_LONGNAME=true NODENAME=rabbit@`env hostname -f` 关闭RabbitMQ：
sudo /etc/init.d/rabbitmq-server stop 配置RabbitMQ集群 首先启动node50064上的RabbitMQ（注：会有告警，可忽略。-detached选项就会导致PID不写入PID文件。）：
sudo rabbitmq-server -detached RabbitMQ节点和CLI工具(例如rabbitmqctl)使用cookie来判断节点间是否可以通信。两个能够通信的节点必须拥有相同的共享密文，称之为Erlangcookie。集群中所有节点必须拥有相同cookie。必须在node50069和node51054关闭RabbitMQ的情况下，从node50064将其cookie复制到node50069（对node51054也做相同操作）： 更省事的方式，是在node50069和node51054没有安装RabbitMQ之前就将node50064上的cookie复制过来，这样node50069和node51054上的erlang节点就不会自己生成cookie了。
手工配置集群：
ubuntu@node50069:~$sudo rabbitmq-server -detached ubuntu@node50069:~$sudo rabbitmqctl stop_app ubuntu@node50069:~$sudo rabbitmqctl join_cluster rabbit@node50064.mryqu.com ubuntu@node50069:~$sudo rabbitmqctl start_app ubuntu@node51054:~$sudo rabbitmq-server -detached ubuntu@node51054:~$sudo rabbitmqctl stop_app ubuntu@node51054:~$sudo rabbitmqctl join_cluster rabbit@node50064.</description></item><item><title>[RabbitMQ] Hello RabbitMQ</title><link>https://mryqu.github.io/post/rabbitmq_hello_rabbitmq/</link><pubDate>Sun, 07 Aug 2016 05:54:08 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_hello_rabbitmq/</guid><description>为了快速入门RabbitMQ，我主要学习了下列参考中的两个链接：RabbitMQ教程和SpringAMQP范例。这里对所学教程做一个小笔记。
准备工作 由于我不打算跑本机上的RabbitMQ服务器，所有对代码稍有修改。
TutorialConfiguration.java public class TutorialConfiguration { public static final String HOST = &amp;#34;mryqu-rabbitmq-server&amp;#34;; public static final String USERNAME = &amp;#34;mryqu&amp;#34;; public static final String PASSWORD = &amp;#34;mryqu-pwd&amp;#34;; } 对原有代码进行修改 // factory.setHost(&amp;#34;localhost&amp;#34;); factory.setHost(TutorialConfiguration.HOST); factory.setUsername(TutorialConfiguration.USERNAME); factory.setPassword(TutorialConfiguration.PASSWORD); } RabbitMQ函数 发布方和消费方首先要创建连接，通过连接创建通道。通过通道也可以声明交换器，也可以直接声明队列。
函数Exchange.DeclareOk exchangeDeclare(String exchange, Stringtype, boolean durable, boolean autoDelete, boolean internal, Maparguments)用于声明交换器。其中exchange为队列名；type为交换器类型，例如fanout、direct、header和topic，注意无法改变已存在交换器的类型；durable为true时为持久交换器，在服务器重启后仍将存在，默认为false；autoDelete为true时，当所有的消费者使用完交换器后，服务器会自动删除交换器。服务器必须为判断交换器未使用提供一个合理时延，起码允许客户端能够创建一个代理并将其与队列绑定。默认为false；internal为true时为内部交换器，客户端不能直接向其发布消息，默认为false。 函数Queue.DeclareOk queueDeclare(String queue, boolean durable,boolean exclusive, boolean autoDelete, Map arguments)用于声明队列，其中queue为队列名；durable为true时为持久队列，在服务器重启后仍将存在。默认为false；exclusive为true时为私有队列，仅在当前连接中可以访问队列，当连接关闭时删除该队列。默认为true；autoDelete为true时，当所有的消费者使用完队列后，服务器会自动删除队列。最后一个消费者可被显式取消或由于通道关闭而取消。如果队列从没有消费者，队列将不会被删除。应用可以像对普通队列一样使用Delete方法显式删除自动删除队列。默认为true。 函数Queue.BindOk queueBind(String queue, String exchange, StringroutingKey, Map arguments)用于通过路由关键字将队列与交换器进行绑定。 函数void basicPublish(String exchange, String routingKey, booleanmandatory, boolean immediate, BasicProperties props, byte[]body)用于发布者发布消息。其中exchange为交换器名；routingKey为路由关键字，使用默认交换器及命名队列时可直接设为队列名；mandatory标志告知服务器当消息无法路由到队列时如何处理。如果标志被设上，服务器通过一个Return方法返回无法路由的消息。如果标志为空，服务器就仅丢弃消息。默认为false；immediate标志告知服务器当消息无法立即路由到队列消费者时如何处理。如果标志被设上，服务器通过一个Return方法返回无法路由的消息。如果标志为空，服务器就将消息放入队列，但不保证消息最终被消费。默认为false；props可设置下列子属性（可参考com.</description></item><item><title>[RabbitMQ] 在Widnows平台安装配置RabbitMQ</title><link>https://mryqu.github.io/post/rabbitmq_%E5%9C%A8widnows%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AErabbitmq/</link><pubDate>Sat, 06 Aug 2016 05:29:19 +0000</pubDate><guid>https://mryqu.github.io/post/rabbitmq_%E5%9C%A8widnows%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AErabbitmq/</guid><description>RabbitMQ介绍 RabbitMQ是基于高级消息队列协议的消息代理软件。RabiitMQ服务器由Erlang语言开发，客户端支持多种主流编程语言。 RabbitMQ由LShift和CohesiveFT合营公司Rabbit技术有限公司开发，在2010年4月被SpringSource收购，2013年5月归入Pivotal软件。 RabbitMQ项目包括：
RabbitMQ交换服务器自身 用于HTTP、流文本定向消息协议(STOMP)和消息队列遥测传输协议(MQTT)的网关 Java、.NET Framework和Erlang语言的AMQP客户端库 支持定制插件的插件平台，内建插件集合为: Shovel插件，负责从一个消息代理（broker）向另一个移动/复制消息。 Federation插件，在消息代理之间有效共享消息(基于exchange这一级) Management插件，监控和管理消息代理 STOMP插件，提供STOMP协议支持 MQTT插件，提供MQTT协议支持 LDAP插件，RabbitMQ通过外部LDAP服务器进行认证和授权 在Widnows平台安装RabbitMQ 根据http://www.rabbitmq.com/install-windows.html安装Erlang和RabbitMQ服务器，运行RabbitMQ安装程序时需要选择“Runas Administrator”，否则事后需要执行下列命令修正.erlang.cookie位置错误。
copy /Y %SystemRoot%\.erlang.cookie %HOMEDRIVE%%HOMEPATH% 设置环境变量（及安装并启动RabbitMQ服务）
SET　ERLANG_HOME=C:\tools\erl8.0 SET RABBITMQ_SERVER＝C:\tools\RabbitMQ_Server\rabbitmq_server-3.6.5 SET　RABBITMQ_BASE=C:\rabbitmq-data ECHO []. &amp;gt; C:\rabbitmq-data\rabbitmq.config %RABBITMQ_SERVER%\sbin\rabbitmq-service.bat install %RABBITMQ_SERVER%\sbin\rabbitmq-service.bat start 安装管理插件 rabbitmq-management插件提供用于管理和监控RabbitMQ服务器的基于HTTP的API，以及基于浏览器的界面和一个控制台工具rabbitmqadmin。功能包括：
声明、列举和删除exchange、queue、binding、用户、虚拟主机和权限。 监控队列长度、消息总速率和每通道速率、连接数据速率等。 发送和接受消息。 监控Erlang进程、文件描述符和内存使用。 导出/导入对象定义到JSON格式 强制关闭连接、清除队列。 重启RabbitMQ后登录http://guest:guest@localhost:15672/，即可见到管理页面。 rabbitmqctl 通过rabbitmqctl创建一个管理员用户admin和一个对虚拟主机有读写权限的普通用户mryqu： 自建管理员用户admin的默认用户guest的区别在于：guest仅能本机访问RabbitMQ，除非在rabbitmq.config增加loopback_users设置。
使用HTTP管理API 将配置导出成JSON格式：
curl -i -u guest:guest http://localhost:15672/api/definitions 激活其他插件 例如激活shovel插件：
%RABBITMQ_SERVER%\sbin\rabbitmq-plugins.bat enable rabbitmq_shovel %RABBITMQ_SERVER%\sbin\rabbitmq-plugins.bat enable rabbitmq_shovel_management 测试RabbitMQ 使用GETTING STARTED: Messaging with RabbitMQ中的代码即可，由于我想试验非本机访问RabbitMQ，因此添加了application.properties：</description></item><item><title>消息队列技术选型资料</title><link>https://mryqu.github.io/post/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%B5%84%E6%96%99/</link><pubDate>Sat, 02 Aug 2014 21:27:49 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E8%B5%84%E6%96%99/</guid><description>Message Queue Evaluation Notes（10/01/12）
消息队列软件产品大比拼（11/05/16）
RabbitMQ / ActiveMQ or Redis for over 250,000 msg/s（11/09/27）
消息中间件的技术选型心得－RabbitMQ、ActiveMQ和ZeroMQ（13/01/07）
消息队列中间件技术选型分析（13/05/24）
谁才是最快的消息队列:ActiveMQ, RabbitMQ, HornetQ, QPID&amp;hellip;（13/12/22）
activemq-or-rabbitmq-or-zeromq-or（14/02/27）
Alibaba： 消息队列中间件调研文档（14/07/01）
Alibaba：RocketMQ 性能测试报告（14/07/01）
消息中间件选型（15/01/20）
RabbitMq、ActiveMq、ZeroMq、kafka之间的比较,资料汇总（15/08/19）
开源 VS 商业，消息中间件你不知道的那些事（15/11/25）
MQ产品比较-ActiveMQ-RocketMQ（16/03/07）</description></item><item><title>ActiveMQ集群</title><link>https://mryqu.github.io/post/activemq%E9%9B%86%E7%BE%A4/</link><pubDate>Wed, 24 Jul 2013 21:24:19 +0000</pubDate><guid>https://mryqu.github.io/post/activemq%E9%9B%86%E7%BE%A4/</guid><description>ActiveMQ Introduction ActiveMQ is an open source (Apache 2.0 licensed) message brokerwhich fully implements the Java Message Service 1.1. It providesadvanced features like clustering, multiple message stores, andability to use file systems, and databases as a JMS persistenceprovider.
ActiveMQ HA ActiveMQ support reliable high performance load balancing ofmessages on a queue across consumers. If a consumer dies, anyunacknowledged messages are redelivered to other consumers on thequeue. If one consumer is faster than the others it gets moremessages etc.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cache on Mryqu's Notes</title><link>https://mryqu.github.io/categories/cache/</link><description>Recent content in Cache on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 05 Jul 2013 21:23:00 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/categories/cache/index.xml" rel="self" type="application/rss+xml"/><item><title>动态GemFire Region使用局限</title><link>https://mryqu.github.io/post/gemfire_usage-limit-of-dynamci-region/</link><pubDate>Fri, 05 Jul 2013 21:23:00 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_usage-limit-of-dynamci-region/</guid><description>介绍 当前项目原有设计使用了嵌套的Map作为缓存。我在使用GemFire产品时使用普通region替代外层map，使用动态region替代内层map。
对于&amp;quot;/outer_region/Dimension&amp;quot;region中的条目，键是维ID（例如5），值是动态region&amp;quot;/inter_region/Dimension/5&amp;quot;. &amp;ldquo;/outer_region/Dimension&amp;rdquo; region的容量是256个条目，动态region&amp;quot;/inter_region/Dimension/5&amp;quot;的容量是10个条目。 当维#5被删除，&amp;quot;/outer_region/Dimension&amp;quot;相应条目应该删除，而动态region&amp;quot;/inter/Dimension/5&amp;quot;应该被销毁。
测试发现，当GemFire节点通过API创建了动态region后，它会将动态region列表发送给其他节点，此后的GemFire节点在创建Cache会失败。通过异常日志可知动态region会在Cache创建过程中被创建，但后继GemFire节点无法找到父region (在该节点创建Cache之前根本没机会创建****region!),这是导致失败的原因。
如果对cache使用cache-xml-file， GemFire会先创建普通region之后创建动态region。这需要将一个cache下所有region定义都放到cache-xml-file里，上述问题可能会被避免。但是一个cache被多个项目共享，所有项目的region定义放在一起的话，配置耦合度很高，对于产品的灵活性和扩展性很不利。
日志 Caused by: com.gemstone.gemfire.cache.RegionDestroyedException: Error -- Could not find a region named: &amp;#39;/inter_region/Dimension&amp;#39; at com.gemstone.gemfire.cache.DynamicRegionFactory.createDynamicRegionImpl(DynamicRegionFactory.java) at com.gemstone.gemfire.cache.DynamicRegionFactory.createDefinedDynamicRegions(DynamicRegionFactory.java) at com.gemstone.gemfire.cache.DynamicRegionFactory._internalInit(DynamicRegionFactory.java) at com.gemstone.gemfire.internal.cache.DynamicRegionFactoryImpl.internalInit(DynamicRegionFactoryImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.readyDynamicRegionFactory(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.initializeDeclarativeCache(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.init(GemFireCacheImpl.java) at com.gemstone.gemfire.internal.cache.GemFireCacheImpl.create(GemFireCacheImpl.java) at com.gemstone.gemfire.cache.CacheFactory.create(CacheFactory.java) at com.gemstone.gemfire.cache.CacheFactory.create(CacheFactory.java) at org.springframework.data.gemfire.CacheFactoryBean.createCache(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.init(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.getObject(CacheFactoryBean.java) at org.springframework.data.gemfire.CacheFactoryBean.getObject(CacheFactoryBean.java) at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java) ... 34 more</description></item><item><title>嵌套的动态GemFire region研究</title><link>https://mryqu.github.io/post/gemfire_nesting-dynamic-region/</link><pubDate>Fri, 28 Jun 2013 16:16:14 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_nesting-dynamic-region/</guid><description>研究目的和结论 研究多级动态region是否可行，结论可行 研究嵌套region(一个region是另一个region的值)是否可行，结论可行 Java代码 import java.util.Set; import com.gemstone.gemfire.cache.Cache; import com.gemstone.gemfire.cache.CacheFactory; import com.gemstone.gemfire.cache.DynamicRegionFactory; import com.gemstone.gemfire.cache.Region; public class EmbededDynamicRegion { public static void main(String[] args) { System.out.println(&amp;#34;\nConnecting to the distributed system and creating the cache.&amp;#34;); Cache cache = null; try { // Create the cache which causes the cache-xml-file to be parsed cache = new CacheFactory().set(&amp;#34;name&amp;#34;, &amp;#34;yqu_test_cache&amp;#34;) .set(&amp;#34;cache-xml-file&amp;#34;, &amp;#34;xml/YquTest.xml&amp;#34;).create(); // Get the exampleRegion Region yquRegion = cache.getRegion(&amp;#34;yqu_region&amp;#34;); printRegionFullPath(yquRegion); DynamicRegionFactory dynRegFactory = DynamicRegionFactory.get(); for(int i=0;i&amp;lt;3;i++) { Region keyRegion = dynRegFactory.</description></item><item><title>Hibernate缓存</title><link>https://mryqu.github.io/post/hibernate%E7%BC%93%E5%AD%98/</link><pubDate>Sat, 25 May 2013 09:40:06 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate%E7%BC%93%E5%AD%98/</guid><description>Hibernate缓存 Hibernate带有三种不同缓存机制：一级缓存、二级缓存和查询缓存。
SessionFactory和Session SessionFactory(在JEE中叫做EntityManager)的用途是创建会话，初始化JDBC链接并（使用例如C3P0之类的可插拔provider）进行池化。SessionFactory是非可变的，通过hibernate.cfg.cml文件或Springbean配置中提供的匹配信息、缓存信息等配置进行创建。会话是最低级的工作单元，对应一个数据库事物。当会话创建后并对Hibernate实体机型一些操作，比如设置实体的一个属性，Hibernate不会立即更新底层数据库表。相反Hibernate记录实体的状态（是否为脏数据），并在会话最终刷新更新到数据库。这就是Hibernate所谓的一级缓存。
一级缓存 一级缓存是Hibernate记录正在进行的会话加载和接触的实体有可能的脏数据状态。正在进行的会话代表工作单元，始终使用，无法关闭。一级缓存的用途是隐藏对数据库许多SQL查询或更新，并在会话最终批量一起执行。当想起一级缓存的时候就应该想到会话。
二级缓存 二级缓存是进程范围内的缓存，与一个SessionFactory绑定。二级缓存可被相同（通常一个应用程序仅一个）SessionFactory的所有会话共享。默认二级缓存没有使能。二级缓存不存储任何实体实例，而是存储“脱水”状态，即字符串或整形数组代表实体的属性，一个实体id指向“脱水”的实体。概念上可以认为它是一个映射，id作为键，数组作为值。或像下面用于缓存region的这些东西：
public class Person { private Person parent; private Set&amp;lt;Person&amp;gt; children; public void setParent(Person p) { parent = p; } public void setChildren(Set&amp;lt;Person&amp;gt; set) { children = set; } public Set&amp;lt;Person&amp;gt; getChildren() { return children; } public Person getParent() { return parent; } } Hibernate映射配置如下:
&amp;lt;class name=&amp;#34;org.javalobby.tnt.hibernate.Person&amp;#34;&amp;gt; &amp;lt;cache usage=&amp;#34;read-write&amp;#34;/&amp;gt; &amp;lt;id name=&amp;#34;id&amp;#34; column=&amp;#34;id&amp;#34; type=&amp;#34;long&amp;#34;&amp;gt; &amp;lt;generator class=&amp;#34;identity&amp;#34;/&amp;gt; &amp;lt;/id&amp;gt; &amp;lt;property name=&amp;#34;firstName&amp;#34; type=&amp;#34;string&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;middleInitial&amp;#34; type=&amp;#34;string&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;lastName&amp;#34; type=&amp;#34;string&amp;#34;/&amp;gt; &amp;lt;many-to-one name=&amp;#34;parent&amp;#34; column=&amp;#34;parent_id&amp;#34; class=&amp;#34;Person&amp;#34;/&amp;gt; &amp;lt;set name=&amp;#34;children&amp;#34;&amp;gt; &amp;lt;key column=&amp;#34;parent_id&amp;#34;/&amp;gt; &amp;lt;one-to-many class=&amp;#34;Person&amp;#34;/&amp;gt; &amp;lt;/set&amp;gt; &amp;lt;/class&amp;gt; Hibernate概念上为此类持有如下记录:</description></item><item><title>使用GemFire做Mybatis/Hibernate二级缓存</title><link>https://mryqu.github.io/post/gemfire_as-l2-cache-of-mybatis-and-hibernate/</link><pubDate>Wed, 22 May 2013 09:12:27 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_as-l2-cache-of-mybatis-and-hibernate/</guid><description>使用GemFire做Mybatis二级缓存 MyBatis支持第三方二级缓存实现，目前支持Ehcache、Hazelcast和OSCache。 GemFire不在支持的范围，但是可以通过实现org.apache.ibatis.cache.Cache接口来使用。
MyBatis的Cache配置及实现 设置MyBatis的Cache全局使用开关：默认是true，如果它配成false，其余各个MapperXML文件配成支持cache也没用。
&amp;lt;settings&amp;gt; &amp;lt;setting name=&amp;#34;cacheEnabled&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;/settings&amp;gt; 各个Mapper XML文件，默认是不采用cache。在配置文件加一行就可以支持cache：
&amp;lt;cache /&amp;gt; 实现GemfireCache
package com.yqu.mybatis.caches.gemfire; import com.gemstone.gemfire.cache.AttributesFactory; import com.gemstone.gemfire.cache.CacheFactory; import com.gemstone.gemfire.cache.Region; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; import org.apache.ibatis.cache.Cache; import org.apache.ibatis.cache.CacheException; public final class GemfireCache implements Cache { private static Region&amp;lt;object&amp;gt; mybatis_region = null; private Region&amp;lt;object&amp;gt; region = null; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public void setId(String id) { this.id = id; } public void setRegion(Region&amp;lt;object&amp;gt; region) { this.</description></item><item><title>Java缓存规范JCache API(JSR107)</title><link>https://mryqu.github.io/post/java%E7%BC%93%E5%AD%98%E8%A7%84%E8%8C%83jcache_apijsr107/</link><pubDate>Wed, 22 May 2013 07:13:07 +0000</pubDate><guid>https://mryqu.github.io/post/java%E7%BC%93%E5%AD%98%E8%A7%84%E8%8C%83jcache_apijsr107/</guid><description>今天看了一下Java缓存规范JCacheAPI（JSR107），它对Java对象缓存进行标准化，方便高效开发，让程序员摆脱实现缓存有效期、互斥、假脱机（spooling）和缓存一致性等负担。该规范提供了API、RI（参考实现）和TCK（技术兼容性套件）。 从设计的角度看，基本组成部分有一个CacheManager，用来持有、控制缓存集合。缓存里存放键值对条目。 整个规范包括了如下内容：
支持原子操作的缓存读写 缓存事件监听器 统计 事务 注解 JSR107从2001年开始，中间搁置了一段时间，后来Terracotta（产品：EhCache）和Oracle（产品：Coherence）在2010年加强了对JSR-107的投入，原本有望放入JAVAEE7(JSR342)中，可惜在期限内完不成，直到2012年底才推出了草案。 我更关注数据网格（JSR347），那个是JSR107的超集，关注缓存的逐出、复制和分布化，以及事务。可惜连草案也还没影呢。 http://jcp.org/en/jsr/detail?id=107
http://jcp.org/en/jsr/detail?id=347</description></item><item><title>GemFire 数据逐出和持久化</title><link>https://mryqu.github.io/post/gemfire_data-eviction-and-persistence/</link><pubDate>Fri, 17 May 2013 15:48:33 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_data-eviction-and-persistence/</guid><description>为什么逐出数据? 如果有多于JVM内存的数据想放入Region，数据逐出是可能使用的一种解决方案。 一种备选方案是对数据进行分区。然而分区Region也可能无法将所有数据放入内存，所以有可能需要对分区Region采用数据逐出。 另一种备选方案是让数据过一定期限后从内存删除，这是基于时间而不是空间的一种方案。
数据逐出如何工作？ 当使用数据逐出时需要决定所采用的算法和动作。 算法规定了需要检查的所耗费资源的最大值，可为基于条目数量、内存消耗字节数和可用堆消耗百分比的LRU（最近最少使用）算法。
条目数量和绝对内存消耗量完全由GemFire逐出控制器基于Region级别进行管理。EntryLRU是最简单的算法，适用于每个条目消耗相同大小的内存。Memory LRU则适用于每个条目消耗不同大小的内存。 Heap消耗百分比由GemFire逐出控制器基于缓存级别进行管理。最大值设置在管理器配置的缓存下配置。当管理器断定需要进行数据逐出时，它命令逐出控制器对所有逐出算法设为lru-heap-percentage的region采取数据逐出，直到管理器停止这一命令。注意的是，当其他非LRU资源甚至非GemFire缓存消耗内存时，这一算法也会导致HeapLRUregion的数据逐出。 对于一个region，数据逐出操作会逐出最近最少使用到的条目。几乎所有操作（包括读写）都认为是对条目的使用，除了以下的操作：
Region.containsKey Region.containsValue Region.getEntry 当使用MemoryLRU或HeapLRU算法时需要实现ObjectSizer接口。这让GemFire可以调用自己的代码来计算条目的字节大小。让条目大小估算精确很重要，但同时需要注意的是复杂ObjectSize实现会花费较长时间并导致性能下降。如果条目的所有值都是String或byte[]类型，GemFire会自动计算内存大小，无须实现ObjectSizer。
分区Region在数据逐出的不同之处 对于分区region，基于条目数量和内存消耗量的逐出行为当节点数据超过本地缓存主副本和冗余副本组合的限制后发生。对于基于堆消耗百分比的逐出行为由管理器驱动。 因为维护整个分区region或者同一节点所有桶（bucket）的LRU条目信息代价太大，GemFire是基于桶来维护LRU条目信息的。此外，对分区region的所有桶施行数据组出会导致数据分布失衡。 因此，对分区region进行的数据逐出可能会保留相对本地节点其他桶或其他分布系统节点相对更老的条目。它可能在主副本中保留条目而在第二副本中逐出条目，或者相反。 LRU逐出对每个桶单独进行:
对基于内存和条目数的数据逐出，LRU逐出在操作新条目时有可能执行，直到Region的桶组合整体内存下降到门限下结束。对于内存逐出，分区region最大内存门限会忽略lru-memory-size设置，始终是local-max-memory。 对于基于堆的数据逐出，每个分区region桶被当作单独region来处理，每个逐出动作仅考虑桶内的LRU，而不是整体分区region。 动作为本地删除条目的数据逐出无法用于复制region，因为不允许对复制分区进行本地写操作，这会违反所有数据在复制分区都可见的契约。如果需要使用本地删除条目的数据逐出，可以考虑使用预加载数据策略，其行为在初始化时与复制分区相同并允许动作为本地删除条目的数据逐出。
数据无持久化 数据持久化 EvictionAction.NONE 条目将在内存中一直保存。 条目将在内存和磁盘中一直保存。 EvictionAction.LOCAL_DESTROY 条目（键和值两部分）将从内存中释放。仅当被逐出数据可从外部数据源加载时可用。 EvictionAction.OVERFLOW_TO_DISK 条目将被逐出到磁盘但是不会持久化 (当缓存关闭时磁盘文件将被删除)，条目的键部分始终在内存中保存。 条目(键和值两部分)一直在磁盘中保存。条目的值部分将被逐出，键部分始终在内存中保存。 磁盘存储文件名和扩展名 磁盘存储文件包括存储管理、访问控制文件和操作日志（oplog，记录了删除和其他所有操作）。下面的表描述了文件名和扩展名及示例。
文件名 文件名包括三部分:
第一部分: 使用标识 值 用途 示例 OVERFLOW 仅为溢出region和队列的操作日志数据。 OVERFLOWoverflowDS1_1.crf BACKUP 持久化、持久化+溢出rgion和队列操作日志数据。 BACKUPoverflowDS1.if, BACKUPDEFAULT.if DRLK_IF 访问控制 - 对磁盘存储上锁。 DRLK_IFoverflowDS1.lk, DRLK_IFDEFAULT.lk 第二部分: 磁盘存储名 值 用途 示例 &amp;lt;磁盘存储名&amp;gt; 非默认磁盘存储。 name=&amp;ldquo;overflowDS1&amp;rdquo; DRLK_IFoverflowDS1.lk,
name=&amp;ldquo;persistDS1&amp;rdquo; BACKUPpersistDS1_1.crf DEFAULT 默认磁盘存储名，当对region或队列指定持久化或溢出但没有命名磁盘存储时使用。 DRLK_IFDEFAULT.lk, BACKUPDEFAULT_1.</description></item><item><title>GemFire查询</title><link>https://mryqu.github.io/post/gemfire_query/</link><pubDate>Wed, 15 May 2013 07:30:01 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_query/</guid><description>GemFire在region中存储的数据为键值对，其中值可以为任何对象，例如简单的字节数组或者复杂的嵌套对象。GemFire提供了一种查询机制可以获得满足特定条件的键、值或条目集合。GemFire支持的查询语义和语法是OQL（对象查询语言）的一个子集。OQL是由对象数据管理组制定的ODMG3.0对象模型的重要组件之一，与SQL很相似，可以查询复杂对象、对象属性和方法，支持完整的ASCII和Unicode字符集。 为了提高查询执行效率，GemFire像数据库一样支持索引。在查询执行时，查询引擎使用数据存储上的索引可以减少查询处理时间。查询是GemFire很强大的功能，但它也需要大量性能优化和容量规划也确保不拖垮系统。
Region存储示例 本文的查询示例基于类Porfolio和Positon的对象。
Portfolio.java package query; import java.io.DataInput; import java.io.DataOutput; import java.io.IOException; import java.io.Serializable; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import com.gemstone.gemfire.DataSerializable; import com.gemstone.gemfire.DataSerializer; public class Portfolio implements Serializable, DataSerializable { private int ID; public String pkid; public Position position1; public Position position2; public String description; public HashMap positions = new HashMap(); String type; public String status; public String [] names={&amp;#34;aaa&amp;#34;,&amp;#34;bbb&amp;#34;,&amp;#34;ccc&amp;#34;,&amp;#34;ddd&amp;#34;}; public int getID() { return ID; } public String getPk() { return pkid; } public HashMap getPositions() { return positions; } public Position getP1() { return position1; } public Position getP2() { return position2; } public boolean isActive() { return status.</description></item><item><title>GemFire Region分类</title><link>https://mryqu.github.io/post/gemfire_region-type/</link><pubDate>Wed, 15 May 2013 07:28:53 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_region-type/</guid><description>GemFire开发指南6.5的第4.2节仅列举了分区、复制（分布式）、分布式（非复制）和本地四种Region类型，但RegionShortcut类却定义了23个快捷预定义属性Region。Region的主要行为取决于数据策略、关注策略、范围、本地最大内存和冗余拷贝数（仅用于分区Region）、逐出算法和动作。
Region快捷预定义属性 数据策略 范围 本地最大内存注1 冗余拷贝数注1 逐出算法 逐出动作 LOCAL NORMAL LOCAL LOCAL_HEAP_LRU NORMAL LOCAL LRU_HEAP LOCAL_DESTROY LOCAL_OVERFLOW NORMAL LOCAL LRU_HEAP OVERFLOW_TO_DISK LOCAL_PERSISTENT PERSISTENT_REPLICATE LOCAL LOCAL_PERSISTENT_OVERFLOW PERSISTENT_REPLICATE LOCAL LRU_HEAP OVERFLOW_TO_DISK PARTITION PARTITION PARTITION_HEAP_LRU PARTITION LRU_HEAP LOCAL_DESTROY PARTITION_OVERFLOW PARTITION LRU_HEAP OVERFLOW_TO_DISK PARTITION_PERSISTENT PERSISTENT_PARTITION PARTITION_PERSISTENT_OVERFLOW PERSISTENT_PARTITION LRU_HEAP OVERFLOW_TO_DISK PARTITION_PROXY PARTITION 0 PARTITION_PROXY_REDUNDANT PARTITION 0 1 PARTITION_REDUNDANT PARTITION 1 PARTITION_REDUNDANT_HEAP_LRU PARTITION 1 LRU_HEAP LOCAL_DESTROY PARTITION_REDUNDANT_OVERFLOW PARTITION 1 LRU_HEAP OVERFLOW_TO_DISK PARTITION_REDUNDANT_PERSISTENT PERSISTENT_PARTITION 1 PARTITION_REDUNDANT_
PERSISTENT_OVERFLOW PERSISTENT_PARTITION 1 LRU_HEAP OVERFLOW_TO_DISK REPLICATE REPLICATE DISTRIBUTED_ACK REPLICATE_HEAP_LRU PRELOAD DISTRIBUTED_ACK LRU_HEAP LOCAL_DESTROY REPLICATE_OVERFLOW REPLICATE DISTRIBUTED_ACK LRU_HEAP OVERFLOW_TO_DISK REPLICATE_PERSISTENT PERSISTENT_REPLICATE DISTRIBUTED_ACK REPLICATE_PERSISTENT_OVERFLOW PERSISTENT_REPLICATE DISTRIBUTED_ACK LRU_HEAP OVERFLOW_TO_DISK REPLICATE_PROXY EMPTY DISTRIBUTED_ACK 注1：仅用于分区region</description></item></channel></rss>
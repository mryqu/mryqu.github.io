<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gradle on Mryqu's Notes</title><link>https://mryqu.github.io/categories/gradle/</link><description>Recent content in Gradle on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 20 Nov 2019 21:15:17 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/categories/gradle/index.xml" rel="self" type="application/rss+xml"/><item><title>Gradle：解决error: unmappable character for encoding GBK</title><link>https://mryqu.github.io/post/gradle_%E8%A7%A3%E5%86%B3error-unmappable-character-for-encoding-gbk/</link><pubDate>Wed, 20 Nov 2019 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%A7%A3%E5%86%B3error-unmappable-character-for-encoding-gbk/</guid><description>在学习某个项目时，.\gradlew build总是遇到error: unmappable character for encoding GBK。至少确定源文件至少会是UTF8的，所以尝试设置文件编码格式来解决这个问题。
一般使用javac编译和java执行程序时，可以使用：
javac -encoding UTF-8 Test.java java -Dfile.encoding=UTF-8 Test 对于Gradle项目，可以设置gradlew.bat:
set DEFAULT_JVM_OPTS=&amp;#34;-Dfile.encoding=UTF-8&amp;#34; 对于IntelliJ Idea，可在配置文件vmoption文件底部添加一行：
-Dfile.encoding=UTF-8 经过上述尝试，问题依旧存在，仔细一看错误是发生在javadoc任务阶段，一个java文件注释中包含一个字符“ß”导致这个问题的出现。
在build.gradle文件中添加：
javadoc { options.encoding = &amp;#39;UTF-8&amp;#39; } 搞定！！！</description></item><item><title>[Gradle] 遭遇 Unable to process incoming event 'ProgressComplete' (ProgressCompleteEvent)</title><link>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</link><pubDate>Thu, 30 Nov 2017 06:08:53 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</guid><description>最近开始玩一个项目，结果gradle build总是报错：
FAILURE: Build failed with an exception. * What went wrong: Unable to process incoming event &amp;#39;ProgressComplete &amp;#39; (ProgressCompleteEvent) 参考了帖子Build fails with “Unable to process incoming event ‘ProgressComplete ’ (ProgressCompleteEvent)”：
The Workaround: use the --console plain gradle command line switch The Fix: If you use git + git-bash, upgrade to git 2.x.x (2.9.3 is current and works for me) If you use DOS, try increasing your screen buffer size.(mine is 1024 x 1024) 将Git Window从2.</description></item><item><title>玩一下uptodate-gradle-plugin插件</title><link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</link><pubDate>Fri, 03 Mar 2017 05:57:34 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</guid><description>玩了一下uptodate-gradle-plugin插件，使用这个插件后执行 gradle uptodate 可以看到那些库在Maven Central仓库有新版本，用于辅助判断是否需要更新Java库。 我一般不追新库，所以这个插件对我的用处小，看一看玩一玩，仅此而已。</description></item><item><title>[Gradle] 将多项目转换成Maven项目</title><link>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</link><pubDate>Fri, 02 Sep 2016 05:46:07 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</guid><description>手头有一个构建多项目的Gradle构建脚本，但是一个哥们问我能不能换成Maven的，搜到一篇gradle项目与maven项目相互转化，照着实践，证明多项目构建也是可行的。
文件结构介绍 ts-demo目录 setting.gradle build.gradle ts-service目录 build.gradle src目录 ts-webapp目录 build.gradle src目录 ts-demo/setting.gradle rootProject.name = &amp;#39;ts-demo&amp;#39; include &amp;#34;ts-service&amp;#34; include &amp;#34;ts-webapp&amp;#34; project(&amp;#34;:ts-service&amp;#34;).name = &amp;#34;ts-service&amp;#34; project(&amp;#34;:ts-webapp&amp;#34;).name = &amp;#34;ts-webapp&amp;#34; ts-demo/build.gradle buildscript { repositories { mavenCentral() } } allprojects { apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;maven&amp;#39; repositories { mavenCentral() } group = &amp;#39;com.yqu&amp;#39; version = &amp;#39;0.1.0&amp;#39; task writeNewPom { pom { project { inceptionYear &amp;#39;2016&amp;#39; licenses { license { name &amp;#39;The Apache Software License, Version 2.</description></item><item><title>[Gradle] 创建含有依赖库的jar文件</title><link>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 18 Oct 2015 05:54:13 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</guid><description>想把自己的Gradle项目打成jar文件，但是&amp;rsquo;gradle build jar&amp;rsquo;生成的jar文件不含依赖库。
按照Gradle – Create a Jar file with dependencies改写了自己的build.gradle，成功包含了依赖库。但是依赖库不再是原来的jar文件，而是以目录的形式存在。
我的build.gradle
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloTwitter4J&amp;#39; version = &amp;#39;0.1.0&amp;#39; } task fatJar(type: Jar) { baseName = &amp;#39;HelloTwitter4J-all&amp;#39; version = &amp;#39;0.1.0&amp;#39; manifest { attributes &amp;#34;Main-Class&amp;#34;: &amp;#34;com.yqu.cdfwebtool.twitter.TwitterRateInfo&amp;#34; } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } with jar } repositories { mavenCentral() } sourceCompatibility = 1.</description></item><item><title>Gradle代理配置</title><link>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 31 Aug 2015 05:46:52 +0000</pubDate><guid>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>HTTP代理配置 gradlew -Dhttp.proxyHost=[myServer] -Dhttp.proxyPort=[myPort] -Dhttp.proxyUser=[myUser] -Dhttp.proxyPassword=[myPassword] HTTPS代理配置 gradlew -Dhttps.proxyHost=[myServer] -Dhttps.proxyPort=[myPort] -Dhttps.proxyUser=[myUser] -Dhttps.proxyPassword=[myPassword]</description></item><item><title>[Gradle] 列举插件</title><link>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 27 Jul 2015 06:17:30 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</guid><description>下列方法可以列举出当前build.gradle牵涉的插件:
project.plugins.each { println it }</description></item><item><title>Gradle Docker Plugin介绍</title><link>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 Jul 2015 05:57:33 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</guid><description>gradle-docker-plugin gradle-docker-plugin是由《Gradle实战》作者BenjaminMuschko实现的Gradle插件，用来管理Docker镜像和容器。gradle-docker-plugin实际上包括两个插件：
com.bmuschko.docker-remote-api:提供通过远程API与Docker进行交互的定制任务 com.bmuschko.docker-java-application:为Java应用创建和上传Docker镜像 build.gradle buildscript { repositories { jcenter() } dependencies { classpath &amp;#39;com.bmuschko:gradle-docker-plugin:2.4.1&amp;#39; } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-java-application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-remote-api&amp;#39; 参考 GitHub：bmuschko/gradle-docker-plugin</description></item><item><title>执行Gradle artifactoryPublish任务时碰到HTTP 409 Conflict错误</title><link>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</link><pubDate>Mon, 13 Jul 2015 06:10:00 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</guid><description>这篇博文算是《尝试Artifactory》的姐妹篇。我打算将《尝试Artifactory》中的&amp;rsquo;libs-snapshot-local&amp;rsquo;和&amp;rsquo;libs-snapshot&amp;rsquo;换成&amp;rsquo;libs-release-local&amp;rsquo;和&amp;rsquo;libs-release&amp;rsquo;，以便将我的构件发布到发布版仓库里。结果遭遇如下错误：
C:\test123\HelloArtifactory&amp;gt;gradlew artifactoryPublish [buildinfo] Not using buildInfo properties file for this build. :generatePomFileForMavenJavaPublication :compileJava 查看Artifactory日志，才知道根本原因在于创建的是SNAPSHOT而libs-release-local只处理发布版构建。The repository &amp;rsquo;libs-release-local&amp;rsquo; rejected the artifact&amp;rsquo;libs-release-local:com/yqu/HelloArtifactory/0.1.0-SNAPSHOT/HelloArtifactory-0.1.0-SNAPSHOT.jar&amp;rsquo;due to its snapshot/release handling policy。 解决方案有如下两种：
修改libs-release-local属性，勾选Handle Snapshots选择框（工作流不正规啦） 将gradle.properties中的version由0.1.0-SNAPSHOT改成0.1.0即可</description></item><item><title>Gradle Git Plugin介绍</title><link>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Sun, 12 Jul 2015 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</guid><description>Grgit和gradle-git Git是一个很流行的分布式版本管理工具。能在构建过程中与Git进行交互，可以提供更强大和更一致的结果。
JGit提供了与Git仓库交互的强大JavaAPI。然而，在Groovy上下本使用它会笨重，需要在所要执行的表达式包一堆换七八糟的东东。Grgit是Andre wOberstar实现的JGit封装器，为基于Groovy的工具与Git仓库交互提供了更简洁流畅的API。 gradle-git同样是由Andrew Oberstar实现的一系列Gradle插件：
org.ajoberstar.grgit - 提供一个Grgit实例，允许与Gradle项目所在的Git仓库交互 org.ajoberstar.github-pages - 向Github仓库的gh-pages分支发布文件 org.ajoberstar.release-base -提供用于从项目状态和所在Git仓库推断当前项目版本和创建新版本的通用结构 org.ajoberstar.release-opinion -用于org.ajoberstar.release-base的默认选项，遵从语义版本控制（Semantic Versioning）下面是一个Gradle任务示例，用于从Git仓库克隆项目。 build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;org.ajoberstar:gradle-git:1.2.0&amp;#39; } } import org.ajoberstar.gradle.git.tasks.* task cloneGitRepo(type: GitClone) { def destination = file(&amp;#34;destination_folder&amp;#34;) uri = &amp;#34;your_git_repo_uri&amp;#34; destinationPath = destination bare = false enabled = !destination.exists() //to clone only once } 参考 GitHub：ajoberstar/gradle-git
GitHub：ajoberstar/grgit</description></item><item><title>[Gradle] buildScript块与allprojects块及根级别的repositories区别</title><link>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 29 Jun 2015 00:03:59 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</guid><description>一直对为什么buildScript块里定义了repositories而allprojects段或根还定义repositories没有思考过，偶然有了念头想要探究一下。
build.gradle：
buildscript { repositories { ... } dependencies { ... } } allprojects { repositories { ... } dependencies { ... } }repositories { ... } dependencies { ... } buildScript块主要是为了Gradle脚本自身的执行，获取脚本依赖插件。我在写的一篇博客《尝试Artifactory》中Gradle脚本需要com.jfrog.artifactory插件才能执行成功，而这个插件是从URL为https://plugins.gradle.org/m2/的Maven仓库获得。 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。 allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。
参考 What&amp;rsquo;s the difference between buildscript and allprojects in build.gradle?
Gradle buildscript dependencies
Gradle: Project</description></item><item><title>玩一下gradle-jvmsrc-plugin</title><link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</link><pubDate>Wed, 27 May 2015 05:51:01 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</guid><description>玩了一下gradle-jvmsrc-plugin插件，使用这个插件后执行gradlecreateJvmSrcDirs可以根据Gradle项目的JVM语言插件（(java、groovy、scala、android等），自动创建默认的源代码、测试和资源包目录。例如：
src/main/resources src/main/java/ src/main/groovy/ src/test/java/ src/test/groovy/ src/test/resources 刚上手总是报错，看了一下CreateJvmSourceDirs.groovy，定位到packageToDirectoryPath方法：
* What went wrong: Execution failed for task &amp;#39;:HelloJvmsrc:createJvmSrcDirs&amp;#39;. &amp;gt; character to be escaped is missing 按照如下gradle-jvmsrc-plugin的说明，要配置基础包名。可是真按它介绍的带有.分割的包名就会出错，简单改成&amp;quot;com&amp;quot;这种没有.分割的包名就可以避免错误。
jvmsrc { packageName &amp;#34;com.mycompany.myproject.mymodule&amp;#34; } 此外，gradle-jvmsrc-plugin对空目录默认生成.gitkeep文件。 总体来说，用处不是很大，可以偷点懒！</description></item><item><title>[Gradle] 在子项目中共享项目属性</title><link>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</link><pubDate>Fri, 22 May 2015 06:09:34 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</guid><description>build.gradle:
buildscript { repositories { mavenCentral() } } subprojects { apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 ext { HadoopVersion = &amp;#39;2.7.x&amp;#39; JUnitVersion = &amp;#39;4.11&amp;#39; ...... } } HelloHadoopClient/build.gradle：
jar { baseName = &amp;#39;hello-hadoopclient&amp;#39; version = &amp;#39;0.1.0&amp;#39; } dependencies { compile &amp;#34;org.apache.hadoop:hadoop-common:${HadoopVersion}&amp;#34; testCompile &amp;#34;junit:junit:${JUnitVersion}&amp;#34; } HelloMapReduce/build.gradle：
jar { baseName = &amp;#39;hello-mapreduce&amp;#39; version = &amp;#39;0.1.0&amp;#39; } dependencies { compile &amp;#34;org.</description></item><item><title>[Gradle] 输出依赖包</title><link>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</link><pubDate>Thu, 16 Apr 2015 06:13:52 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</guid><description>下面我以https://spring.io/guides/gs/spring-boot/中的gs-spring-boot项目为例，使用Gradle输出依赖包。
首先对build.gradle做如下修改：
buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; jar { baseName = &amp;#39;gs-spring-boot&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 task copyToLib(type: Copy) { print configurations into &amp;#34;$buildDir/dep-libs&amp;#34; from configurations.runtime } build.dependsOn(copyToLib) dependencies { compile(&amp;#34;org.springframework.boot:spring-boot-starter-web&amp;#34;) // tag::actuator[] compile(&amp;#34;org.springframework.boot:spring-boot-starter-actuator&amp;#34;) // end::actuator[] // tag::tests[] testCompile(&amp;#34;org.springframework.boot:spring-boot-starter-test&amp;#34;) // end::tests[] } 首先可以在命令行中看到：</description></item><item><title>[Gradle] 执行Java类</title><link>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</link><pubDate>Wed, 15 Apr 2015 18:32:08 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</guid><description>需求 我想用Gradle脚本执行下列Java类Hello123.java：
import java.util.Arrays; public class Hello123 { public static void main(String[] args) { System.out.println(&amp;#34;args:&amp;#34;+ Arrays.toString(args)); } } 测试一：创建execute任务 build.gralde apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; task execute(type: { main = System.getProperty(&amp;#34;exec.mainClass&amp;#34;) classpath = sourceSets.main.runtimeClasspath systemProperties System.getProperties() if(System.getProperty(&amp;#34;exec.args&amp;#34;)) args System.getProperty(&amp;#34;exec.args&amp;#34;).split() } sourceCompatibility = 1.8 targetCompatibility = 1.8 测试结果 测试二：重写run任务 build.gralde apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#34;application&amp;#34; mainClassName = &amp;#34;NonExistentClass&amp;#34; task run (type: { main = System.</description></item><item><title>[Gradle] 阻止build任务执行测试任务</title><link>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</link><pubDate>Tue, 14 Apr 2015 05:53:30 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</guid><description>在执行gradle build时想要阻止执行测试任务，方法如下：
第一种方法：如Gradle用户指南的14.8 Skipping tasks所说，在build.gradle里设置&amp;quot;test.enabled=false&amp;quot;，执行gradle build 第二种方法：在build.gradle里设置&amp;quot;check.dependsOn.remove(test)&amp;quot;，执行gradle build 第三种方法：执行gradle build -x test</description></item><item><title>[Gradle] 强制重新下载依赖</title><link>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</link><pubDate>Mon, 13 Apr 2015 05:49:35 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</guid><description>强制Gradle重新下载依赖的方式有两种：
在Gradle命令中加入&amp;ndash;refresh-dependencies选项。该选项会让Gradle忽略已解析模块和构件的所有缓存项，对所配置的仓库重新进行解析，动态计算版本、更新模块和下载构件。 删除Gralde的缓存目录~/.gradle/caches。这个有点过于粗暴。 示例：
gradlew clean --refresh-dependencies build bootRun</description></item><item><title>学习Gradle</title><link>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</link><pubDate>Sun, 12 Apr 2015 00:08:35 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</guid><description>当前参与的SAS Workflow2.0原型开发项目，美国那边的项目组经营将代码编译脚本从Ant切换成Gradle了。此外我司已经在去年就将Gradle列入了技术雷达的正式采用象限，感觉有必要学习一下Gradle，扩充自己的开发能力。 Gradle官网上提供的图书信息链接中有两本免费O&amp;rsquo;Reilly出版社图书：
Building and Testing With Gradle Gradle Beyond the Basics一般软件官网文档质量不错的情况下，我优先阅读最新的官网文档，所以我先看了《Gradle入门》和《Gradle用户指南》。 参考 Gradle官网 Gradle文档 Spring提供的Gradle入门 Gradle用户指南 Groovy官网 Groovy++ Java Build Tools: Ant vs Maven vs Gradle</description></item><item><title>[Gradle] 设置项目属性的三种方式</title><link>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Tue, 07 Apr 2015 05:36:16 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>命令行 gradle bootRun -PyquPropKey=yquPropValue build.properties yquPropKey=yquPropValue gradle.properties 添加ext块：
ext { yquPropKey=yquPropValue }</description></item><item><title>[Gradle] 在build.gradle中添加本地包依赖</title><link>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</link><pubDate>Wed, 16 Apr 2014 22:17:45 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</guid><description>一直在Gradle中用的依赖包都是来自仓库，头一次添加本地包依赖。
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloAlgs&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { runtime files(&amp;#39;libs/algs4.jar&amp;#39;) } task wrapper(type: Wrapper) { gradleVersion = &amp;#39;2.3&amp;#39; }</description></item></channel></rss>
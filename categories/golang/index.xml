<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Mryqu's Notes</title><link>https://mryqu.github.io/categories/golang/</link><description>Recent content in Golang on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 25 Oct 2017 06:06:40 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>[GoLang]add proxy for dep</title><link>https://mryqu.github.io/post/golang_add_proxy_for_dep/</link><pubDate>Wed, 25 Oct 2017 06:06:40 +0000</pubDate><guid>https://mryqu.github.io/post/golang_add_proxy_for_dep/</guid><description>玩一下goquery，dep总是报错，无法解析golang.org/x/net和cascadia，添加代理后搞定。
Windows set https_proxy=http://username:password@[proxy_host]:[proxy_port] set http_proxy=http://username:password@[proxy_host]:[proxy_port] dep init -v Linux $https_proxy=http://username:password@[proxy_host]:[proxy_port] http_proxy=http://username:password@[proxy_host]:[proxy_port] dep init -v</description></item><item><title>[Golang] 折腾一下Golang项目调试</title><link>https://mryqu.github.io/post/golang_%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%8Bgolang%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95/</link><pubDate>Tue, 24 Oct 2017 05:59:46 +0000</pubDate><guid>https://mryqu.github.io/post/golang_%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%8Bgolang%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95/</guid><description>想装个MinGW-W64玩玩64位GDB，才发现继上一博文MinGW安装和使用已三年了，不经意间到看到了下列帖子：
MinGW MinGW-w64 TDM-GCC等工具链之间的区别与联系 发现个新环境msys2 MinGW、MinGW-w64 与TDM-GCC 应该如何选择？ 对于mingw-w64、tdm-gcc、Win-builds这三个小纠结一会，觉得自己本身也就是用一下GDB，还是去https://sourceforge.net/projects/mingw-w64/直接下载MinGW-W64好了。
MinGW-W64安装 所用MinGW-W64安装配置：
配置项 配置值 Architecture x86_64 Threads posix Exception seh Golang项目编译 编译Golang项目采用 go build -gcflags “-N -l” 关闭内联优化。
GDB调试 载入runtime-gdb.py脚本以对Go运行时结构进行完美打印和转换(例如显示slice和map值、查看goroutine等)：
参数载入：gdb -d $GCROOT 手工载入：source C:\Go\src\runtime\runtime-gdb.py 折腾一会，最后还是折在GDB on windows with golang: buildsym_init Assertion &amp;ldquo;free_pendings == NULL&amp;rdquo; failed.这个问题上，一调试就DDB崩了，貌似目前无解。 Delve调试 不过Debugging Go Code with GDB里还介绍了另外一个对Golang支持更好的工具Delve。 上手容易，有些命令跟GDB差不多。 好了，就折腾到这里了。目前不太需要的东东就不花费力气了。</description></item><item><title>[Golang] 使用dep</title><link>https://mryqu.github.io/post/golang_%E4%BD%BF%E7%94%A8dep/</link><pubDate>Sun, 22 Oct 2017 06:00:25 +0000</pubDate><guid>https://mryqu.github.io/post/golang_%E4%BD%BF%E7%94%A8dep/</guid><description>之前的博文[Golang]Win10下Glide的安装和使用记录了对Glide的学习，本博将记录对Golang包管理工具dep的学习使用。
dep介绍 在2012年，go get成为获取依赖包的方式。dep的FAQ中有一段描述dep是否要取代go get的解答，一句话概括就是：依赖管理工具是为应用管理代码的，go get是为GOPATH管理代码的。go get仅仅支持获取master branch上的latest代码，没有指定version、branch或revision的能力。这不符合gopher对自己项目所依赖的第三方包受控的期望。 在2015年，Russ Cox在Go 1.5发布前期以一个experiment feature身份紧急加入vendor机制，vendor标准化了项目依赖的第三方库的存放位置，隔离不同项目依赖的同一个包的不同版本。 Golang的包管理一直没有官方统一的解决方案，因此也产生了很多非官方的包管理工具。这些工具很多都很不错，但是相互兼容性差。随着Go语言在全球范围内应用的愈加广泛，缺少官方包管理工具这一问题变得日益突出。2016年GopherCon大会后，由微服务框架go-kit作者Peter Bourgon牵头， 在Go官方的组织下，Go包管理委员会经过各种头脑风暴和讨论后发布了“包管理建议书”，并启动了最有可能被接纳为官方包管理工具的项目dep的设计和开发。当前主导dep开发的是Sam Boyer，Sam也是dep底层包依赖分析引擎-gps的作者。2017年年初，dep项目正式对外开放。
安装 我的实验平台是Win10，所以无法通过brew或者shell脚本安装，只能通过go get安装：
go get -u github.com/golang/dep/cmd/dep 安装完，执行dep命令，出现帮助代表安装成功。
$ dep Dep is a tool for managing dependencies for Go projects Usage: &amp;#34;dep [command]&amp;#34; Commands: init Set up a new Go project, or migrate an existing one status Report the status of the project&amp;#39;s dependencies ensure Ensure a dependency is safely vendored in the project prune Pruning is now performed automatically by dep ensure.</description></item><item><title>[Golang] Go项目的国际化</title><link>https://mryqu.github.io/post/golang_go%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96/</link><pubDate>Sat, 21 Oct 2017 06:34:41 +0000</pubDate><guid>https://mryqu.github.io/post/golang_go%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96/</guid><description>因为我看的那些书里都没有提及Go项目的国际化实现，但在放狗搜索前，还是觉得跟Java/JS项目中的实践应该都差不多。搜了一下才发现自己Too young too simple！ 在Internationalization plan for Go中提到了Golang曾经的I18N路线图：
对国际化文本提供全面支持 对国际化日期、时间等提供支持 对多语言消息提供支持 这个2011年的讨论有人提及Golang已经支持UTF8/unicode，日期时间自己可以格式化，其他人纷纷表示不同意他的观点，然后就没有然后了。 Golang的标准库还有提供完整的I18N支持，所以还需要对众多的Golang I18N库进行技术选型。通过https://golanglibs.com/search?q=i18n可知go-i18n排名第一，而且使用者也比较多。i18n4go为大厂IBM的cloud CTO出品，从Cloud Foundary CLI中提取出来的，估计能遇到的坎都解决掉了，但是排名并不靠前。 最终决定开始我的go-18n学习之旅。
通过go-bindata嵌入i18n properties文件 具体细节见之前的博文Go程序内嵌I18N properties文件。
资源文件 i18n/resources/locale.properties mryqu.hello=Welcome to Golang world! mryqu.intro=This is a go-bindata-i18n example. mryqu.verinfo={{.Cli}} Version {{.Version}} (Build: {{.Build}}) i18n/resources/locale_en.properties mryqu.hello=Welcome to Golang world! mryqu.intro=This is a go-bindata-i18n example. mryqu.verinfo={{.Cli}} Version {{.Version}} (Build: {{.Build}}) i18n/resources/locale_zh-CN.properties mryqu.hello=欢迎来到Golang世界！ mryqu.intro=这是一个go-bindata-i18n示例。 mryqu.verinfo={{.Cli}} 版本 {{.Version}} (构建：{{.Build}}) 其他源码 i18n/i18n.go 与之前的博文Go程序内嵌I18N properties文件相比，这里添加了下面内容：
使用github.com/magiconair/properties包获取properties文件内的键值对； 通过github.com/nicksnyder/go-i18n/i18n包判断properties文件语言、为文件内所有键值对创建新的翻译。（如果不用properties文件，而是json或TOML格式文件，i18n.LoadTranslationFile就可以直接完成这些事情了，见https://github.com/nicksnyder/go-i18n/blob/master/i18n/bundle/bundle.go。） go-i18n的优点：
实现了CLDR plural rules。 使用text/template处理带有变量的字符串。 翻译文件可以是简单的JSON、TOML和YAML。 package i18n //go:generate go-bindata -pkg i18n -o resources.</description></item><item><title>[Golang] GOPATH和包导入</title><link>https://mryqu.github.io/post/golang_gopath%E5%92%8C%E5%8C%85%E5%AF%BC%E5%85%A5/</link><pubDate>Fri, 20 Oct 2017 05:43:09 +0000</pubDate><guid>https://mryqu.github.io/post/golang_gopath%E5%92%8C%E5%8C%85%E5%AF%BC%E5%85%A5/</guid><description>才开始玩GoLang，碰到一些与包导入相关的问题：
go build没有找到vendor目录下的包 local import &amp;ldquo;./XXX&amp;rdquo; in non-local package GoLang自定义包的特点 Go的package不局限于一个文件，可以由多个文件组成。组成一个package的多个文件，编译后实际上和一个文件类似，组成包的不同文件相互之间可以直接引用变量和函数，不论是否导出；因此，组成包的多个文件中不能有相同的全局变量和函数（这里有一个例外就是包的初始化函数：init函数） Go不要求package的名称和所在目录名相同，但是你最好保持相同，否则容易引起歧义。因为引入包的时候，go会使用子目录名作为包的路径，而你在代码中真正使用时，却要使用你package的名称。 每个子目录中只能存在一个package，否则编译时会报错。 Go的package是以绝对路径GOPATH来寻址的，不要用相对路径来导入 包的初始化函数init 包中可以有多个初始化函数init，每个初始化函数都会被调用，且顺序固定。
对同一个Go文件的init()调用顺序是从上到下的 对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。 对于对不同的package，如果不相互依赖的话，按照main包中&amp;quot;先import的后调用&amp;quot;的顺序调用其包中的init() 如果package存在依赖，则先调用最早被依赖的包中的init() GOPATH go命令依赖一个重要的环境变量：$GOPATH。从go 1.8开始，GOPATH环境变量现在有一个默认值，如果它没有被设置。 它在Unix上默认为$HOME/go,在Windows上默认为%USERPROFILE%/go。GOPATH支持多个目录。
$GOPATH src |--github.com |-mryqu |-prj1 |-vendor |--prj2 |-vendor pkg |--相应平台 |-github.com |--mryqu |-prj1 |-XXX.a |-YYY.a |-ZZZ.a |-prj2 |-AAA.a |-BBB.a |-CCC.a Go加载包时会从vendor tree、 $GOROOT下的src目录以及$GOPATH中的多目录下的src目录查找。
相对路径导入 通过go build无法完成非本地导入（non-local imports），必须使用go build main.go。go install根本不支持非本地导入。 相对路径导入文档位于https://golang.org/cmd/go/#hdr-Relative_import_paths 更多细节见：
https://groups.google.com/forum/#!topic/golang-nuts/1XqcS8DuaNc/discussion https://github.com/golang/go/issues/12502 https://github.com/golang/go/issues/3515#issuecomment-66066361 参考 Build Web Application with Golang
关于golang中包（package）的二三事儿
Go: local import in non-local package</description></item><item><title>[Golang] Go程序内嵌I18N properties文件</title><link>https://mryqu.github.io/post/golang_go%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8Ci18n_properties%E6%96%87%E4%BB%B6/</link><pubDate>Thu, 19 Oct 2017 06:11:03 +0000</pubDate><guid>https://mryqu.github.io/post/golang_go%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8Ci18n_properties%E6%96%87%E4%BB%B6/</guid><description>本博文将介绍一下如何将I18N properties文件内嵌到Go程序中。一般来说，go-i18n等Go包官方示例使用JSON文件保存I18N消息，而我的示例还是采用properties文件。
go-bindata go-bindata包可以将任何文件转换为可管理的Go源代码，在将二进制数据嵌入Go程序时是非常有帮助的。文件数据在转换成原始字节切片之前可做选择性的gzip压缩。 在我的示例中，我选择用go-bindata将i18n/resources下的i18n properties文件嵌入Go程序。
安装 go get -u github.com/jteeuwen/go-bindata/... 地址最后的三个点 &amp;hellip;会分析所有子目录并下载依赖编译子目录内容，而go-bindata的命令行工具在子目录中。go-bindata命令行工具将被安装到$GOPATH/bin目录中。 资源文件 i18n/resources/locale.properties mryqu.hello=Welcome to Golang world! mryqu.intro=This is a go-bindata example. i18n/resources/locale_en.properties mryqu.hello=Welcome to Golang world! mryqu.intro=This is a go-bindata example. i18n/resources/locale_zh-Hans.properties mryqu.hello=欢迎来到Golang世界！ mryqu.intro=这是一个go-bindata示例。 操练 看了go-bindata的帮助后，感觉go-bindata简单易用。这里就探索一下nocompress选项吧。
cd {MyPrj}/i18n go-bindata -pkg i18n -o resources.go resources/ go-bindata -pkg i18n -o resources-nocompress.go -nocompress resources/ 通过对比resources.go和resources-nocompress.go可以看出，resources.go里面多引入了bytes、compress/gzip和io包，多生成了一个bindataRead函数用于读取gzip压缩后的数据。 在resources.go中的内嵌数据：
var _resourcesLocaleProperties = []byte(&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xca\x2d\xaa\x2c\x2c\xd5\xcb\x48\xcd\xc9\xc9\xb7\x0d\x4f\xcd\x49\xce\xcf\x4d\x55\x28\xc9\x57\x70\xcf\xcf\x49\xcc\x4b\x57\x28\xcf\x2f\xca\x49\x51\xe4\xe5\x82\xa8\xca\xcc\x2b\x29\xca\xb7\x0d\xc9\xc8\x2c\x56\xc8\x2c\x56\x48\x54\x48\xcf\xd7\x4d\xca\xcc\x4b\x49\x2c\x49\x54\x48\xad\x48\xcc\x2d\xc8\x49\xd5\x03\x04\x00\x00\xff\xff\x45\xdc\x42\x7f\x4f\x00\x00\x00&amp;#34;) var _resourcesLocale_enProperties = []byte(&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xca\x2d\xaa\x2c\x2c\xd5\xcb\x48\xcd\xc9\xc9\xb7\x0d\x4f\xcd\x49\xce\xcf\x4d\x55\x28\xc9\x57\x70\xcf\xcf\x49\xcc\x4b\x57\x28\xcf\x2f\xca\x49\x51\xe4\xe5\x82\xa8\xca\xcc\x2b\x29\xca\xb7\x0d\xc9\xc8\x2c\x56\xc8\x2c\x56\x48\x54\x48\xcf\xd7\x4d\xca\xcc\x4b\x49\x2c\x49\x54\x48\xad\x48\xcc\x2d\xc8\x49\xd5\x03\x04\x00\x00\xff\xff\x45\xdc\x42\x7f\x4f\x00\x00\x00&amp;#34;) var _resourcesLocale_zhHansProperties = []byte(&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xca\x2d\xaa\x2c\x2c\xd5\xcb\x48\xcd\xc9\xc9\xb7\x7d\xb6\x66\xd1\x8b\xfd\x7d\xcf\xe6\x2e\x7d\xda\xb1\xc1\x3d\x3f\x27\x31\x2f\xfd\xc9\x8e\x69\xcf\xa7\xf6\xbc\xdf\xd3\xc8\xcb\x05\x51\x98\x99\x57\x52\x94\x6f\xfb\x62\xff\xcc\x67\x33\xd6\x3f\xd9\xd1\xf0\x64\xc7\xaa\xf4\x7c\xdd\xa4\xcc\xbc\x94\xc4\x92\xc4\xe7\x4b\x76\x3d\xd9\xd7\xfd\xb8\xa1\x09\x10\x00\x00\xff\xff\xf7\xd1\x50\xc9\x54\x00\x00\x00&amp;#34;) 在resources-nocompress.go中的内嵌数据：
var _resourcesLocaleProperties = []byte(`mryqu.</description></item><item><title>[Golang] 使用Makefile实现Go项目的跨平台构建</title><link>https://mryqu.github.io/post/golang_%E4%BD%BF%E7%94%A8makefile%E5%AE%9E%E7%8E%B0go%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA/</link><pubDate>Wed, 18 Oct 2017 05:49:28 +0000</pubDate><guid>https://mryqu.github.io/post/golang_%E4%BD%BF%E7%94%A8makefile%E5%AE%9E%E7%8E%B0go%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA/</guid><description>通常编译go程序，都是用go build，对于小的示例代码还可以应付，对于稍大一点的项目就有点繁琐了。 上网调差了一下，发现很多人是通过Makefile的形式对Go项目进行可重现构建的。下面我将以hellomake项目这个小示例展示如何使用Makefile实现Go项目的跨平台构建。
hellomake/Makefile BUILD_ENV := CGO_ENABLED=0 BUILD=`date +%FT%T%z` LDFLAGS=-ldflags &amp;#34;-w -s -X main.Version=${VERSION} -X main.Build=${BUILD}&amp;#34; TARGET_EXEC := hellomake .PHONY: all clean setup build-linux build-osx build-windows all: clean setup build-linux build-osx build-windows clean: rm -rf build setup: mkdir -p build/linux mkdir -p build/osx mkdir -p build/windows build-linux: setup ${BUILD_ENV} GOARCH=amd64 GOOS=linux go build ${LDFLAGS} -o build/linux/${TARGET_EXEC} build-osx: setup ${BUILD_ENV} GOARCH=amd64 GOOS=darwin go build ${LDFLAGS} -o build/osx/${TARGET_EXEC} build-windows: setup ${BUILD_ENV} GOARCH=amd64 GOOS=windows go build ${LDFLAGS} -o build/windows/${TARGET_EXEC}.</description></item><item><title>[Golang] UUID包</title><link>https://mryqu.github.io/post/golang_uuid%E5%8C%85/</link><pubDate>Tue, 17 Oct 2017 15:12:12 +0000</pubDate><guid>https://mryqu.github.io/post/golang_uuid%E5%8C%85/</guid><description>最早Google的Go UUID包位于https://code.google.com/archive/p/go-uuid/，后来移到了https://github.com/pborman/uuid。而https://github.com/google/uuid是基于pborman版的，区别于之前的实现在于用16字节数组取代了字节切片，缺点是无法表示无效UUID。上述UUID包采用BSD 3-Clause许可协议。 此外还有采用MIT协议的https://github.com/satori/go.uuid，它支持UUID版本1-5，与RFC 4122和DCE 1.1兼容。通过https://golanglibs.com/top?q=uuid可以看出，它是GitHub点星(star)最多的UUID包，远远超过了Google的。</description></item><item><title>[Golang] Win10下Glide的安装和使用</title><link>https://mryqu.github.io/post/golang_win10%E4%B8%8Bglide%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 16 Oct 2017 15:47:55 +0000</pubDate><guid>https://mryqu.github.io/post/golang_win10%E4%B8%8Bglide%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid><description>不论是开发Java还是你正在学习的Golang，都会遇到依赖管理问题。Java有牛逼轰轰的Maven和Gradle。 Golang亦有Godep、Govendor、Glide、dep等等。本文主要给大家介绍Glide。 Glide是Golang的包管理工具，是为了解决Golang依赖问题的。 为什么需要Glide？ 原因很简单，Go语言原生包管理的缺陷。罗列一下Golang的get子命令管理依赖有很多大缺陷：
能拉取源码的平台很有限，绝大多数依赖的是 github.com 不能区分版本，以至于令开发者以最后一项包名作为版本划分 依赖 列表/关系 无法持久化到本地，需要找出所有依赖包然后一个个 go get 只能依赖本地全局仓库（GOPATH/GOROOT），无法将库放置于项目局部仓库（$PROJECT_HOME/vendor） Glide是有下列几大主要功能：
持久化依赖列表至配置文件中，包括依赖版本（支持范围限定）以及私人仓库等 持久化关系树至 lock 文件中（类似于 yarn 和 cargo），以重复拉取相同版本依赖 兼容 go get 所支持的版本控制系统：Git, Bzr, HG, and SVN 支持 GO15VENDOREXPERIMENT 特性，使得不同项目可以依赖相同项目的不同版本 可以导入其他工具配置，例如： Godep, GPM, Gom, and GB Glide在Mac或Linux上是很容易安装的，但是在Win10 x64上据说最新版有问题。详见https://github.com/Masterminds/glide/issues/873。 想多了没用，还是实干吧。从https://github.com/Masterminds/glide/releases上下载了glide-v0.13.0-windows-amd64.zip，里面就一个glide.exe。 将glide.exe放入%GOPATH%/bin下，然后将%GOPATH%/bin加入环境变量Path中，由于我的Go版本是1.9所以GO15VENDOREXPERIMENT环境变量就不用管了。执行 glide --version ，开头没问题呀！ 进入我的项目目录%GOPATH%/src/helloglide，执行下列命令：
glide create #创建新的工作空间，生成glide.yaml glide get github.com/pborman/uuid #获取uui包 glide install #建立glide.lock版本 go build #构建项目 glide list #列举项目导入的所有包 INSTALLED packages: github.com\pborman\uuid glide tree #以树的形式列举项目导入的所有包 [WARN] The tree command is deprecated and will be removed in a future version helloglide |-- github.</description></item><item><title>[Golang] 解决GoClipse安装问题</title><link>https://mryqu.github.io/post/golang_%E8%A7%A3%E5%86%B3goclipse%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 14 Oct 2017 17:22:43 +0000</pubDate><guid>https://mryqu.github.io/post/golang_%E8%A7%A3%E5%86%B3goclipse%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</guid><description>按照GoClipse安装文档安装Eclipse的GoClipse插件时，提示org.eclipse.platform.feature.group无法找到。 我的Eclipse还是Eclipse 4.4 (Luna)，而GoClipse要求Eclipse 4.6 (Neon)及更高版本，看来不听话是没有好下场的。接着这个机会升级到Eclipse 4.7 (Oxygen)吧。
安装gocode、guru、godef gocode在安装LiteIDE时已经安装。GoClipse下载guru会执行go get -u golang.org/x/tools/cmd/guru ，其结果是网站不响应该请求。
go get -u github.com/nsf/gocode go get -u github.com/rogpeppe/godef mkdir %GOPATH%\src\golang.org\x\ cd %GOPATH%\src\golang.org\x\ git clone https://github.com/golang/tools.git go install golang.org/x/tools/cmd/guru 配置GoClipse 测试 齐活！</description></item><item><title>[Golang] 安装Go开发环境</title><link>https://mryqu.github.io/post/golang_%E5%AE%89%E8%A3%85go%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Fri, 13 Oct 2017 15:36:59 +0000</pubDate><guid>https://mryqu.github.io/post/golang_%E5%AE%89%E8%A3%85go%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>项目上有几个Story涉及GoLang。Go语言是谷歌2009发布的第二款开源编程语言。Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。 学习新语言从安装环境开始。到https://golang.org/下载一个Windows版的安装程序，就可以轻松搞定。 初次上手，习惯性地选了一个IDE。没下jetbrains家的GoLand，而是拿LiteIDE试试手。感觉有点卡顿，其他还好。 链接 https://golang.org/
LiteIDE
GoClipse installation</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 31 Jul 2017 05:46:44 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;] 优化twitcurl项目中的HMAC_SHA1</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</link>
      <pubDate>Mon, 31 Jul 2017 05:46:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</guid>
      <description>twitcurl开源项目中包含SHA1.cpp和HMAC_SHA1.cpp用于计算Twitter认证所需的HMAC-SHA1签名。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC_SHA1需要一个密钥，而SHA1不需要。HMAC_SHA1的公式为：SHA1(Key XOR opad, SHA1(Key XOR ipad, text)) 通过分析oauthlib.cpp和HMAC_SHA1.cpp可知： 1. 对于HMAC_SHA1算法，请求URL及参数信息作为文本输入，ConsumerSecret和AccessTokenSecret组合作为密钥输入； 2. 第一步：如果密钥输入大小超过64字节，则先做一次SHA1获取其摘要用于后继操作；否则直接使用密钥进行后继操作； 3. 第二步：密钥输入（/密钥输入摘要）XOR ipad（即0x36）； 4. 第三步：将上一步的[Key XOR ipad]和文本输入并入缓存AppendBuf1； 5. 第四步：使用上一步生成的缓存AppendBuf1一起进行SHA1以产生内部摘要； 6. 第五步：密钥输入（/密钥输入摘要）XOR opad（即0x5C）； 7. 第六步：将上一步的[Key XOR opad]和第四步产生的内部摘要并入缓存AppendBuf2； 8. 第七步：使用上一步生成的缓存AppendBuf2一起进行SHA1以产生外部摘要。
HMAC_SHA1.h中定义的AppendBuf1和AppendBuf2都有4K大小，合计8K。能不能省点空间呢？
下面我们可以看一个小示例：
char srcTest[] = &amp;quot;abcdef&amp;quot;; int srcTestL = strlen(srcTest); char srcTest1[] = &amp;quot;abc&amp;quot;; int srcTestL1 = strlen(srcTest1); char srcTest2[] = &amp;quot;def&amp;quot;; int srcTestL2 = strlen(srcTest2); unsigned char dst1[20] = &amp;quot;&amp;quot;; unsigned char dst2[20] = &amp;quot;&amp;quot;; CSHA1 sha1A = CSHA1(); sha1A.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Compile JsonCpp library using CMake</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_compile_jsoncpp_library_using_cmake/</link>
      <pubDate>Thu, 23 Mar 2017 06:14:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_compile_jsoncpp_library_using_cmake/</guid>
      <description>本文为升级JsonCpp库操作过程的备份笔记。
Linux/Unix平台 下载JsonCpp 从JsonCpp releases页面可知，当前最高版本为1.8.0。
wget https://github.com/open-source-parsers/jsoncpp/archive/1.8.0.tar.gz tar xzvf 1.8.0.tar.gz cd jsoncpp-1.8.0 mkdir build/release  升级gcc 这里我选择使用gcc 5:
sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-5 g++-5 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 1  升级cmake JsonCpp 1.8.0要求cmake&amp;gt;=3.1
sudo apt-get install software-properties-common sudo add-apt-repository ppa:george-edison55/cmake-3.x sudo apt-get update sudo apt-get upgrade cmake  编译JsonCpp cmake -DCMAKE_BUILD_TYPE=release -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G &amp;quot;Unix Makefiles&amp;quot; .</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Build JsonCpp library in Linux platform</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_build_jsoncpp_library_in_linux_platform/</link>
      <pubDate>Wed, 22 Mar 2017 05:47:27 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_build_jsoncpp_library_in_linux_platform/</guid>
      <description>wget https://github.com/open-source-parsers/jsoncpp/archive/1.8.0.tar.gz tar xzvf 1.8.0.tar.gz cd jsoncpp-1.8.0/src/lib_json g++ -g -std=c++11 -Wall -fPIC -c -I../../include json_reader.cpp json_value.cpp json_writer.cpp ar rvs libjsoncpp.a *.o g++ -g json_reader.o json_writer.o json_value.o -shared -o libjsoncpp.so  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 将JSON转成字符串</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E5%B0%86json%E8%BD%AC%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 26 Dec 2016 05:24:36 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E5%B0%86json%E8%BD%AC%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>需要将如下JSON字符串作为GoogleSheets API POST请求的消息体。打算使用JsonCpp实现。
{&amp;quot;majorDimension&amp;quot;:&amp;quot;ROWS&amp;quot;,&amp;quot;values&amp;quot;:[[&amp;quot;Name&amp;quot;,&amp;quot;Sex&amp;quot;,&amp;quot;Age&amp;quot;,&amp;quot;Height&amp;quot;,&amp;quot;Weight&amp;quot;],[&amp;quot;阿尔弗雷德&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;112.5&amp;quot;],[&amp;quot;爱丽丝&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;56.5&amp;quot;,&amp;quot;84&amp;quot;],[&amp;quot;芭芭拉&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;65.3&amp;quot;,&amp;quot;98&amp;quot;],[&amp;quot;凯露&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;62.8&amp;quot;,&amp;quot;102.5&amp;quot;],[&amp;quot;亨利&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;63.5&amp;quot;,&amp;quot;102.5&amp;quot;],[&amp;quot;詹姆斯&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;57.3&amp;quot;,&amp;quot;83&amp;quot;],[&amp;quot;简&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;59.8&amp;quot;,&amp;quot;84.5&amp;quot;],[&amp;quot;雅妮特&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;62.5&amp;quot;,&amp;quot;112.5&amp;quot;],[&amp;quot;杰弗瑞&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;62.5&amp;quot;,&amp;quot;84&amp;quot;],[&amp;quot;约翰&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;59&amp;quot;,&amp;quot;99.5&amp;quot;],[&amp;quot;乔伊斯&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;11&amp;quot;,&amp;quot;51.3&amp;quot;,&amp;quot;50.5&amp;quot;],[&amp;quot;茱迪&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;64.3&amp;quot;,&amp;quot;90&amp;quot;],[&amp;quot;罗伊斯&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;56.3&amp;quot;,&amp;quot;77&amp;quot;],[&amp;quot;玛丽&amp;quot;,&amp;quot;女&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;66.5&amp;quot;,&amp;quot;112&amp;quot;],[&amp;quot;菲利普&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;16&amp;quot;,&amp;quot;72&amp;quot;,&amp;quot;150&amp;quot;],[&amp;quot;罗伯特&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;64.8&amp;quot;,&amp;quot;128&amp;quot;],[&amp;quot;罗纳德&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;67&amp;quot;,&amp;quot;133&amp;quot;],[&amp;quot;托马斯&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;11&amp;quot;,&amp;quot;57.5&amp;quot;,&amp;quot;85&amp;quot;],[&amp;quot;威廉&amp;quot;,&amp;quot;男&amp;quot;,&amp;quot;15&amp;quot;,&amp;quot;66.5&amp;quot;,&amp;quot;112&amp;quot;]]}  最终代码：</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 调试libcurl程序</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%B0%83%E8%AF%95libcurl%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 25 Dec 2016 21:22:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%B0%83%E8%AF%95libcurl%E7%A8%8B%E5%BA%8F/</guid>
      <description>最近在调试通过libcurl发送GoogleSheets API POST请求时，增加了一点经验，特此总结。
GoogleSheets API 请求 POST /v4/spreadsheets?access_token={YOUR_ACCESSTOKEN}&amp;amp;fields=spreadsheetId HTTP/1.1 Host: sheets.googleapis.com Content-Type: application/json;charset=UTF-8 Accept: application/json Cache-Control: no-cache {&amp;quot;properties&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;newhaha&amp;quot;},&amp;quot;sheets&amp;quot;:[{&amp;quot;properties&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;Sheet1&amp;quot;}}]}  libcurl调试 当GoogleSheets API 请求失败时，仅能获得返回的状态码和消息。感觉没有更多信息可以研究！后来通过CURLOPT_VERBOSE和CURLOPT_DEBUGFUNCTION获得了更多调试信息。
使用CURLOPT_VERBOSE curl_easy_setopt(m_curl, CURLOPT_VERBOSE, 1L);  这样就可以看到请求报头、响应报头和消息体了。
使用CURLOPT_DEBUGFUNCTION 使用libcurl API指南中CURLOPT_DEBUGFUNCTION示例代码即可。这样就可以看到完整的请求和响应内容了。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 给twitcurl添加访问频次限制信息获取功能</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</link>
      <pubDate>Thu, 24 Mar 2016 06:05:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</guid>
      <description>在我之前的博文Twitter API访问频次限制处理中，描述了Twitter API访问频次限制及Twitter4J对其处理。twitcurl项目并没有这样的功能，今天我将getLastRateLimitStatus功能添加到了twitcurl。 通过添加如下代码，我可以获取响应头信息：
curl_easy_setopt( m_curlHandle, CURLOPT_HEADERFUNCTION, curlHeaderCallback ); curl_easy_setopt( m_curlHandle, CURLOPT_HEADERDATA, this );  输出的调试信息如下：
Enter string to search: va Limit search results to: 2 twitCurl::curlHeaderCallback headers: HTTP/1.1 200 OK twitCurl::curlHeaderCallback headers: cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0 twitCurl::curlHeaderCallback headers: content-disposition: attachment; filename=json.json twitCurl::curlHeaderCallback headers: content-encoding: gzip twitCurl::curlHeaderCallback headers: content-length: 1301 twitCurl::curlHeaderCallback headers: content-type: application/json;charset=utf-8 twitCurl::curlHeaderCallback headers: date: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: expires: Tue, 31 Mar 1981 05:00:00 GMT twitCurl::curlHeaderCallback headers: last-modified: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: pragma: no-cache twitCurl::curlHeaderCallback headers: server: tsa_b twitCurl::curlHeaderCallback headers: set-cookie: guest_id=v1:145879558114535127; Domain=.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]获取Facebook帖子生成的SAS时间</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96facebook%E5%B8%96%E5%AD%90%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 20 Feb 2016 06:13:22 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96facebook%E5%B8%96%E5%AD%90%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</guid>
      <description>写了一个小代码分析Facebook帖子生成时间字符串，将其解析成SAS时间。 简而言之，time_t存储的是距00:00:00, Jan 1, 1970 UTC的秒数（epoch），其中tm_year存储的是当前年数减去1900；而SAS时间起始点为00:00:00, Jan 1, 1960UTC；转换主要使用difftime获取两者的时间差。
代码如下：参考 C++: time_t
C++: time
C++: gmtime</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]获取推文生成的SAS时间</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96%E6%8E%A8%E6%96%87%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</link>
      <pubDate>Fri, 19 Feb 2016 06:07:14 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E8%8E%B7%E5%8F%96%E6%8E%A8%E6%96%87%E7%94%9F%E6%88%90%E7%9A%84sas%E6%97%B6%E9%97%B4/</guid>
      <description>写了一个小代码分析推文生成时间字符串，将其解析成SAS时间。 简而言之，time_t存储的是距00:00:00, Jan 1, 1970 UTC的秒数（epoch），其中tm_year存储的是当前年数减去1900；而SAS时间起始点为00:00:00, Jan 1, 1960UTC；转换主要使用difftime获取两者的时间差。 代码如下：参考 C++: time_t
C++: time
C++: gmtime</description>
    </item>
    
    <item>
      <title>cURL错误处理</title>
      <link>https://mryqu.github.io/post/curl%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 07 Jan 2016 06:08:54 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/curl%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>cURL执行错误分为两种： - 通过curl_easy_perform函数执行请求结果，返回值不是CURLE_OK。错误信息除了可以对照CURLcode定义查看，也可以通过设置CURLOPT_ERRORBUFFER设置错误缓存区获得人类易读的错误文字信息。范例见https://curl.haxx.se/libcurl/c/CURLOPT_ERRORBUFFER.html
 curl = curl_easy_init(); if(curl) { CURLcode res; char errbuf[CURL_ERROR_SIZE]; curl_easy_setopt(curl, CURLOPT_URL, &amp;quot;http://example.com&amp;quot;); curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf); errbuf[0] = 0; res = curl_easy_perform(curl); if(res != CURLE_OK) { size_t len = strlen(errbuf); fprintf(stderr, &amp;quot;\nlibcurl: (%d) &amp;quot;, res); if(len) fprintf(stderr, &amp;quot;%s%s&amp;quot;, errbuf, ((errbuf[len - 1] != &#39;\n&#39;) ? &amp;quot;\n&amp;quot; : &amp;quot;&amp;quot;)); else fprintf(stderr, &amp;quot;%s\n&amp;quot;, curl_easy_strerror(res)); } }   另一种是curl_easy_perform返回CURLE_OK，但是HTTP响应代码为400及以上的整数。HTTP响应代码可以通过curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE,&amp;amp;httpCode)获得错误消息需要通过curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,curlCallback)获得消息体后解析而得。  </description>
    </item>
    
    <item>
      <title>为cURL库设置HTTP代理的代码片段</title>
      <link>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link>
      <pubDate>Wed, 06 Jan 2016 06:01:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid>
      <description>在twitcurl看到cURL库设置http代理的方法，记录一下。
void twitCurl::prepareCurlProxy() { if( m_curlProxyParamsSet ) { return; } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYUSERPWD, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYAUTH, (long)CURLAUTH_ANY ); std::string proxyIpPort(&amp;quot;&amp;quot;); if( getProxyServerIp().size() ) { utilMakeCurlParams( proxyIpPort, getProxyServerIp(), getProxyServerPort() ); } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, proxyIpPort.c_str() ); if( m_proxyUserName.length() &amp;amp;amp;&amp;amp;amp; m_proxyPassword.length() ) { std::string proxyUserPass; utilMakeCurlParams( proxyUserPass,getProxyUserName(),getProxyPassword() ); curl_easy_setopt( m_curlHandle,CURLOPT_PROXYUSERPWD,proxyUserPass.c_str() ); } m_curlProxyParamsSet = true; }  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]用正则表达式检查日期格式yyyy-MM-dd</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</link>
      <pubDate>Thu, 31 Dec 2015 06:21:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</guid>
      <description>写了一个小程序使用C++的正则表达式检查日期是否符合yyyy-MM-dd格式： 结果总是抛出exception，错误代码不是error_brack就是error_escape。检查了一下代码，没觉得不符合ECMAScript语法法则。 查了一下我的环境，用的gcc 4.7.0。试了一下regex_match的例子，没问题，但是稍微改动一下用\d{4}检查4位数字就又抛exception了。
C:\&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=C:\quTools\Anaconda\Scripts\g++.bat\..\..\MinGW\bin\g++.exe COLLECT_LTO_WRAPPER=c:/qutools/anaconda/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.7.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../build/gcc/src/configure --target=x86_64-w64-mingw32 --prefix=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --with-sysroot=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --enable-languages=all,obj-c++ --enable-fully-dynamic-string --disable-multilib Thread model: win32 gcc version 4.7.0 20111220 (experimental) (GCC)  搜了一下，发现C++2011标准中的regex功能直到gcc 4.9.0才正式发布。啥也不说了，在Mingw-w64 Toolchains上直接下载个gcc 5.3.0试试，一切正常了
C:\ctest&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=C:/tools/mingw32/bin/../libexec/gcc/i686-w64-mingw32/5.3.0/lto-wrapper.exe Target: i686-w64-mingw32 Configured with: ../../../src/gcc-5.3.0/configure --host=i686-w64-mingw32 --build=i686-w64-mingw32 --target=i686-w64-mingw32 --prefix=/mingw32 --with-sysroot=/c/mingw530/i686-530-posix-dwarf-rt_v4-rev0/mingw32 --with-gxx-include-dir=/mingw32/i686-w64-mingw32/include/c++ --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-sjlj-exceptions -- with-dwarf2 --disable-isl-version-check --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=i686 --with-tune=generic --with-libiconv --with-system-zlib --with-gmp=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpfr=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpc=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-isl=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-pkgversion=&#39;i686-posix-dwarf-rev0, Built by MinGW -W64 project&#39; --with-bugurl=http://sourceforge.</description>
    </item>
    
    <item>
      <title>解决使用twitcurl.lib遇到的LNK1112和LNK2038链接错误</title>
      <link>https://mryqu.github.io/post/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8twitcurl.lib%E9%81%87%E5%88%B0%E7%9A%84lnk1112%E5%92%8Clnk2038%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</link>
      <pubDate>Wed, 30 Dec 2015 14:52:38 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8twitcurl.lib%E9%81%87%E5%88%B0%E7%9A%84lnk1112%E5%92%8Clnk2038%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</guid>
      <description>在使用twitcurl.lib时，遭遇下列链接错误：
fatal error LNK1112: module machine type &#39;X86&#39; conflicts with target machine type &#39;x64&#39; libtwitcurl.lib(twitcurl.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MD_DynamicRelease&#39; doesn&#39;t match value &#39;MT_StaticRelease&#39; in xxxxx.obj  解决方法： </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]玩玩Designated Initializer</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%8E%A9%E7%8E%A9designated_initializer/</link>
      <pubDate>Mon, 28 Dec 2015 06:18:40 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%8E%A9%E7%8E%A9designated_initializer/</guid>
      <description>玩一把gcc的Designated Initializers： 测试结果：结构体内的变量必须按照声明的顺序初始化，并且不能遗漏，否则会报“sorry, unimplemented:non-trivial designated initializers not supported”错误。
参考 C99标准
Bug 55606 - sorry, unimplemented: non-trivial designated initializers not supported
C++ - g++: sorry, unimplemented: non-trivial designated initializers not supported - SysTutorials QA
http://stackoverflow.com/questions/31215971/non-trivial-designated-initializers-not-supported
Non-trivial designated initializers not supported · Issue #8 · couchbaselabs/cbforest · GitHub</description>
    </item>
    
    <item>
      <title>twitcurl生成HTTP OAuth头的实现流程</title>
      <link>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 27 Dec 2015 06:12:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description>对twitcurl代码做了一些修改，结果遇到了认证失败的错误：
{“errors”:[{“message”:”Could not authenticate you”,”code”:32}]}  通过继续修改twitcurl代码改正问题，学习了twitcurl的认证授权部分代码。其授权部分主要在oauthlib.h和oauthlib.cpp中的oAuth类实现中。下面主要分析一下oAuth::getOAuthHeader方法。
外部数据 Http URL: https://api.twitter.com/1.1/search/tweets.json Http头参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |q|va |count|23 |result_type|recent
Http授权参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |oauth_consumer_key|xvz1evFS4wEEPTGEFPHBog |oauth_signature_method|HMAC-SHA1 |oauth_token|370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |oauth_version|1.0
oAuth::getOAuthHeader方法  通过buildOAuthHttpParameterKeyValPairs(params, true,rawKeyValuePairs);对Http头参数中参数值进行百分号编码（URL编码），编码后结果放在哈希表rawKeyValuePairs中 rawKeyValuePairs: 键值qvacount23result_typerecent
 假定HTTP内容是经过百分号编码的，通过buildOAuthRawDataKeyValPairs( rawData,false, rawKeyValuePairs );找到内容中的键值对，放入哈希表rawKeyValuePairs中 rawKeyValuePairs: 键值qvacount23result_typerecent 通过buildOAuthTokenKeyValuePairs( includeOAuthVerifierPin,std::string( &amp;ldquo;&amp;rdquo; ), rawKeyValuePairs, true );创建认授权证： rawKeyValuePairs: 键值说明qvacount23result_typerecentoauth_consumer_keyxvz1evFS4wEEPTGEFPHBogoauth_nonce131862295819ctwitcurl实现就是时戳项加一个随机数oauth_signature_methodHMAC-SHA1固定值oauth_timestamp1318622958oauth_token370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEboauth_version1.0固定值 通过getSignature( eType, pureUrl, rawKeyValuePairs,oauthSignature );获得签名  生成 sigBase： 使用consumer_secret和token_secret组成signing_key，使用HMAC_SHA1算法通过sigBase和signing_key生成摘要strDigest：B6 79 C0 AF 18 F4 E9 C5 87 AB 8E 20 0A CD 4E 48 A9 3F 8C B6(非真实计算而得数据) 通过base64_encode进行编码：tnnArxj06cWHq44gCs1OSKk/jLY= (非真实计算而得数据) 通过百分比编码获得最终签名：(非真实计算而得数据)  通过rawKeyValuePairs.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 我服务器上的GCC版本不支持C&#43;&#43;11特性</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E6%88%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84gcc%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81c&#43;&#43;11%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 25 Dec 2015 06:10:29 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E6%88%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84gcc%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81c&#43;&#43;11%E7%89%B9%E6%80%A7/</guid>
      <description>用了点C++11特性，结果编译失败，编译参数加&amp;rdquo;-std=c++0x&amp;rdquo;，结果识别不出来。
$ g++ -v Using built-in specs. Target: amd64-undermydesk-freebsd Configured with: FreeBSD/amd64 system compiler Thread model: posix gcc version 4.2.1 20070719 [FreeBSD]  C++0x/C++11 Support in GCC提到GCC 4.3版本之后才支持C++11特性，白折腾一把！ 好吧，我用gcc docker!</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]遭遇error C2039: &#39;min&#39; : is not a member of &#39;std&#39;</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%81%AD%E9%81%87error_c2039_min__is_not_a_member_of_std/</link>
      <pubDate>Tue, 22 Dec 2015 05:31:50 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%81%AD%E9%81%87error_c2039_min__is_not_a_member_of_std/</guid>
      <description>使用Visual Studio2013编译twitcurl遭遇下列错误：
error C2039: &#39;min&#39; : is not a member of &#39;std&#39;  解决方法：
#include &amp;lt;algorithm&amp;gt;  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] Building twitcurl Library in Unix platform</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_building_twitcurl_library_in_unix_platform/</link>
      <pubDate>Sat, 19 Dec 2015 05:47:33 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_building_twitcurl_library_in_unix_platform/</guid>
      <description> Download twitcurl source from https://github.com/swatkat/twitcurl using Git client.  git clone https://github.com/swatkat/twitcurl.git  In Unix shell, cd into libtwitcurl directory. Compile all of the twitcurlsource files into object files.  g++ -Wall -fPIC -c -I. twitcurl.cpp oauthlib.cpp urlencode.cpp base64.cpp HMAC_SHA1.cpp SHA1.cpp  Building twitcurl asstatic library: Use the archive commandto build twitcurl library from object files.  ar rvs libtwitcurl.a *.o   </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用NM查看目标文件的符号列表</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8nm%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 18 Dec 2015 06:10:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8nm%E6%9F%A5%E7%9C%8B%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8/</guid>
      <description>练习使用nm查看目标文件的符号列表。此外发现G++竟然创建了两套构造函数和析构函数。
nm命令  -a或&amp;ndash;debug-syms：显示调试符号。 -B：等同于&amp;ndash;format=bsd，用来兼容MIPS的nm。 -C或&amp;ndash;demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D或&amp;ndash;dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -fformat：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g或&amp;ndash;extern-only：仅显示外部符号。 -n、-v或&amp;ndash;numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p或&amp;ndash;no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P或&amp;ndash;portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-fposix。 -s或&amp;ndash;print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r或&amp;ndash;reverse-sort：反转排序的顺序(例如，升序变为降序)。 &amp;ndash;size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -tradix或&amp;ndash;radix=radix：使用radix进制显示符号值。radix只能为&amp;rdquo;d&amp;rdquo;表示十进制、&amp;rdquo;o&amp;rdquo;表示八进制或&amp;rdquo;x&amp;rdquo;表示十六进制。 &amp;ndash;target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u或&amp;ndash;undefined-only：仅显示没有定义的符号(那些外部符号)。 -l或&amp;ndash;line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V或&amp;ndash;version：显示nm的版本号。 &amp;ndash;help：显示nm的任选项。  练习 symtest.hpp #include &amp;lt;iostream&amp;gt; class SymTest { SymTest(); SymTest(int x); ~SymTest(); void foo(); };  symtest.cpp #include &amp;quot;symtest.hpp&amp;quot; SymTest::SymTest() { printf(&amp;quot;SymTest::SymTest\n&amp;quot;); } SymTest::SymTest(int x) { printf(&amp;quot;SymTest::SymTest(int)\n&amp;quot;); } SymTest::~SymTest() { printf(&amp;quot;SymTest::~SymTest\n&amp;quot;); } void SymTest::foo() { printf(&amp;quot;SymTest::foo\n&amp;quot;); }  编译 NM: -g 仅显示外部符号 -C 显示用户级名字 学习了StackOverflow上的帖子Dual emission of constructor symbols，才了解这是G++的一个已知问题，两套构造函数分别是complete objectconstructor和base object constructor。</description>
    </item>
    
    <item>
      <title>Sublime Text2&#43;Ctags&#43;Cscope使用实践</title>
      <link>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 09 Dec 2015 07:07:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/sublime_text2&#43;ctags&#43;cscope%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</guid>
      <description>安装 安装Package Control 步骤见https://packagecontrol.io/installation#st2
安装CTags插件  通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Ctags插件（快捷键Ctrl+Shift+P，输入install） 打开Preference -&amp;gt; Package Settings -&amp;gt; Ctags -&amp;gt;Settings-Default和Setting-User，将Settings-Default中的内容拷贝到Setting-User中，将&amp;rdquo;command&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;rdquo; 填入Ctags.exe的路径位置 打开C工程根目录，在上点击右键，选择Ctags:Rebuild tags  安装Cscope插件  同样通过 Preference -&amp;gt; Package Control -&amp;gt; InstallPackage安装Cscope插件（快捷键Ctrl+Shift+P，输入install） 通过cscope –Rb在C工程根目录创建cscope.out文件 Cscope在ST2上没有包配置菜单，需要打开CscopeSublime.sublime-settings文件(我的机器在C:/Users/yqu/AppData/Roaming/SublimeText 2/Packages/Cscope目录下)，将 &amp;ldquo;executable&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的 &amp;ldquo;&amp;ldquo;填入Cscope.exe的路径位置,将 &amp;ldquo;database_location&amp;rdquo;: &amp;ldquo;&amp;rdquo; 中的&amp;rdquo;&amp;ldquo;填入cscope.out的路径位置。  使用 CTags命令 |Command|Key Binding|Alt Binding|Mouse Binding |&amp;mdash;&amp;ndash; |rebuild_ctags|ctrl+t, ctrl+r| &amp;nbsp; | &amp;nbsp; |navigate_to_definition|ctrl+t, ctrl+t|ctrl+&amp;gt;|ctrl+shift+left_click |jump_prev|ctrl+t, ctrl+b|ctrl+&amp;lt;|ctrl+shift+right_click |show_symbols|alt+s| &amp;nbsp;| &amp;nbsp; |show_symbols (all files)|alt+shift+s| &amp;nbsp;| &amp;nbsp; |show_symbols (suffix)|ctrl+alt+shift+s| &amp;nbsp;| &amp;nbsp;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用readelf</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8readelf/</link>
      <pubDate>Tue, 08 Dec 2015 06:06:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8readelf/</guid>
      <description>在计算机科学中，ELF文件（Executableand LinkableFormat）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件，是UNIX系统实验室（USL）作为应用程序二进制接口（ApplicationBinaryInterface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。1999年，被86open项目选为x86架构上的类Unix操作系统的二进制文件标准格式，用来取代COFF。因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上。 ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program headertable）、节（Section）和节头表（Section headertable）。实际上，一个文件中不一定包含全部内容，而且他们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。 而readelf用于显示ELF文件的信息。 Usage: readelf &amp;lt;option(s)&amp;gt; elf-file(s) Display information about the contents of ELF format files Options are: -a --all 全部 Equivalent to: -h -l -S -s -r -d -V -A -I -h --file-header ELF头 Display the ELF file header -l --program-headers 程序头表 Display the program headers --segments An alias for --program-headers -S --section-headers 节头 Display the sections&#39; header --sections An alias for --section-headers -g --section-groups 节组 Display the section groups -t --section-details 节细节 Display the section details -e --headers 全部头 Equivalent to: -h -l -S -s --syms 符号表 Display the symbol table --symbols An alias for --syms --dyn-syms 动态符号表 Display the dynamic symbol table -n --notes 核心注释 Display the core notes (if present) -r --relocs 重定位 Display the relocations (if present) -u --unwind Display the unwind info (if present) -d --dynamic 动态节 Display the dynamic section (if present) -V --version-info 版本节 Display the version sections (if present) -A --arch-specific 架构信息 Display architecture specific information (if any) -c --archive-index 该架构下符号/文件索引 Display the symbol/file index in an archive -D --use-dynamic Use the dynamic section info when displaying symbols -x --hex-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as bytes -p --string-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as strings -R --relocated-dump=&amp;lt;number|name&amp;gt; Dump the contents of section &amp;lt;number|name&amp;gt; as relocated bytes -w[lLiaprmfFsoRt] or --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames, =frames-interp,=str,=loc,=Ranges,=pubtypes, =gdb_index,=trace_info,=trace_abbrev,=trace_aranges, =addr,=cu_index] 显示DWARF2调试节 Display the contents of DWARF2 debug sections --dwarf-depth=N Do not display DIEs at depth N or greater --dwarf-start=N Display DIEs starting with N, at the same depth or deeper -I --histogram 柱状图 Display histogram of bucket list lengths -W --wide 输出宽度 Allow output width to exceed 80 characters @&amp;lt;file&amp;gt; Read options from &amp;lt;file&amp;gt; -H --help 帮助 Display this information -v --version 版本 Display the version number of readelf  练习 - 查看ELF文件头 hadoop@node51054:/usr/bin$ readelf -h curl ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x4023b1 Start of program headers: 64 (bytes into file) Start of section headers: 152600 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 27  练习 - 查看符号表 hadoop@node51054:/usr/bin$ readelf -s curl Symbol table &#39;.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 使用ldd</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8ldd/</link>
      <pubDate>Mon, 07 Dec 2015 06:05:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BD%BF%E7%94%A8ldd/</guid>
      <description>ldd是用来查看共享库依赖的Shell脚本命令。下面来看一下ldd命令的参数。 - -v：显示所有信息，例如包括符号版本信息。 - -u：显示没有使用的直接依赖。 - -d：执行重新定位，报告任何缺失对象（仅针对ELF） - -r：对数据对象和函数执行重新定位，报告任何缺失对象或函数（仅针对ELF）
Oracle - Linker and Libraries Guide - Relocations介绍了重新定位技术的来龙去脉，也介绍了ldd命令的相关使用。
ldd练习 hadoop@node51054:/usr/bin$ ldd curl linux-vdso.so.1 =&amp;gt; (0x00007ffefe989000) libcurl.so.4 =&amp;gt; /usr/lib/x86_64-linux-gnu/libcurl.so.4 (0x00007fb86cf8f000) libz.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fb86cd76000) libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fb86cb58000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb86c790000) libidn.so.11 =&amp;gt; /usr/lib/x86_64-linux-gnu/libidn.so.11 (0x00007fb86c55d000) librtmp.so.0 =&amp;gt; /usr/lib/x86_64-linux-gnu/librtmp.so.0 (0x00007fb86c343000) libssl.so.1.0.0 =&amp;gt; /lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007fb86c0e4000) libcrypto.so.1.0.0 =&amp;gt; /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007fb86bd08000) libgssapi_krb5.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007fb86bac1000) liblber-2.4.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/liblber-2.4.so.2 (0x00007fb86b8b2000) libldap_r-2.4.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libldap_r-2.4.so.2 (0x00007fb86b661000) /lib64/ld-linux-x86-64.so.2 (0x00007fb86d1f6000) libgnutls.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] GNU Binutils之ar和ranlib</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_gnu_binutils%E4%B9%8Bar%E5%92%8Cranlib/</link>
      <pubDate>Sun, 06 Dec 2015 07:36:13 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_gnu_binutils%E4%B9%8Bar%E5%92%8Cranlib/</guid>
      <description>GNU binutils是一组二进制工具集。包括：ld、as、addr2line、ar、gprof、nm、objcopy、objdump、ranlib、size、strings、strip等。本文重点学习一下其中的ar和ranlib。
ar命令 ar用于建立、修改、提取档案文件(archive)。archive是一个包含多个被包含文件的单一文件（也称之为库文件），其结构保证了可以从中检索并得到原始的被包含文件（称之为archive中的member）。member的原始文件内容、模式（权限）、时间戳、所有者和组等属性都被保存在archive中。member被提取后，他们的属性被恢复到初始状态。 ar命令第一个参数可混合指令代码（operationcode p）和修饰符标志（modifier flags mod），可按意愿添加一个折线。
ar [--plugin name] [-X32_64] [-]p[mod [relpos] [count]] archive [member...]  指令参数  d：删除档案文件中的成员文件。 m：移动在档案文件中的成员文件，改变次序。可以借助修饰符标志a、b、i移动到指定位置。 p：显示档案文件中的成员文件内容。 q：将文件快速附加在档案文件末端。不检查、不替换已有同名成员文件，也不更新档案文件的符号表索引，修饰符标志a、b、i无效。然而很多不同系统都假设q指令重建档案文件的符号表索引，因此GNU将其按照r指令进行相同实现。 r：将文件插入档案文件中。检查并替换已有同名成员文件，重建档案文件的符号表索引，借助修饰符标志a、b、i将文件插入到指定位置。 t：显示档案文件中所包含的文件。 x：自档案文件中取出成员文件。  修饰符标志  a &amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之后。 b&amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之前。 c：建立档案文件。当更新档案文件时，档案文件不存在则创建档案文件，但会告警。此标志可抑制告警。 D：以确定模式工作。 f：为避免过长的文件名不兼容于其他系统的ar指令指令，可利用此参数，截掉要放入档案文件中过长的成员文件名称。 i &amp;lt;成员文件&amp;gt;：将文件插入档案文件中指定的成员文件之前。（等同标志b） I：可接受但不使用。 N：使用count参数。当档案文件中存在多个同名成员，用于指定提取/删除的个数。 o：保留档案文件中文件的日期。如无此参数，则输出文件的修改时间为提取时间。 s：若档案文件中包含了对象模式，可利用此参数建立档案文件的符号表。 S：不产生符号表。 T：使指定档案文件成为瘦档案文件。例如将多个档案文件加入目标档案文件，目标档案文件可以包含符号索引及对源档案文件中成员文件的引用。 u：只将日期较新文件插入档案文件中。 v：程序执行时显示详细的信息。 V：显示版本信息。  练习 # 将当前目录下所有.o打包成libyqutest.a档案文件：r插入，v显示操作信息，s生成符号表。 ar rvs libyqutest.a *.o # 制作瘦档案文件：r插入，c建立档案文件，T指定为瘦档案文件。 ar -rcT libkx.a libke.a libxiao.a  ranlib命令 为档案文件创建符号索引。
ranlib [-vVt] archive  选项： - -v、-V或&amp;ndash;version：显示版本 - -t：更新档案文件符号映射的时戳。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] addr2line使用</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_addr2line%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 11 Sep 2015 05:33:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_addr2line%E4%BD%BF%E7%94%A8/</guid>
      <description>GNU Binutils的Addr2line工具是一个可以将指令的地址和可执行程序转换成文件名、函数名和源代码行数的工具。这种功能对于将跟踪地址转换成更有意义的内容来说简直是太棒了。
下面是一个小示例testAddr2line.c：
#include &amp;quot;stdio.h&amp;quot; void test() { printf(&amp;quot;Hello Addr2line\n&amp;quot;); } int main() { test(); return 0; }  编译时使用-g选项包含调试符号条，使用-Wl,-Map=testAddr2line.map选项输出MapFile。
gcc -Wl,-Map=testAddr2line.map -g -o testAddr2line testAddr2line.c  testAddr2line.map部分内容如下： testAddr2line中也包含符号表信息，因而可以使用objdump查找：
hadoop@node51054:~/ctest$ objdump -t testAddr2line | grep &#39;main\|test&#39; testAddr2line: file format elf64-x86-64 0000000000000000 l df *ABS* 0000000000000000 testAddr2line.c 0000000000000000 F *UND* 0000000000000000 __libc_start_main@@GLIBC_2.2.5 0000000000400547 g F .text 0000000000000015 main 0000000000400536 g F .text 0000000000000011 test  使用addr2line：
hadoop@node51054:~/ctest$ addr2line -e testAddr2line 400536 /home/hadoop/ctest/testAddr2line.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 编译OpenSSL和libCurl</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%BC%96%E8%AF%91openssl%E5%92%8Clibcurl/</link>
      <pubDate>Sun, 01 Mar 2015 23:05:26 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%BC%96%E8%AF%91openssl%E5%92%8Clibcurl/</guid>
      <description>准备工作 登录一台Linux服务器，并完成下列工作： - 在目录/home/mryqu/创建子目录out，在out目录下创建子目录ssl和curl； - 从OpenSSL项目下载openssl-1.0.2.tar.gz，并解压； - 从curl项目下载curl-7.40.0.tar.gz，并解压
编译OpenSSL  进入openssl-1.0.2目录; 完成OpenSSL配置，仅支持静态库不支持动态库：  ./config no-shared --openssldir=/home/mryqu/out/ssl  对Makefile文件中的FGLAG和DEPFLAG变量进行修改，增加-fPIC。 编译：  make depend make make install   编译产生如下内容： 编译libCurl  进入curl-7.40.0目录; 首先设定pkg-config路径，指定为上一步OpenSSL编译结果。由于我们的OpenSSL编译结果不在编译器/链接器默认搜索路径，通过pkg-config路径和&amp;ndash;with-ssl让libCurl查找到OpenSSL。通过&amp;ndash;without-zlib禁止掉即时解压缩。  export PKG_CONFIG_PATH=/home/mryqu/out/ssl/lib/pkgconfig ./configure --prefix=/home/mryqu/out/curl --with-ssl --without-zlib make make install   编译产生如下内容： 参考 OpenSSL Compilation and Installation
how to install curl and libcurl
OpenSSL Cookbook
Everything curl</description>
    </item>
    
    <item>
      <title>[C] 了解printf中的%.s</title>
      <link>https://mryqu.github.io/post/c_%E4%BA%86%E8%A7%A3printf/</link>
      <pubDate>Thu, 22 Jan 2015 20:59:59 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_%E4%BA%86%E8%A7%A3printf/</guid>
      <description>偶尔看到C代码printf(&amp;quot;%.*s&amp;quot;,dataL,data);，对printf中的格式化字符串&amp;rdquo;%.*s&amp;rdquo;有点不解。
查看了http://www.cplusplus.com/reference/cstdio/printf/文档后，有所理解。
| width |description |&amp;mdash;&amp;ndash; | (number) |Minimum number of characters to be printed. If the value tobe printed is shorter than this number, the result is padded withblank spaces. The value is not truncated even if the result islarger. | * |The width is not specified in the format string, but as an additional integer value argument preceding theargument that has to be formatted.
| .precision |description |&amp;mdash;&amp;ndash; | .</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]不错的C&#43;&#43;引用参数分析</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%B8%8D%E9%94%99%E7%9A%84c&#43;&#43;%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 09 Nov 2013 07:29:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%B8%8D%E9%94%99%E7%9A%84c&#43;&#43;%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</guid>
      <description>阅读了一篇不错的C++ 引用参数 深入分析，摘要如下：
把参数声明成引用，实际上改变了缺省的按值传递参数的传递机制，在按值传递时，函数操纵的是实参的本地拷贝。
一、引用参数的三种常见用法：  需要改变实参的值，比如swap()。参数是引用时，函数接收的是实参的左值而不是值的拷贝。这意味着函数知道实参在内存中的位置，因而能够改变它的值或取它的地址。 向主调函数返回额外的结果。 向函数传递大型的类对象。  二、如果引用参数不希望在被调用的函数内部被修改，那么把参数声明为 const 型的引用是个不错的办法。 三、 我们可以声明任意内置数据类型的引用参数 四、引用参数还是指针参数 这两种参数都能够改变实参的值，也可以有效的传递大型类对象，怎么样决定参数该声明成哪种呢？ 根本区别是：引用必须被初始化为指向一个对象，一旦初始化了，它就不能再指向其他对象；指针可以指向一系列不同的对象也可以什么都不指向。因为指针可能指向一个对象或没有任何对象，所以函数在确定指针实际指向一个有效的对象之前不能安全地解引用（dereference）一个指针。另一方面，对于引用参数，函数不需要保证它指向一个对象。引用必须指向一个对象，甚至在我们不希望这样时也是如此。 如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必须使用指针参数 。 引用参数的一个重要用法是：它允许我们在有效地实现重载操作符的同时，还能保证用法的直观性。</description>
    </item>
    
    <item>
      <title>Linux/Unix下显示二进制目标文件的符号表</title>
      <link>https://mryqu.github.io/post/linux%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link>
      <pubDate>Thu, 31 Oct 2013 22:22:34 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid>
      <description>nm 查看二进制目标文件符号表的标准工具是nm，可以执行下列命令查看二进制目标文件（.o）/静态库（.a）/动态库（.so）的符号表：
nm -g yourObj.o nm -g yourLib.a nm -g yourLib.so  C/C++语言在C++编译器编译以后，函数的名字会被编译器修改，改成编译器内部的名字，这个名字会在链接的时候用到。例如std::string::size()经过修饰后是_ZNKSs4sizeEv。通过添加&amp;rdquo;-C&amp;rdquo;选项，可以对底层符号表译成用户级名称（demangle），具有更好的可读性。
以test.cpp为例：将其编译后，通过nm查看符号表，带&amp;rdquo;-C&amp;rdquo;选项与否的结果如下：readelf 如果你的二进制目标文件（.o）/静态库（.a）/动态库（.so）是ELF（Executableand linkingformat）格式，则可以使用readelf命令提取符号表信息。
readelf -Ws usr/lib/yourLib.so  如果仅想输出函数名，可以通过awk命令进行解析：
readelf -Ws test.o | awk &#39;$4==&amp;quot;FUNC&amp;quot; {print $8}&#39;;  以上面的test.o为例：
显示test.o的elf文件头信息：显示test.o的符号表：参考 How do I list the symbols in a .so file
nm - Linux man page
readelf - Linux man page
[](http://man.linuxde.net/nm)
[](http://man.linuxde.net/readelf)</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 重温函数隐藏和重写</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</link>
      <pubDate>Sat, 26 Oct 2013 08:23:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</guid>
      <description>首先回顾一下C++的重载、隐藏和重写概念：
 在相同作用域中，同名不同参的函数称为重载，这是c++多态的一种表现。对相同名字的成员函数，编译器可以根据传递的参数类型调用相应的成员函数。同名不同参的全局函数和类成员函数由于作用域不同，不是重载。不能通过函数返回值进行重载。像int和float这样不同的参数类型，可能会由于隐式转换隐患而无法通过编译。 当派生类中的成员函数/变量和基类中的成员函数/变量同名时，会隐藏基类的成员函数/变量，也就是指在派生类调用这个同名的成员函数/变量，调用的是派生类的成员函数/变量，而不是基类的那个成员函数/变量。可以通过类名::成员函数/变量去访问基类中同名的成员函数/变量。 派生类中的成员函数与基类的成员函数同名同参，就称为重写。当直接访问成员函数调用的是在派生类中重写的函数而不是从基类继承下来的成员函数，如果要访问从基类继承下来的成员函数也是通过类名::成员函数这种方式去调用基类的成员函数。  下面的小示例testOverride.cpp用于测试添加virtual与否对重写的影响：
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } BaseClass(const BaseClass&amp;amp;) { cout &amp;lt;&amp;lt; &amp;quot;BaseClass(BaseClass) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); bo1-&amp;gt;vfun1(); bo1-&amp;gt;vfun2(); bo1-&amp;gt;fun1(); bo1-&amp;gt;fun2(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); do1-&amp;gt;vfun1(); // error: &#39;virtual void DerivedClass::vfun2()&#39; is private // within this context // do1-&amp;gt;vfun2(); do1-&amp;gt;fun1(); // error: &#39;void DerivedClass::fun2()&#39; is private // within this context // do1-&amp;gt;fun2(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); bo2-&amp;gt;vfun1(); bo2-&amp;gt;vfun2(); bo2-&amp;gt;fun1(); bo2-&amp;gt;fun2(); delete bo2; return 0; }  vfun2和fun2在BaseClass类中是public访问权限，而在DerivedClass类中是private访问权限。 - 对DerivedClass指针，vfun2和fun2无法访问，这个满足期望。 - 对于指向DerivedClass对象的BaseClass指针，vfun2和fun2仍然可以访问。我只能在心里留一个&amp;rdquo;?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 重温析构函数</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Oct 2013 21:11:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>创建一个C++对象时，一般先调用父类构造函数，再调用自己的构造函数；而在销毁一个C++对象时，一般先调用自己的析构函数，再调用父类的析构函数。我用如下testDestructor.cpp进行测试。
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); delete bo2; cout &amp;lt;&amp;lt; &amp;quot;=== test bo3 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass bo3 = DerivedClass(&amp;quot;321&amp;quot;); return 0; }  输出结果如下：</description>
    </item>
    
    <item>
      <title>[Linux] 判断可执行文件或动态库是否包含符号表</title>
      <link>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link>
      <pubDate>Thu, 24 Oct 2013 22:48:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid>
      <description>在Linux下生成一个可执行文件或动态库，可以使用gcc/g++的&amp;rdquo;-g&amp;rdquo;选项使文件包含调试符号表。 要在Linux下判断一个第三方的可执行文件或动态库是否包含调试符号表，可以通过file命令实现：
srv01&amp;gt; file libcurl.so.6 libcurl.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (FreeBSD), dynamically linked, not stripped srv01&amp;gt; file /usr/bin/X11/curl /usr/bin/X11/curl: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked (uses shared libs), for FreeBSD 8.0 (800107), stripped  显示not stripped，表明文件带调试符号表；而显示stripped，表明文件已去除符号表。
如果文件包含调试符号表，可以通过objdump -t命令及选项打印文件的符号表：
srv01&amp;gt; objdump -t libcurl.so.6 libcurl.so.6: file format elf64-x86-64 SYMBOL TABLE: 0000000000000120 l d .hash 0000000000000000 00000000000012b0 l d .dynsym 0000000000000000 0000000000004b08 l d .dynstr 0000000000000000 0000000000006f36 l d .</description>
    </item>
    
    <item>
      <title>[C] GCC对UTF8 BOM的支持</title>
      <link>https://mryqu.github.io/post/c_gcc%E5%AF%B9utf8_bom%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Thu, 24 Oct 2013 20:31:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_gcc%E5%AF%B9utf8_bom%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>最近玩些特俗字符，结果对yqutest.cpp源码文件编译时先碰到error:converting to execution character set: Illegal bytesequence错误。GCC的源码字符集与执行字符集默认是UTF-8编码，为了避免源码文件乱码，最好也是采用UTF-8编码来存储源码文件。将源码编码转成UTF-8，问题得以解决。 但是否需要UTF-8 BOM(byte-order mark)呢？ 我一时兴起添加了BOM，十六进制为EF BB BF，即对应八进制的357 273 277，编译结果如下：
mryqu&amp;gt; g++ yqutest.cpp -o yqutst123 yqutest.cpp:1: error: stray &#39;\357&#39; in program yqutest.cpp:1: error: stray &#39;\273&#39; in program yqutest.cpp:1: error: stray &#39;\277&#39; in program yqutest.cpp:1: error: stray &#39;#&#39; in program yqutest.cpp:1: error: expected constructor, destructor, or type conversion before &#39;&amp;lt;&#39; token mryqu&amp;gt; g++ -v Using built-in specs. Target: amd64-undermydesk-freebsd Configured with: FreeBSD/amd64 system compiler Thread model: posix gcc version 4.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 从静态库获取GCC版本和编译平台</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BB%8E%E9%9D%99%E6%80%81%E5%BA%93%E8%8E%B7%E5%8F%96gcc%E7%89%88%E6%9C%AC%E5%92%8C%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Thu, 24 Oct 2013 07:43:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BB%8E%E9%9D%99%E6%80%81%E5%BA%93%E8%8E%B7%E5%8F%96gcc%E7%89%88%E6%9C%AC%E5%92%8C%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</guid>
      <description>获取GCC版本：strings -a {library} | grep &amp;ldquo;GCC: (&amp;rdquo;
mryqu&amp;gt; strings -a libcurl.a | grep &amp;quot;GCC: (&amp;quot; GCC: (GNU) 4.4.5 20110214 (Red Hat 4.4.5-6)  获取编译平台信息：ar -x {library}file *.o
mryqu&amp;gt; ar -x libcurl.a mryqu&amp;gt;file libcurl_la-url.o libcurl_la-url.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped  参考 How to retrieve the GCC version used to compile a given ELF executable?
How to see the compilation platform of a static library file</description>
    </item>
    
    <item>
      <title>[C] Exec format error</title>
      <link>https://mryqu.github.io/post/c_exec_format_error/</link>
      <pubDate>Sun, 20 Oct 2013 17:28:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_exec_format_error/</guid>
      <description>很久没用g++了，结果编个小程序还出错。
mryqu:~/ctest$ g++ -g -c wvc.cpp -o wvc mryqu:~/ctest$ chmod a+x wvc mryqu:~/ctest$ ./wvc -bash: ./wvc: cannot execute binary file: Exec format error mryqu:~/ctest$ file wvc wvc: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped  查了查gcc的帮助，才发现用了-c选项后其实是只编译不链接的：
-c Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</description>
    </item>
    
    <item>
      <title>[C] #和##宏操作符</title>
      <link>https://mryqu.github.io/post/c_%E5%AE%8F%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Sun, 20 Oct 2013 10:45:24 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c_%E5%AE%8F%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>在看# and ## in macros之前觉得对#和##宏操作符挺明白的，看了之后才感觉需要重新学习一下。
#define f(a,b) a##b #define g(a) #a #define h(a) g(a) int main() { printf(&amp;quot;%s\n&amp;quot;,h(f(1,2))); printf(&amp;quot;%s\n&amp;quot;,g(f(1,2))); return 0; }  如果你能确保自己能写出正确答案的话，那么你可以略过这篇帖子。 C/C++语言中对宏的处理属于编译器预处理的范畴，属于编译期概念而非运行期概念。其中#操作符用于对指定的宏参数进行字符串化，而##操作符用来将两个符号连接为一个符号。
struct command { char *name; void (*function) (void); };   ``` #define COMMAND(NAME) \ { #NAME, NAME ## _command } struct command commands[] = { COMMAND (quit), COMMAND (help), … }; ``` 等同 ``` struct command commands[] = { { &#34;quit&#34;, quit_command }, { &#34;</description>
    </item>
    
    <item>
      <title>Cscope笔记</title>
      <link>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 20:20:11 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/cscope%E7%AC%94%E8%AE%B0/</guid>
      <description>Cscope简介 Cscope是一个类似Ctags的工具，但功能比ctags强大很多。Cscope是一款自带一个基于文本的用户界面的源代码浏览工具，尽管它最初是为C代码的搜索（包括lex、yacc文件）设计的，但是也可以用于对C++和Java代码的搜索。用Cscope你可以轻易地搜索到你的标识符是在哪里被定义和使用的，它可以轻而易举地解决以下问题： - 这个变量在哪里被使用？ - 这个预处理符号的值是什么？ - 这个函数都在哪些源代码文件中出现过？ - 都有哪些函数调用了这个函数？ - &amp;ldquo;out of space&amp;rdquo;的消息是从哪里来的？ - 这个源文件在在目录结构中的位置？ - 都有哪些源文件包含了这个头文件？
Cscope是由Santa Cruz Operation, Inc发布的，它遵循BSD开源协议。
安装 Cscope项目仅提供源代码，不提供二进制文件。cscope-win32项目提供了使用MinGW、MSYS和Cygwin编译Windows平台Cscope的方法，此外也提供编译好好的csope.exe文件。下载cscope-15.8a-win64rev1-static.zip，将其中的cscope.exe解压缩到系统环境变量path包含的路径即可。 使用 创建符号数据库 Cscope在第一次被使用在指定的源文件时会建立一个符号的数据库。接下来调用时，Cscope仅仅重建那些被改动或者和新文件相关的数据库。那些没有被改动的文件相关的数据库会被直接复制使用。这使得重建数据库要比第一次运行快许多。 Cscope命令的参数如下： - -R: 在生成索引文件时，搜索子目录树中的代码 - -b: 只生成索引文件，不进入cscope的界面 - -q:生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度 - -k: 在生成索引文件时，不搜索/usr/include目录 - -i:如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”-“，表示由标准输入获得文件列表。 - -Idir:在-I选项指出的目录中查找头文件 - -u: 扫描所有文件，重新生成交叉索引文件 - -C: 在搜索时忽略大小写 - -Ppath:在以相对路径表示的文件前加上的path，这样，你不用切换到你数据库文件所在的目录也可以使用它了。 我针对curl项目执行cscope -Rkq ，这样会启动Cscope的文本用户界面，之后我搜索set_binmode函数： 搜索符号 在Cscope的文本界面里可以在命令模式执行:cs find或:cs f命令搜索符号，其参数为： - s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方 - g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能 - d: 查找本函数调用的函数 - c: 查找调用本函数的函数 - t: 查找指定的字符串 - e: 查找egrep模式，相当于egrep功能，但查找速度快多了 - f: 查找并打开文件，类似vim的find功能 - i: 查找包含本文件的文件</description>
    </item>
    
    <item>
      <title>Exuberant Ctags笔记</title>
      <link>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 19 Oct 2013 14:46:08 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/exuberant_ctags%E7%AC%94%E8%AE%B0/</guid>
      <description>Ctags简介 Ctags（Generate tag files for sourcecode）产生标记(/索引)文件以帮助在源文件中定位对象。Ctags最初支持C语言，现在已经支持C/C++/Java/JS/Python等41种语言。Vim/Emacs/SublimeText/UltraEdit等编辑器或工具都支持Ctags生成的标记文件。 对于C/C++语言来说，其生成的标记文件tags中包括这些对象的列表： - 用#define定义的宏 - 枚举型变量的值 - 函数的定义、原型和声明 - 名字空间（namespace） - 类型定义（typedefs） - 变量（包括定义和声明） - 类（class）、结构（struct）、枚举类型（enum）和联合（union） - 类、结构和联合中成员变量或函数
安装 下载ctags58.zip，将其中的ctags.exe解压缩到系统环境变量path包含的路径即可。 使用选项 如果没有指定−−language−force选项，每个源文件的语言基于文件名和语言的映射进行自动选择。该映射可用−−list−maps选项显示，它可能会被−−langmap选项改变。对于操作系统所支持的文件，如果文件名无法映射到某种语言且该文件可被执行，则会对文件第一行检查是为&amp;rdquo;#!&amp;ldquo;公认的语言脚本。默认情况下，所有其他文件名都会被忽略。由于仅文件名可匹配某种语言的文件会被扫描，这使得在单个目录对所有文件(例如&amp;rdquo;ctags*&amp;ldquo;)或对目录树的所有文件(例如&amp;rdquo;ctags −R&amp;rdquo;)执行ctags成为可能。.h扩展名即用于C++也用于C，所以Ctags将.h映射为C++，这样做不会有不良后果。
 -R：等同于&amp;ndash;recurse，递归子目录遍历 -L：从文件读取Ctags待处理文件列表并对其执行ctags  find . -name &amp;quot;*.h&amp;quot; -o -name &amp;quot;*.c&amp;quot; -o -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.bld&amp;quot; -o -name &amp;quot;*.blt&amp;quot; &amp;gt; prj.files ctags -L prj.files  --list−maps：显示文件名和语言的映射  --list−languanges：显示所有支持的语言  --langmap：设置文件名和语言的映射 如果程序中有的.c文件其实是C++程序，这该怎么办？答案是使用ctags &amp;ndash;langmap=c++:+.c。 −−language−force：强制使用特定语言，而不是通过文件名和语言的映射进行自动选择 像C++标准库stl中文件名没有后缀，怎么办？ 使用ctags−−language−force=C++这样就把所有文件当成C++来处理了。 −−fields：指定标记文件中条目的可用扩展字段（没有指明的默认关闭） a
类成员的访问属性
f
文件限制范围 [enabled]</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 类型转换</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 15 Dec 2007 21:20:37 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>C++中的强制转换函数共有以下几种： - C 风格（C-style）强制转型: (Type) expr - 函数风格（Function-style）强制转型: Type( expr )要注意的是Type(expr)语法上等同(Type)expr，但是要避免使用。Type(expr,expr_else)是安全的。 - static_cast &amp;lt;type-id&amp;gt; ( expr )：用于非多态类型转换。static_cast是第一个应该尝试的类型转换。它完成类似隐性类型转换（例如int转float，指针转void*）这样的工作，也能调用显式（或隐式）类型转换函数。在很多情况下，显式使用static_cast没有必要。static_cast也能在继承层次上进行类型转换。在进行上行转换（子类转父类）是没有必要的，下行转换只要没有虚拟继承的情况下也可用，但是它不会做任何检查，下行转换为非该对象真正的类型时行为不明确。type-id和expr必须是指针、引用、算术类型或枚举类型。 - dynamic_cast &amp;lt;type-id&amp;gt; ( expr )：用于多态类型转换。dynamic_cast是几乎唯一用于处理多态类型转换的。你可以将一个指针或引用转换成其他类的多态类型（一个多态类型至少有一个虚函数，不管是声明的还是继承的）。它不仅经可用于下行转换，还可以横向转换或上行转换到另一个继承链。dynamic_cast会检查转换是否可行，如果可行则返回期望的对象，否则原表达式是指针的话返回空指针、原表达式是引用的话抛出std::bad_cast异常。dynamic_cast有一些限制。当继承层次上有相同类型的多个对象（DiamondDerivationproblem，菱形派生问题）而又没有使用虚拟继承时，无法工作。它仅能遍历公开继承，在遍历保护继承或私有继承时总是失败。非公开的继承很少使用，所以这种问题也很少见。Type-id必须是类的指针、类的引用或者void*；如果type-id是类指针类型，那么expr也必须是一个指针，如果type-id是一个引用，那么exp也必须是一个引用。 - const_cast &amp;lt;type-id&amp;gt; ( expr)：用来修改类型的const、volatile和__unaligned属性。const_cast可用于对一个变量添加或删除const属性，其他C++类型转换（甚至reinterpret_cast）没有删除const的能力。需要注意的是原有变量是const的，如果修改之前的常量值会造成不确定的行为。如果一个const引用指向非常量，对引用去掉const是安全的。当重载的成员函数是const的时候非常有用，例如你可以对一个对象添加const以调用重载的成员函数。const_cast也能对volatile属性进行修改，只是会更少被用到。除了const 或volatile修饰之外， type_id和expr的类型是一样的。 - reinterpret_cast &amp;lt;type-id&amp;gt; ( expr )：对类型简单重新解释reinterpret_cast是最危险的类型转换，应该尽可能少地使用。它直接将一个类型转换成另外一个，例如将一个指针获得的值转换成另一种类型、将指针存储成整型值、或其他一些丑陋的转换。基本上，reinterpret_cast仅能保障转换回原类型是正常的，你能在中间类型不小于原有类型的情况下获得相同的值。有很多reinterpret_cast不能做的转换。主要用于转义转换和二进制处理，例如将原始数据流转成实际数据、或将数据存储在对齐指针的低bit位中。type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
其中前两种称为旧风格（old-style）的强制转型，后四种为标准C++的类型转换符。
旧风格的强制转型可以看成按下列顺序排列的第一个成功的类型转换组合： - const_cast - static_cast (忽略访问限制) - static_cast接着const_cast - reinterpret_cast - reinterpret_cast接着const_cast
旧风格的强制转型比较危险，因为可能被解析成reinterpret_cast，而且解析成static_cast时会忽略访问权限控制（能做其他类型转换无法实现的功能）。此外，使用旧风格的强制转型也不如C++类型转换容易查找，所以一般不推荐使用。
参考 Type conversions
MSDN：Casting Operators
When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
总结C++中的所有强制转换函数(const_cast，reinterpret_cast，static_cast，dynamic_cast)
In C++, why use static_cast(x) instead of (int)x?</description>
    </item>
    
  </channel>
</rss>
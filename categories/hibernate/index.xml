<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hibernate on Mryqu's Notes</title><link>https://mryqu.github.io/categories/hibernate/</link><description>Recent content in Hibernate on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 30 Aug 2015 08:56:57 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/categories/hibernate/index.xml" rel="self" type="application/rss+xml"/><item><title>[Hibernate Tools] 通过数据库表生成JPA Entity类</title><link>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%94%9F%E6%88%90jpa_entity%E7%B1%BB/</link><pubDate>Sun, 30 Aug 2015 08:56:57 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%94%9F%E6%88%90jpa_entity%E7%B1%BB/</guid><description>本文与前一博文[Hibernate Tools] 通过JPA Entity类生成数据库表 正好相反，实践一下如何通过数据库表生成JPA Entity类。
在Eclipse中安装JBoss Tools中的Hibernate Tools插件 创建JPA项目PetStoreDemo 使用向导创建JPA项目 项目基本设置 设置JPA Facet 此处选用了Generatic 2.1平台，用户库HIBERNATE_JPA包含如下jar文件：
hibernate-commons-annotations.jar hibernate-core.jar hibernate-jpa-2.1-api.jar 通过数据库表生成JPA Entity类 执行“Generate Entities from Tables” 选择库表 设置库表关联关系 定制生成Entity的默认行为 设置单个Entity 生成结果 下面以Item为例，展示生成结果。
package com.yqu.jpetstore; import java.io.Serializable; import javax.persistence.*; import java.math.BigDecimal; @Entity @Table(name=&amp;#34;item&amp;#34;) @NamedQuery(name=&amp;#34;Item.findAll&amp;#34;, query=&amp;#34;SELECT i FROM Item i&amp;#34;) public class Item implements Serializable { private static final long serialVersionUID = 1L; private String itemid; private String attr1; private String attr2; private String attr3; private String attr4; private String attr5; private BigDecimal listprice; private String status; private BigDecimal unitcost; private Product product; private Supplier supplierBean; public Item() { } @Id @GeneratedValue(strategy=GenerationType.</description></item><item><title>[Hibernate Tools] 通过JPA Entity类生成数据库表</title><link>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87jpa_entity%E7%B1%BB%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/</link><pubDate>Sat, 29 Aug 2015 07:19:26 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87jpa_entity%E7%B1%BB%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/</guid><description>以前用过hbm2ddlAnt任务通过Hibernate映射文件生成数据库DDL。现在使用JPA后，不知道还有没有标准工具了。找了一圈，还是HibernateTools。
在Eclipse中安装JBoss Tools中的Hibernate Tools插件 创建JPA项目CustomerDemo 使用向导创建JPA项目 项目基本设置 设置JPA Facet 此处选用了EclipseLink 2.5.x平台。如选择Generatic2.1平台，在生成数据库Schema时会报“Generate Tables from Entities is notsupported by the Generic Platform”。 用户库ECLIPSELINK_JPA包含如下jar文件：
eclipselink.jar javax.persistence.jar org.eclipse.persistence.jpa.modelgen.jar org.eclipse.persistence.jpars.jar Entity类代码及设置 Customer类 package hello; import javax.persistence.*; @Entity @Table(name=&amp;#34;CUSTOMER&amp;#34;) public class Customer { @Id @Column(name=&amp;#34;CUSTOMER_ID&amp;#34;, nullable=false, updatable=false, unique=true) @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(name = &amp;#34;CUSTOMER_FNAME&amp;#34;) private String firstName; @Column(name = &amp;#34;CUSTOMER_LNAME&amp;#34;) private String lastName; protected Customer() {} public Customer(String firstName, String lastName) { this.firstName = firstName; this.</description></item><item><title>数据源/Hibernate配置明文密码加密思考</title><link>https://mryqu.github.io/post/%E6%95%B0%E6%8D%AE%E6%BA%90hibernate%E9%85%8D%E7%BD%AE%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E6%80%9D%E8%80%83/</link><pubDate>Wed, 01 Jan 2014 17:48:44 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%95%B0%E6%8D%AE%E6%BA%90hibernate%E9%85%8D%E7%BD%AE%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E6%80%9D%E8%80%83/</guid><description>无论是Web应用服务器数据源配置还是Hibernate配置，一般数据库用户和密码都是明文的，感觉很不安全。上网搜了一圈，博客帖子还不少，不过都跟Web应用服务器官方文档差不太多。 Tomcat坚持明文，理由是最终需要用原始用户名和密码去连接数据库，而Tomcat是开源的，攻击者很容易找到加密/解密方法，所以也得不到真正的保护。 另一方就是用AES/DES/3DES等密钥算法对明文密码进行加密，然后在程序某处进行解密，例如使用Tomcat连接池时用org.apache.tomcat.jdbc.pool.DataSourceFactory继承子类实现自己的数据源工厂时进行解密，使用Srping时用LocalSessionFactoryBean继承子类读取配置进行解密然后将其写回运行态的配置。这种方式说白了，如果程序不是很大，使用JAD等工具对程序进行反编译，找到如何加解密的算法还是不难的。 我个人认为，真正的Web应用实施肯定是要设置服务器访问权限及服务器内目录的访问权限的，一般人不应该能访问到Web服务器程序及配置，这样即使使用明文密码也能保证相同的安全等级。当然，如果开发一个不严肃的小项目，并且部署在一个公共访问机器上，做做障眼法瞒瞒那些不是码农的人也是可以的。
Web应用服务器文档：
Tomcat Wiki：FAQ/Password JBoss：Encrypting Data Source Passwords JBoss EAP：Encrypting Data Source Passwords TomEE：DataSource Password Encryption博客： Encrypting passwords in Tomcat Hibernate的配置文件中用户和密码的加密 hibernate配置文件中数据库密码加密,该如何解决 Hibernate的验证，而不存储在纯文本密码 如何给工程中的配置文件加密 解密 通过spring对hibernate/ibatis的配置文件加密 jndi 数据源配置密码加密 spring 属性文件加密码及解密 怎么实现数据库连接的密码加密 Jboss数据源密码加密 Tomcat数据源连接池加密 使用 Jasypt 保护数据库配置 spring datasource 密码加密后运行时解密的解决办法</description></item><item><title>Hibernate shards数据库分片</title><link>https://mryqu.github.io/post/hibernate_shards%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87/</link><pubDate>Fri, 19 Jul 2013 07:01:23 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate_shards%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87/</guid><description>简介 Hibernate Shards是Hibernate的一个子项目，由Google工程师Max Ross创建并捐献给Hibernate社区。 http://www.hibernate.org/subprojects/shards.html https://github.com/hibernate/hibernate-shards
Hibernate Shards是对Hibernate Core提供水平分区支持的一个框架。
标准Hibernate编程模型 灵活的分片策略 支持虚拟分片 免费/开源 实现Hibernate Shards Hibernate Shards几乎可以与现有Hibernate项目无缝结合使用。 Hibernate Shards的首要目标是让程序员使用标准Hibernate Core API查询和处理已分片的数据库,因此Hibernate Shards主要由大家已经熟知的Hibernate Core接口的实现（分片感知）组成，大多数Hibernate应用程序使用Hibernate Core提供的接口，因此无需对已有代码做过多重构。
|Hibernate Core接口|Hibernate Shards实现 |&amp;mdash;&amp;ndash; |org.hibernate.Session|org.hibernate.shards.session.ShardedSession |org.hibernate.SessionFactory|org.hibernate.shards.ShardedSessionFactory |org.hibernate.Criteria|org.hibernate.shards.criteria.ShardedCriteria |org.hibernate.Query|org.hibernate.shards.query.ShardedQuery
唯一问题是 Hibernate Shards 需要一些特定信息和行为。比如，需要一个分片访问策略、一个分片选择策略和一个分片解析策略。这些是您必须实现的接口，虽然部分情况下，您可以使用默认策略。我们将在后面的部分逐个了解各个接口。 首先让我们看一下《HibernateShard 参考指南》中所用的数据库模式、对象模型及映射。
气象报告数据库模式 CREATE TABLE WEATHER_REPORT ( REPORT_ID INT NOT NULL AUTO_INCREMENT PRIMARY KEY, CONTINENT ENUM(&amp;#39;AFRICA&amp;#39;, &amp;#39;ANTARCTICA&amp;#39;, &amp;#39;ASIA&amp;#39;, &amp;#39;AUSTRALIA&amp;#39;, &amp;#39;EUROPE&amp;#39;, &amp;#39;NORTH AMERICA&amp;#39;, &amp;#39;SOUTH AMERICA&amp;#39;), LATITUDE FLOAT, LONGITUDE FLOAT, TEMPERATURE INT, REPORT_TIME TIMESTAMP ); 气象报告对象模型 @Entity @Table(name=&amp;#34;WEATHER_REPORT&amp;#34;) public class WeatherReport { @Id @GeneratedValue(generator=&amp;#34;WeatherReportIdGenerator&amp;#34;) @GenericGenerator(name=&amp;#34;WeatherReportIdGenerator&amp;#34;, strategy=&amp;#34;org.</description></item><item><title>发现Hibernate 3.2.6统计中一个bug</title><link>https://mryqu.github.io/post/%E5%8F%91%E7%8E%B0hibernate_3.2.6%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%B8%AAbug/</link><pubDate>Tue, 18 Jun 2013 17:13:28 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%8F%91%E7%8E%B0hibernate_3.2.6%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%B8%80%E4%B8%AAbug/</guid><description>今天使用Hibernate的统计类，分析一下结果。结果发现了一个bug，不能获得查询缓存中的查询语句。 这个bug倒在3.6.8已经修改了，不过还是影响我的工作。
Statistics stat = sessionFactory.getStatistics(); logger.info(&amp;#34;isStatisticsEnabled:&amp;#34;+stat.isStatisticsEnabled()); logger.info(&amp;#34;stat=&amp;#34;+stat.toString()); logger.info(&amp;#34;queries=&amp;#34;+Arrays.toString(stat.getQueries())); org.hibernate.stat.StatisticsImpl.java
public String[] getQueries() { return ArrayHelper.toStringArray( queryStatistics.keySet()); } org.hibernate.util.ArrayHelper.java (Hibernate 3.2.6)
public static String[] toStringArray(Collection coll) { return (String[]) coll.toArray(EMPTY_STRING_ARRAY); } org.hibernate.util.ArrayHelper.java (Hibernate3.6.8)
public static String[] toStringArray(Collection coll) { return (String[]) coll.toArray( new String[coll.size()]); }</description></item><item><title>Hibernate3 HQL: ClassCastException解决办法</title><link>https://mryqu.github.io/post/hibernate3_hql_classcastexception%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link><pubDate>Tue, 11 Jun 2013 18:06:03 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate3_hql_classcastexception%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid><description>下面的示例代码跑在Hibernate 3.6.8，会抛出异常java.lang.ClassCastException:[Ljava.lang.Object 无法转换成实体对象。通过调试可知返回的仍然是标量字段对象数组，而不是实体对象。
public class DemoEntity { public static final String DEMO_ENTITY_ID = &amp;#34;demoEntityID&amp;#34;; public static final String USER_ID = &amp;#34;userID&amp;#34;; public static final String OFFICE_ID = &amp;#34;officeID&amp;#34;; private Integer demoEntityID; private String userID; private Integer officeID; private String subjectTxt; public List findDemoEntitys(int startID, int limit, boolean includeStartIdInResults) { try { StringBuilder querySb = new StringBuilder(); querySb.append(&amp;#34;select demo.&amp;#34;).append(DemoEntity.DEMO_ENTITY_ID); querySb.append(&amp;#34;, demo.&amp;#34;).append(DemoEntity.USER_ID); querySb.append(&amp;#34;, demo.&amp;#34;).append(DemoEntity.OFFICE_ID); querySb.append(&amp;#34; from DemoEntity demo where demo.&amp;#34;).append(DemoEntity.DEMO_ENTITY_ID); if (includeStartIdInResults) { querySb.</description></item><item><title>Hibernate3.X升级到4.X实践</title><link>https://mryqu.github.io/post/hibernate3.x%E5%8D%87%E7%BA%A7%E5%88%B04.x%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 07 Jun 2013 22:49:33 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate3.x%E5%8D%87%E7%BA%A7%E5%88%B04.x%E5%AE%9E%E8%B7%B5/</guid><description>Jar调查 |jar文件|Hibernate 4.2.2|当前的Hibernate|操作 |&amp;mdash; |antlr.jar|required, 2.7.7|3.2.0|无需改变。 |dom4j.jar|required, 1.6.1|1.6.1|无需改变。 |hibernate-commons-annotations.jar|required, 4.0.2|3.3.1|替换。 |hibernate-corel.jar|required, 4.2.2|3.2.6|替换。 |hibernate-jpa-2.0-api.jar|required, 1.0.1||增加。 |javassist.jar|required, 3.15.0|3.15.0|无需改变。 |jboss-logging.jar|required, 3.1.0||增加。 |jboss-transaction-api_1.1_specl.jar|required, 1.0.1||一开始增加，后来去掉了。 |hibernate-annotations.jar|null|3.3.1|去掉。从Hibernate3.6.0开始hibernate-annotations被合并到hibernate-core。 |hibernate-entitymanager.jar|jpa, 4.2.2|3.2.2|替换。
修改HibernateUtil 将AnnotationConfiguration替换成Configuration； 在使用ServiceRegistry;
Configuration config = new Configuration().configure(); ServiceRegistry serviceRegistry = newServiceRegistryBuilder() .applySettings(config.getProperties()).buildServiceRegistry(); sessionFactory = config.buildSessionFactory(serviceRegistry); Hibernate4不支持Ant HibernateToolTask。 使用Hibernate3和HibernateToolTask创建hibernate.cfg.xml 使用Hibernate4编译。 https://community.jboss.org/thread/177200
修改Web容器下的jar文件 替换hibernate3.jar为hibernate-core.jar 替换hibernate-commons-annotations.jar 删除ejb3-persistence.jar 删除hibernate-annotations.jar 复制hibernate-entitymanager.jar 复制hibernate-jpa-2.0-api.jar 复制jboss-logging.jar 复制jboss-transaction-api_1.1_spec.jar （最终没有复制） 通过删除jboss-transaction-api_1.1_spec.jar解决TransactionManager冲突 org.springframework.jndi.TypeMismatchNamingException: Objectof type [class com.atomikos.icatch.jta.J2eeTransactionManager]available at JNDI location [java:comp/env/TransactionManager] isnot assignable to [javax.transaction.TransactionManager] 通过删除ejb3-persistence.jar解决javax.persistence冲突 java.lang.NoSuchMethodError:javax.persistence.OneToMany.orphanRemoval() ejb3-persistence.</description></item></channel></rss>
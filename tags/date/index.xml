<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>date on Mryqu's Notes</title><link>https://mryqu.github.io/tags/date/</link><description>Recent content in date on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 31 Dec 2015 06:21:51 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/date/index.xml" rel="self" type="application/rss+xml"/><item><title>[C++]用正则表达式检查日期格式yyyy-MM-dd</title><link>https://mryqu.github.io/post/c++_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</link><pubDate>Thu, 31 Dec 2015 06:21:51 +0000</pubDate><guid>https://mryqu.github.io/post/c++_%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8Fyyyy-mm-dd/</guid><description>写了一个小程序使用C++的正则表达式检查日期是否符合yyyy-MM-dd格式： 结果总是抛出exception，错误代码不是error_brack就是error_escape。检查了一下代码，没觉得不符合ECMAScript语法法则。 查了一下我的环境，用的gcc 4.7.0。试了一下regex_match的例子，没问题，但是稍微改动一下用\d{4}检查4位数字就又抛exception了。
C:\&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=C:\quTools\Anaconda\Scripts\g++.bat\..\..\MinGW\bin\g++.exe COLLECT_LTO_WRAPPER=c:/qutools/anaconda/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.7.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../build/gcc/src/configure --target=x86_64-w64-mingw32 --prefix=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --with-sysroot=/c/bb/vista64-mingw32/mingw-x86-x86_64/build/build/root --enable-languages=all,obj-c++ --enable-fully-dynamic-string --disable-multilib Thread model: win32 gcc version 4.7.0 20111220 (experimental) (GCC) 搜了一下，发现C++2011标准中的regex功能直到gcc 4.9.0才正式发布。啥也不说了，在Mingw-w64 Toolchains上直接下载个gcc 5.3.0试试，一切正常了
C:\ctest&amp;gt;g++ -v Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=C:/tools/mingw32/bin/../libexec/gcc/i686-w64-mingw32/5.3.0/lto-wrapper.exe Target: i686-w64-mingw32 Configured with: ../../../src/gcc-5.3.0/configure --host=i686-w64-mingw32 --build=i686-w64-mingw32 --target=i686-w64-mingw32 --prefix=/mingw32 --with-sysroot=/c/mingw530/i686-530-posix-dwarf-rt_v4-rev0/mingw32 --with-gxx-include-dir=/mingw32/i686-w64-mingw32/include/c++ --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-sjlj-exceptions -- with-dwarf2 --disable-isl-version-check --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=i686 --with-tune=generic --with-libiconv --with-system-zlib --with-gmp=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpfr=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-mpc=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-isl=/c/mingw530/prerequisites/i686-w64-mingw32-static --with-pkgversion=&amp;#39;i686-posix-dwarf-rev0, Built by MinGW -W64 project&amp;#39; --with-bugurl=http://sourceforge.</description></item><item><title>[OpenUI5] sap.ui.core.format.DateFormat使用</title><link>https://mryqu.github.io/post/openui5_sap.ui.core.format.dateformat%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 15 Mar 2015 17:02:46 +0000</pubDate><guid>https://mryqu.github.io/post/openui5_sap.ui.core.format.dateformat%E4%BD%BF%E7%94%A8/</guid><description>使用javascript的Date类型，想要输出国际化的字符串，可以使用toLocaleString函数，但是需要自己往里设locale，并且输出结果随操作系统和浏览器不同而变化。
最后还是用OpenUI5的DateFormat，既可以固定格式有可以自动国际化。
var oDateFormat = sap.ui.core.format.DateFormat.getDateTimeInstance({ pattern: &amp;#34;EEEE, MMMM d, yyyy HH:mm:ss a z&amp;#34; }); oDateFormat.format(new Date());</description></item><item><title>Joda-Time笔记</title><link>https://mryqu.github.io/post/joda-time%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 01 Dec 2013 00:31:39 +0000</pubDate><guid>https://mryqu.github.io/post/joda-time%E7%AC%94%E8%AE%B0/</guid><description>Joda简介 Joda项目致力于为Java平台提供替代API的一些质量保证的基础库。包括如下子项目：
Joda-Time -日期和时间库 Joda-Money -货币库 Joda-Beans -下一代JavaBeans Joda-Convert -字符串与对象转换库 Joda-Collect - 提供JDK或Google Guava没有的集合数据类型 Joda-Primitives -提供原始数据类型集合 Joda-Time简介 其中Joda-Time由于JDK自身时间日期API的不给力而被广泛使用，已经成为事实上的标准时间日期库。Joda-Time在JavaSE8将融入JDK API内，使用者可以使用java.time (JSR-310)内的API了。Joda-Time在时区、时间差和时间解析等方面支持多种历法系统，但仍然提供很简单的API。默认的历法是ISO8601标准，此外也支持Gregorian(现行公历、格里历)、Julian(儒略历)、Buddhist(佛历)、Coptic(科普特历)、Ethiopic(埃塞俄比亚历)和Islamic(伊斯兰历)历法系统。 为什么要使用Joda-Time（以下简称Joda）？考虑创建一个用时间表示的某个随意的时刻，例如2000年1月1日0时0分。如何创建一个用时间表示这个瞬间的JDK对象？使用java.util.Date？事实上这是行不通的，因为自JDK1.1 之后的每个 Java 版本的 Javadoc 都声明应当使用java.util.Calendar。Date中Date(intyear, int month, int date) 、Date(int year, int month, int date, inthrs, int min)、Date(int year, int month, int date, int hrs, int min,int sec)已经废弃、不建议使用，严重限制了您创建此类对象的途径。然而，Date确实有一个构造函数Date(long date)，您可以用来创建用时间表示某个瞬间的对象（除“当前时间”以外）。该方法使用距离1970年1月1日子时格林威治标准时间（也称为_epoch_）以来的毫秒数作为一个参数，对时区进行校正。 那么Calendar又如何呢？可以使用下面的方式创建必需的实例：
Calendar calendar = Calendar.getInstance(); calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0); 使用Joda，代码应该类似如下所示：
DateTime dateTime = new DateTime(2000, 1, 1, 0, 0, 0, 0); 这一行简单代码没有太大的区别。但是如果使问题稍微复杂化，假设希望在这个日期上加上90天并输出结果。使用JDK，需要如下代码：</description></item></channel></rss>
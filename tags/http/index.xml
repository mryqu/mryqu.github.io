<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>http on Mryqu's Notes</title><link>https://mryqu.github.io/tags/http/</link><description>Recent content in http on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 06 Jan 2016 06:01:08 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/http/index.xml" rel="self" type="application/rss+xml"/><item><title>为cURL库设置HTTP代理的代码片段</title><link>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link><pubDate>Wed, 06 Jan 2016 06:01:08 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%B8%BAcurl%E5%BA%93%E8%AE%BE%E7%BD%AEhttp%E4%BB%A3%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid><description>在twitcurl看到cURL库设置http代理的方法，记录一下。
void twitCurl::prepareCurlProxy() { if( m_curlProxyParamsSet ) { return; } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYUSERPWD, NULL ); curl_easy_setopt( m_curlHandle, CURLOPT_PROXYAUTH, (long)CURLAUTH_ANY ); std::string proxyIpPort(&amp;#34;&amp;#34;); if( getProxyServerIp().size() ) { utilMakeCurlParams( proxyIpPort, getProxyServerIp(), getProxyServerPort() ); } curl_easy_setopt( m_curlHandle, CURLOPT_PROXY, proxyIpPort.c_str() ); if( m_proxyUserName.length() &amp;amp;amp;&amp;amp;amp; m_proxyPassword.length() ) { std::string proxyUserPass; utilMakeCurlParams( proxyUserPass,getProxyUserName(),getProxyPassword() ); curl_easy_setopt( m_curlHandle,CURLOPT_PROXYUSERPWD,proxyUserPass.c_str() ); } m_curlProxyParamsSet = true; }</description></item><item><title>cURL速查表</title><link>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</link><pubDate>Thu, 30 Apr 2015 06:16:21 +0000</pubDate><guid>https://mryqu.github.io/post/curl%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid><description>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 cURL支持的通訊协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。
参考 cURL Man Page curl cheat-sheet</description></item><item><title>[Git] Git代理配置</title><link>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 01 Dec 2013 22:00:58 +0000</pubDate><guid>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>设置Git的http和https代理 git config --global http.proxy http://proxyUser:proxyPwd@proxyServer:proxyPort git config --global https.proxy https://proxyUser:proxyPwd@proxyServer:proxyPort 查询Git的http和https代理 git config --global --get http.proxy git config --global --get https.proxy 移除Git的http和https代理 git config --global --unset http.proxy git config --global --unset https.proxy</description></item><item><title>RESTful Web Services Cookbook笔记（一）</title><link>https://mryqu.github.io/post/restful_web_services_cookbook-note/</link><pubDate>Sat, 19 Oct 2013 08:10:45 +0000</pubDate><guid>https://mryqu.github.io/post/restful_web_services_cookbook-note/</guid><description>使用统一接口 HTTP是一种应用层协议，它定义了客户端与服务器之间的转移操作的表述形式。在此协议中，诸如GET，POST和DELETE之类的方法是对资源的操作。有了它，无须创造createOrder,getOrder,updateOrder等应用程序特定的操作了。 作为应用协议，HTTP的设计目标是在客户端和服务器之间保持对库、服务器、代理、缓存和其他工具的可见性。可见性是HTTP的一个核心特征。 一旦识别并设计资源，就可以使用GET方法获取资源的表述，使用PUT方法更新资源，使用DELETE方法删除资源，以及使用POST方法执行各种不安全和非幂等的操作。可以添加适当的HTTP标头来描述请求和相应。 以下特性完全取决于保持请求和相应的可见性：
缓存：缓存响应内容，并在资源修改时使缓存自动失效。 乐观并发控制：检测并发写入，并在操作过期的表述时防止资源发生变更。 内容协商：在给定资源的多个可用表述中，选择合适的表述。 安全性和幂等性：确保客户端可以重复或重试特定的HTTP请求。 HTTP通过以下途径来实现可见性：
HTTP的交互是无状态的，任何HTTP中介都可以推断出给定请求和响应的意义，而无须关联过去和将来的请求和响应。 HTTP使用一个统一接口，包括有OPTIONS，GET，HEAD，POST，DELETE和TRACE方法。接口中的每一个方法操作一个且仅一个资源。每个方法的语法和含义不会因应用程序和资源的不同而发生改变。 HTTP使用一种与MIME类似的信封格式进行表述编码。这种格式明确区分标头和内容。标头是可见的，除了创建、处理消息的部分，软件的其他部分都可以不用关心消息的内容。 保持可见性的另一方面是使用适当的状态码和状态消息，以便代理、缓冲和客户端可以决定请求的结果。 在某些情况下，可能需要权衡其他特性，如网络效率、客户端的便利性以及分离关注点，为此放弃可见性。当进行这种权衡时，应仔细分析对缓存、幂等性、安全性等特性的影响。 当有多个共享数据的资源，或一个操作修改多个资源时，需要权衡是否降低可见性（例如是否禁止缓存）以便获得更好的信息抽象、更松散的耦合程度、更好地网络效率、更好地资源粒度，或纯粹为了方便客户端使用。 可以通过带有应用程序状态的URI链接来保持应用程序状态而无需依赖服务器中内存中的会话。 安全性和幂等性是服务器要实现的HTTP方法的特征。当客户端发送GET、HEAD、OPTIONS、PUT或DELETE请求时，如果没有使用并发条件限制时，确保服务器提供相同响应。
|方法|是否安全?|是否幂等? |&amp;mdash;&amp;ndash; |GET|是|是 |HEAD|是|是 |OPTIONS|是|是 |PUT|否|是 |DELETE|否|是 |POST|否|否
客户端通过下列方法实现幂等的/安全的HTTP请求：
将GET、OPTIONS和HEAD视为只读操作，可按需随时可发送请求。 在网络或软件异常的情况下，通过If-Unmodified-Since/If-Match条件标头重发GET、PUT和DELETE请求。 不要重发POST请求，除非客户端（通过服务器文档）知道对特定资源的POST实现是幂等的。 Web基础设施严重依赖于GET方法的幂等性和安全性。客户端期望能够重复发起GET请求，而不必担心造成副作用。缓存依赖于不需访问源服务器就能提供已缓存表述的能力。 不要把GET方法用于不安全和非幂等操作。因为这样做可能造成永久性的、意想不到的、不符合需要的资源改变。 可以使用POST方法或PUT方法创建新资源。只有在客户端可以决定资源的URI时才使用PUT方法创建新资源；否则使用POST，由服务器决定新创建资源的URI（客户端请求可以使用Slug头建议新资源的URI）。 在以下场合中使用POST方法：
创建新的资源，把资源作为一个工厂 通过一个控制器资源来修改一个或多个资源 执行需要大数据输入的查询 在其他HTTP方法看上去不合适时，执行不安全或非幂等的操作。（缓存不会缓存这一方法的响应） 使用POST方式实现异步任务：服务器在接受到POST请求时，返回状态码202（Accepted），并包含一个让客户端可以跟踪异步任务状态的资源表述和客户端稍后检查状态的建议时间（ping-after）。 客户端使用GET请求查询异步任务状态，如服务器还在执行中，返回响应码200（OK）及包含当前状态的任务资源表述；如服务器成功完成，返回响应码303（SeeOther）以及包含新资源URL的Location头；如服务器任务失败，返回响应码200（OK）及任务失败的表述。 使用DELETE方法实现异步请求：服务器在收到DELETE请求，返回状态码202（Accepted），并包含一个让客户端可以跟踪异步任务状态的资源表述和客户端稍后检查状态的建议时间（ping-after）。 客户端使用GET请求查询异步任务状态，服务器返回响应码200（OK）及包含当前状态的任务资源表述。 避免使用非标准的自定义HTTP方法。当前比较有名的自定义方法包括WebDAV定义的方法、PATCH和MERGE。 HTTP服务器可能会使用自定义HTTP标头，比较有名的自定义HTTP包括X-Powered-By、X-Cache、X-Pingback、X-Forwarded-For及X-HTTP-Method-Override。实现客户端和服务器时，要让他们在没有发现需要的自定义标头时也不会失败。避免使用自定义HTTP标头改变HTTP方法的行为。
识别资源 从领域名词中识别资源。 直接将领域实体映射为资源可能导致资源效率低下且难以使用，可以通过网络效率、表述的多少以及客户端的应用程度来帮助确定资源的粒度。 粗粒度设计便于富客户端应用程序，更精细的资源颗粒可以更好地忙族缓存的要求。因此，应从客户端和网络的角度确定资源的粒度。下列原书可能会进一步影响资源粒度：
可缓存性 修改频率 可变性 仔细设计资源粒度，以确保使用更多缓存，减少修改频率，或将不可变数据从使用缓存较少、修改频率更高或可变数据分离出来，这样可以改善客户端和服务器端的效率。 基于应用程序特有的条件来识别相似的资源（例如共享同一数据库schema的资源，有相同特性或属性的资源），可以将这些有共性的资源组织成为集合。 基于客户端的使用模式、性能和延时要求，确定一些新的聚合其他资源的复合资源，来减少客户端与服务器的交互。 符合资源降低了统一接口的可见性，应为它们的表述中包含了和其他资源相重叠的资源。因此，在提供复合资源前,需要考虑一下几点：
如果在应用程序的请求很少，那么它可能不是一个好的选择。依赖缓存代理，从缓存中获取这些资源，也许能让客户端收益匪浅。 另一个因素是网络开销&amp;ndash;客户端与服务器之间的网络开销，服务区和后端服务或他所依赖的数据存储之间的网络开销。如果后者开销很大，那获取大量数据并在服务器上将他们组合成复合资源可能会增加客户端的延时，降低服务器的吞吐量。 想要改善延时，可以在客户端和服务器之间增加一个缓存层，并避免复合资源，进行一些负载测试来验证复合资源是否能起到改善作用。 最后，为每个客户端创建特定目标的复合资源并非是注重实效的做法。选择对Web服务最重要的客户端，设计复合资源来满足它们的需要。 像计算两地距离、行车路线、信用卡验证之类的计算或处理函数可被当作资源处理，并使用带有查询参数的HTTP GET获取函数输出表述。 当需要原子性修改多个资源时，可以为每个不同的操作指派一个控制器。客户端通过HTTP POST方法提交请求触发操作。如果操作结果是创建一个新资源，返回响应码201（Created）并在Location头里包含新资源的URL。如果操作结果是对一个或多个已有资源的修改，返回响应码303（See Other）并在Location头里包含客户端可用户获取修改表述的URL。如果服务器无法提供所有修改资源的单个URI，返回状态码200（OK）并在消息体内包含客户选可以用于了解操作结果的表述。 在RESTful Web服务中，控制器有助于对服务器和客户端之间进行关注分离，增进网络效率，让服务器端原子性地实现复杂操作。
设计表述 在HTTP设计中，发送发可以用一些名为实体头的标头来描述表述正文（也成为实体正文或消息正文）。有了这些标头，接收方可能在无须查看正文的情况下决定如何处理正文，还可以将解析正文所需要提前了解及猜测的内容尖刀最小程度。 使用以下标头来注解包含消息正文的表述：
58 [some bytes here] 0在没有确定接收到表述不带Transfer-Encoding: chunked前，不要检查Content-Length头是否存在。Content-Language如果使用某种语言对表述进行本地化，使用该标头来指定语言。值是两个字母的RFC5646语言标签，还可以在谋面带上连字符（-）和任意两个字母的国家代码。如en-US或kr。如果存在该标头，读取并存储它的值，记录下使用的语言。Content-MD5工具/软件在处理或存储表述时可能存在错误，需要提供一致性校验来验证实体正文的完整性，用该标头的值是表述正文（在进行内容压缩编码之后，分块传输编码之间计算）的MD5摘要。请注意，TCP使用checksum在传输层提供一致性校验，因此此标头对非可靠网络发送或接受大的表述时非常有用。Content-Encoding当使用gzip、compress或deflate对表述正文进行编码时，使用该标头。接收方在解析正文前需要先解压缩消息。客户端可以用Accept-Encoding头来表明自己偏好的Content-Encoding。然而，并没有一个标准的方式让客户端了解到服务器是否可以处理用给定编码压缩过的表述。让网络库代码来解压这些压缩过的表述。Last-Modified仅用在响应上的标头，值是一个时间戳，表示服务器最后修改表述或资源的时间。</description></item><item><title>Meta的http-equiv属性详解</title><link>https://mryqu.github.io/post/%E4%BB%8A%E5%A4%A9%E7%9C%8B%E7%9A%84%E4%B8%9C%E4%B8%9Cmeta%E7%9A%84http-equiv%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</link><pubDate>Fri, 03 Oct 2008 19:25:51 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BB%8A%E5%A4%A9%E7%9C%8B%E7%9A%84%E4%B8%9C%E4%B8%9Cmeta%E7%9A%84http-equiv%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</guid><description>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meta标签的http-equiv属性语法格式是：＜meta http-equiv=&amp;ldquo;参数&amp;rdquo; content=&amp;ldquo;参数变量值&amp;quot;＞；其中http-equiv属性主要有以下几种参数：
Expires(期限) 说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法：＜meta http-equiv=&amp;ldquo;expires&amp;rdquo; content=&amp;ldquo;Wed, 20 Jun 2007 22:33:00 GMT&amp;quot;＞ 注意：必须使用GMT的时间格式。 Pragma(cache模式) 说明：禁止浏览器从本地计算机的缓存中访问页面内容。 用法：＜meta http-equiv=&amp;ldquo;Pragma&amp;rdquo; content=&amp;ldquo;no-cache&amp;quot;＞ 注意：这样设定，访问者将无法脱机浏览。 Refresh(刷新) 说明：自动刷新并指向新页面。 用法：＜meta http-equiv=&amp;ldquo;Refresh&amp;rdquo; content=&amp;ldquo;2；URL=http://www.net.cn/&amp;ldquo;＞ 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 Set-Cookie(cookie设定) 说明：如果网页过期，那么存盘的cookie将被删除。 用法：＜meta http-equiv=&amp;ldquo;Set-Cookie&amp;rdquo; content=&amp;ldquo;cookievalue=xxx; expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/&amp;ldquo;＞ 注意：必须使用GMT的时间格式。 Window-target(显示窗口的设定) 说明：强制页面在当前窗口以独立页面显示。 用法：＜meta http-equiv=&amp;ldquo;Window-target&amp;rdquo; content=&amp;quot;_top&amp;quot;＞ 注意：用来防止别人在框架里调用自己的页面。 content-Type(显示字符集的设定) 说明：设定页面使用的字符集。 用法：＜meta http-equiv=&amp;ldquo;content-Type&amp;rdquo; content=&amp;ldquo;text/html; charset=gb2312&amp;quot;＞ Pics-label(网页等级评定) 用法：网页等级评定 说明：在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的。 还有Page_Enter、Page_Exit…… 补充： 设定进入页面时的特殊效果
设定离开页面时的特殊效果
Duration的值为网页动态过渡的时间，单位为秒。
Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表： 0 盒状收缩 1 盒状放射
2 圆形收缩 3 圆形放射
4 由下往上 5 由上往下</description></item></channel></rss>
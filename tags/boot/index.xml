<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>boot on Mryqu's Notes</title><link>https://mryqu.github.io/tags/boot/</link><description>Recent content in boot on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 04 Dec 2015 06:08:47 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/boot/index.xml" rel="self" type="application/rss+xml"/><item><title>[Spring Boot] 让非Spring管理的类获得一个Bean</title><link>https://mryqu.github.io/post/spring_boot_%E8%AE%A9%E9%9D%9Espring%E7%AE%A1%E7%90%86%E7%9A%84%E7%B1%BB%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAbean/</link><pubDate>Fri, 04 Dec 2015 06:08:47 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_%E8%AE%A9%E9%9D%9Espring%E7%AE%A1%E7%90%86%E7%9A%84%E7%B1%BB%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAbean/</guid><description>我有一个工具类，它既会被SpringBean调用，也会被非Spring管理的类调用。我想在这个工具类里获得Spring注入了拦截器的RestTemplate。一开始考虑了ApplicationContextAware、ContextLoaderListener和ContextLoaderServlet，最后采用了下面这种改动最小的解决方案。
示例代码 Application.java @SpringBootApplication public class Application{ public static void main(String[] args) { final ApplicationContext applicationContext = SpringApplication.run(Application.class, args); MyUtil.setApplicationContext(applicationContext); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } MyUtil.java public class MyUtil { private static ApplicationContext applicationContext; public static void setApplicationContext(ApplicationContext context) { applicationContext = context; } public static void doSomething() { RestTemplate _restTemplate = applicationContext.getBean(RestTemplate.class); ........ } }</description></item><item><title>[Spring Boot] Use alwaysUseFullPath for Spring MVC URL mapping</title><link>https://mryqu.github.io/post/spring_boot_use_alwaysusefullpath_for_spring_mvc_url_mapping/</link><pubDate>Thu, 03 Dec 2015 06:38:56 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_use_alwaysusefullpath_for_spring_mvc_url_mapping/</guid><description>简介 SpringMVC的URL映射有一个控制路径匹配的参数alwaysUseFullPath。当它被设置为true后，总是使用当前servlet上下文中的全路径进行URL查找，否则使用当前servlet映射内的路径。默认为false。下面示例一下当一个请求的全路径通过servlet映射找到所服务的RequestDispatcherservelet后alwaysUseFullPath为false时URL映射表现：
servlet mapping = &amp;ldquo;/*&amp;rdquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/test/a&amp;rdquo; servlet mapping = &amp;ldquo;/&amp;rdquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/test/a&amp;rdquo; servlet mapping = &amp;ldquo;/test/*&amp;rdquo;; request URI = &amp;ldquo;/test/a&amp;rdquo; -&amp;gt; &amp;ldquo;/a&amp;rdquo; servlet mapping = &amp;ldquo;/test&amp;rdquo;; request URI = &amp;ldquo;/test&amp;rdquo; -&amp;gt; &amp;quot;&amp;quot; servlet mapping = &amp;ldquo;/*.test&amp;rdquo;; request URI = &amp;ldquo;/a.test&amp;rdquo; -&amp;gt; &amp;quot;&amp;quot; 从org.springframework.web.util.UrlPathHelper的getLookupPathForRequest方法可知，当alwaysUseFullPath为true时使用getPathWithinApplication获得待查找的全路径，否则使用getPathWithinServletMapping获得待查找的剩余路径。 如果对alwaysUseFullPath的设置进行修改，对RestController的请求映射也要做相应的设置修改。
@RequestMapping(value = {&amp;#34;**/test/dosomething**&amp;#34;}, method = RequestMethod.POST, produces = { MediaType.APPLICATION_JSON_VALUE }) 假设servlet映射为&amp;quot;/test/*&amp;ldquo;且RestControoler仅在方法级别进行请求映射，如果alwaysUseFullPath为true时请求映射为上面的&amp;rdquo;/test/dosomething&amp;quot;。则在alwaysUseFullPath改为false后，请求映射相应改为&amp;quot;/dosomething&amp;quot;即可。
alwaysUseFullPath设置范例 想在SpringBoot应用中设定alwaysUseFullPath为true，可通过BeanPostProcessor完成其设置。
@SpringBootApplication public class Application implements BeanPostProcessor { public static void main(String[] args) { final ApplicationContext applicationContext = SpringApplication.</description></item><item><title>[Spring Boot] 使用多个Servlet</title><link>https://mryqu.github.io/post/spring_boot_%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAservlet/</link><pubDate>Wed, 28 Oct 2015 06:07:53 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAservlet/</guid><description>当使用Spring boot的嵌入式servlet容器时，可以通过Springbean或扫描Servlet组件的方式注册Servlet、Filter和Servlet规范的所有监听器(例如HttpSessionListener)。
当urlMapping不是很复杂时，可以通过ServletRegistrationBean、FilterRegistrationBean和ServletListenerRegistrationBean获得完整控制。如果bean实现了ServletContextInitializer接口的话则可以直接注册。 当使用@ServletComponentScan扫描Servlet组件时，Servlet、过滤器和监听器可以是通过@WebServlet、@WebFilter和@WebListener自动注册 示例代码 Application.java package com.yqu.multiservlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.embedded.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.web.servlet.DispatcherServlet; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean public ServletRegistrationBean dispatcherRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean(dispatcherServlet); registration.addUrlMappings(&amp;#34;/hirest/*&amp;#34;); printStacks(); return registration; } @Bean public ServletRegistrationBean servletRegistrationBean() { printStacks(); return new ServletRegistrationBean( new SigninServlet(), &amp;#34;/signin&amp;#34;); } private void printStacks() { StackTraceElement[] elements = Thread.currentThread().getStackTrace(); System.</description></item><item><title>从Gradle bootRun任务向Spring Boot应用传递环境变量</title><link>https://mryqu.github.io/post/%E4%BB%8Egradle_bootrun%E4%BB%BB%E5%8A%A1%E5%90%91spring_boot%E5%BA%94%E7%94%A8%E4%BC%A0%E9%80%92%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Tue, 08 Sep 2015 06:32:44 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BB%8Egradle_bootrun%E4%BB%BB%E5%8A%A1%E5%90%91spring_boot%E5%BA%94%E7%94%A8%E4%BC%A0%E9%80%92%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>尝试了从Gradle bootRun任务中传递环境变量给Spring Boot应用，下面是示例代码和演示。
示例代码 Application.java package com.yqu.gradlesysprop; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; @SpringBootApplication public class Application { private static final Logger log = LoggerFactory.getLogger(Application.class); public static void main(String[] args) { SpringApplication app = new SpringApplication(Application.class); app.setWebEnvironment(false); app.setShowBanner(false); app.run(args); } @Bean public CommandLineRunner demo1() { return (args) -&amp;gt; { log.info(&amp;#34;mryqu.prop.test=&amp;#34;+ System.getProperty(&amp;#34;mryqu.prop.test&amp;#34;)); }; } } build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; jar { baseName = &amp;#39;hello-gradlesysprop&amp;#39; version = &amp;#39;0.</description></item><item><title>[Spring Boot] 创建超媒体驱动的Mail服务</title><link>https://mryqu.github.io/post/spring_boot_%E5%88%9B%E5%BB%BA%E8%B6%85%E5%AA%92%E4%BD%93%E9%A9%B1%E5%8A%A8%E7%9A%84mail%E6%9C%8D%E5%8A%A1/</link><pubDate>Mon, 03 Aug 2015 06:46:47 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_%E5%88%9B%E5%BB%BA%E8%B6%85%E5%AA%92%E4%BD%93%E9%A9%B1%E5%8A%A8%E7%9A%84mail%E6%9C%8D%E5%8A%A1/</guid><description>Spring与Mail的集成 Spring框架为邮件发送提供了一个有用的工具库，可为用户屏蔽底层邮件系统细节，并负责代表客户端负责低层资源处理。 org.springframework.mail包是Spring框架邮件支持的根级包。发送邮件的核心接口是MailSender 接口；封装了简单邮件_from_和_to_等属性的简单对象类是 SimpleMailMessage 。该包也包含对底层邮件系统进行更高级抽象的分层检查异常，其根异常为MailException。 org.springframework.mail.javamail.JavaMailSender 接口MailSender为添加了专业的_JavaMail_ 功能，例如MIME消息支持。JavaMailSender 也为JavaMailMIME消息提供了回调接口org.springframework.mail.javamail.MimeMessagePreparator。
Spring HATEOAS HATEOAS (Hypermedia as the Engine of ApplicationState，超媒体即应用状态引擎)是REST应用架构的一个约束。Spring HATEOAS是一个用于支持实现超媒体驱动的RESTWeb服务的开发库。它提供一些API用于同Spring特别是SpringMVC一起使用时轻松创建遵循HATEOAS原则的REST表述，其试图解决的核心问题是链接创建和表述装配。功能：
用于链接、资源表述模型的模型类 用于指向Spring MVC控制器方法的链接建造者API 对HAL之类的多媒体格式的支持 示例 Application.java package com.yqu.mail; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } MailServerVO.java package com.yqu.mail; import org.springframework.hateoas.ResourceSupport; import java.io.Serializable; import java.util.Properties; public class MailServerVO extends ResourceSupport implements Serializable { private String host; private Integer port; private String userName; private String password; private String defaultEncoding; private Properties properties; public MailServerVO() {} public MailServerVO( String host, Integer port, String userName, String password, String defaultEncoding, Properties properties) { this.</description></item><item><title>[Spring Boot] 监控和管理Spring Boot应用</title><link>https://mryqu.github.io/post/spring_boot_%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86spring_boot%E5%BA%94%E7%94%A8/</link><pubDate>Sat, 11 Jul 2015 06:53:41 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86spring_boot%E5%BA%94%E7%94%A8/</guid><description>本博文在[Spring Boot] Hello Spring LDAP 基础上稍作修改，尝试一下监控和管理Spring Boot应用。
application.properties改动 server.context-path=/HelloSpringLdapOdm server.port=8080 spring.profiles.active=test,dev # spring.dao.exceptiontranslation.enabled=false yqu.ldap.url=ldap://127.0.0.1:18880 yqu.ldap.userDN=uid=admin,ou=system yqu.ldap.password=secret yqu.ldap.base=dc=jayway,dc=se yqu.ldap.clean=true management.port=8081 management.address=127.0.0.1 endpoints.shutdown.enabled=true applicationDefaultJvmArgs: [ &amp;#34;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=55558&amp;#34; ] 测试 autoconfig: Displays an auto-configuration report showing allauto-configuration candidates and the reason why they ‘were’ or‘were not’ applied. beans: Displays a complete list of all the Spring beans in yourapplication. configprops: Displays a collated list of all@ConfigurationProperties. dump: Performs a thread dump. env: Exposes properties from Spring’sConfigurableEnvironment.</description></item><item><title>[Spring Boot] Hello CommandLineRunner</title><link>https://mryqu.github.io/post/spring_boot_hello_commandlinerunner/</link><pubDate>Wed, 08 Jul 2015 06:02:53 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_hello_commandlinerunner/</guid><description>通过CommandLineRunner，可在所有Spring Bean和ApplicationContext被创建后执行一些可以访问命令行参数的任务。如想指定多个CommandLineRunnerBean的执行顺序，可以实现org.springframework.core.Ordered接口或添加org.springframework.core.annotation.Order注解。
示例代码 Application.java package com.yqu.cmdlinerunner; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.Banner; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.DependsOn; import org.springframework.core.annotation.Order; import org.springframework.core.annotation.OrderUtils; import java.util.Arrays; @SpringBootApplication public class Application { private static final Logger log = LoggerFactory.getLogger(Application.class); public static void main(String[] args) { SpringApplication app = new SpringApplication(Application.class); app.setWebEnvironment(false); app.setShowBanner(false); app.run(args); } @Bean(name=&amp;#34;demo1&amp;#34;) @DependsOn(&amp;#34;demo2&amp;#34;) @Order(8) public CommandLineRunner demo1() { return (args) -&amp;gt; { log.info(&amp;#34;demo1:order=&amp;#34;+ OrderUtils.getOrder(this.getClass())+ &amp;#34;:args=&amp;#34;+Arrays.toString(args)); //log.info(getStacks()); }; } @Bean(name=&amp;#34;demo2&amp;#34;) @Order(1) public CommandLineRunner demo2() { return (args) -&amp;gt; { log.</description></item><item><title>[Spring Boot] Hello Spring LDAP</title><link>https://mryqu.github.io/post/spring_boot_hello_spring_ldap/</link><pubDate>Mon, 06 Jul 2015 06:20:32 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_hello_spring_ldap/</guid><description>这个帖子设定了标题后，一直忙于其他事情，拖延了两个月终于能够结贴了。
部分示例代码 LdapConfiugration.java package com.yqu.ldap.odm; import com.yqu.ldap.odm.dao.*; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.*; import org.springframework.core.env.Environment; import org.springframework.ldap.core.LdapTemplate; import org.springframework.ldap.core.support.LdapContextSource; import javax.annotation.PostConstruct; @Configuration @ComponentScan(basePackages={&amp;#34;com.yqu.ldap.odm&amp;#34;}) public class LdapConfiugration { @Autowired private Environment _environment; private static Log log = LogFactory.getLog(LdapConfiugration.class); @PostConstruct private void init() { log.debug(&amp;#34;environment: yqu.ldap.url:&amp;#34; + _environment.getProperty(&amp;#34;yqu.ldap.url&amp;#34;)); log.debug(&amp;#34;environment: yqu.ldap.userDN:&amp;#34; + _environment.getProperty(&amp;#34;yqu.ldap.userDN&amp;#34;)); log.debug(&amp;#34;environment: yqu.ldap.password:&amp;#34; + _environment.getProperty(&amp;#34;yqu.ldap.password&amp;#34;)); log.debug(&amp;#34;environment: yqu.ldap.base:&amp;#34; + _environment.getProperty(&amp;#34;yqu.ldap.base&amp;#34;)); } @Bean(name=&amp;#34;ldapContextSource&amp;#34;) public LdapContextSource ldapContextSource() { String url = _environment.getProperty(&amp;#34;yqu.ldap.url&amp;#34;); String user = _environment.</description></item><item><title>[Spring Data] 调试H2数据库</title><link>https://mryqu.github.io/post/spring_data_%E8%B0%83%E8%AF%95h2%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sun, 28 Jun 2015 01:00:55 +0000</pubDate><guid>https://mryqu.github.io/post/spring_data_%E8%B0%83%E8%AF%95h2%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>我将Spring的两个入门指南Building a RESTful Web Service和Accessing Data with JPA融到一起，测试成功。那接下来的一个问题就是怎么查看H2数据库内容并进行调试？
配置H2 Web控制台 为了解决这个问题，我首先增加了src/resources/application.properties配置文件，内容如下：
spring.profiles.active=dev spring.h2.console.enabled=true 在H2 Web控制台上操作 启动Spring Boot应用，在浏览器中进入http://localhost:8080/h2_console/即可进入H2数据库的Web控制台了。 配置IDEA IntelliJ数据源 如果不使用H2 Web控制台的话，在IDEA IntelliJ集成开发环境中也可以通过配置H2数据源进行数据库操作。 解决数据库表不存在问题 上面的玩法有个问题，那就是没看到Accessing Data with JPA里面创建的CUSTOMER表，对不对？为了解决这个问题，在src/resources/application.properties配置文件增加如下内容：
spring.profiles.active=dev spring.h2.console.enabled=true spring.datasource.url=jdbc:h2:~/test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password= 搞定，收工！
参考 Using H2’s web console in Spring Boot
Common application properties for Spring Boot
H2 Console</description></item><item><title>Spring Boot Example：Rest Exception Handling</title><link>https://mryqu.github.io/post/spring_boot_examplerest_exception_handling/</link><pubDate>Tue, 02 Jun 2015 00:14:40 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_examplerest_exception_handling/</guid><description>要给同事做个Rest异常处理的演示，顺便用用Spring Boot和Gradle构建。 首先新建一个项目：rest-exception-handling。
rest-exception-handling/src/main/java/com/yqu/rest目录 Application.java package com.yqu.rest; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } GreetingController.java package com.yqu.rest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; @RestController public class GreetingController { @Autowired private GreetingService service; @RequestMapping(value = &amp;#34;/&amp;#34;, method = RequestMethod.GET) public ModelAndView home(Model m){ System.out.println(&amp;#34;home&amp;#34;); return new ModelAndView(&amp;#34;index&amp;#34;); } @RequestMapping(value = &amp;#34;/greeting&amp;#34;, method = RequestMethod.GET) public @ResponseBody GreetingVO greeting(@RequestParam(value=&amp;#34;name&amp;#34;) String name) throws GreetingException { System.</description></item><item><title>[Spring Boot] 访问JSP</title><link>https://mryqu.github.io/post/spring_boot_%E8%AE%BF%E9%97%AEjsp/</link><pubDate>Fri, 08 May 2015 05:53:04 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_%E8%AE%BF%E9%97%AEjsp/</guid><description>需求 我的Spring Boot web应用中用到了JSP，可是访问始终404。
@Controller public class TestController { @RequestMapping(&amp;#34;/test&amp;#34;) public String webapp(Map model) { return &amp;#34;WEB-INF/index.jsp&amp;#34;; } } 解决方案是增加tomcat-embed-jasper依赖，此外可选性地增加了jstl依赖。
Gradle dependencies { ...... // jsps providedRuntime (&amp;#39;org.apache.tomcat.embed:tomcat-embed-jasper&amp;#39;) } Maven</description></item></channel></rss>
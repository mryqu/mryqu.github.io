<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>region on Mryqu's Notes</title><link>https://mryqu.github.io/tags/region/</link><description>Recent content in region on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 28 Jun 2013 16:16:14 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/region/index.xml" rel="self" type="application/rss+xml"/><item><title>嵌套的动态GemFire region研究</title><link>https://mryqu.github.io/post/gemfire_nesting-dynamic-region/</link><pubDate>Fri, 28 Jun 2013 16:16:14 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_nesting-dynamic-region/</guid><description>研究目的和结论 研究多级动态region是否可行，结论可行 研究嵌套region(一个region是另一个region的值)是否可行，结论可行 Java代码 import java.util.Set; import com.gemstone.gemfire.cache.Cache; import com.gemstone.gemfire.cache.CacheFactory; import com.gemstone.gemfire.cache.DynamicRegionFactory; import com.gemstone.gemfire.cache.Region; public class EmbededDynamicRegion { public static void main(String[] args) { System.out.println(&amp;#34;\nConnecting to the distributed system and creating the cache.&amp;#34;); Cache cache = null; try { // Create the cache which causes the cache-xml-file to be parsed cache = new CacheFactory().set(&amp;#34;name&amp;#34;, &amp;#34;yqu_test_cache&amp;#34;) .set(&amp;#34;cache-xml-file&amp;#34;, &amp;#34;xml/YquTest.xml&amp;#34;).create(); // Get the exampleRegion Region yquRegion = cache.getRegion(&amp;#34;yqu_region&amp;#34;); printRegionFullPath(yquRegion); DynamicRegionFactory dynRegFactory = DynamicRegionFactory.get(); for(int i=0;i&amp;lt;3;i++) { Region keyRegion = dynRegFactory.</description></item><item><title>GemFire Region分类</title><link>https://mryqu.github.io/post/gemfire_region-type/</link><pubDate>Wed, 15 May 2013 07:28:53 +0000</pubDate><guid>https://mryqu.github.io/post/gemfire_region-type/</guid><description>GemFire开发指南6.5的第4.2节仅列举了分区、复制（分布式）、分布式（非复制）和本地四种Region类型，但RegionShortcut类却定义了23个快捷预定义属性Region。Region的主要行为取决于数据策略、关注策略、范围、本地最大内存和冗余拷贝数（仅用于分区Region）、逐出算法和动作。
Region快捷预定义属性 数据策略 范围 本地最大内存注1 冗余拷贝数注1 逐出算法 逐出动作 LOCAL NORMAL LOCAL LOCAL_HEAP_LRU NORMAL LOCAL LRU_HEAP LOCAL_DESTROY LOCAL_OVERFLOW NORMAL LOCAL LRU_HEAP OVERFLOW_TO_DISK LOCAL_PERSISTENT PERSISTENT_REPLICATE LOCAL LOCAL_PERSISTENT_OVERFLOW PERSISTENT_REPLICATE LOCAL LRU_HEAP OVERFLOW_TO_DISK PARTITION PARTITION PARTITION_HEAP_LRU PARTITION LRU_HEAP LOCAL_DESTROY PARTITION_OVERFLOW PARTITION LRU_HEAP OVERFLOW_TO_DISK PARTITION_PERSISTENT PERSISTENT_PARTITION PARTITION_PERSISTENT_OVERFLOW PERSISTENT_PARTITION LRU_HEAP OVERFLOW_TO_DISK PARTITION_PROXY PARTITION 0 PARTITION_PROXY_REDUNDANT PARTITION 0 1 PARTITION_REDUNDANT PARTITION 1 PARTITION_REDUNDANT_HEAP_LRU PARTITION 1 LRU_HEAP LOCAL_DESTROY PARTITION_REDUNDANT_OVERFLOW PARTITION 1 LRU_HEAP OVERFLOW_TO_DISK PARTITION_REDUNDANT_PERSISTENT PERSISTENT_PARTITION 1 PARTITION_REDUNDANT_
PERSISTENT_OVERFLOW PERSISTENT_PARTITION 1 LRU_HEAP OVERFLOW_TO_DISK REPLICATE REPLICATE DISTRIBUTED_ACK REPLICATE_HEAP_LRU PRELOAD DISTRIBUTED_ACK LRU_HEAP LOCAL_DESTROY REPLICATE_OVERFLOW REPLICATE DISTRIBUTED_ACK LRU_HEAP OVERFLOW_TO_DISK REPLICATE_PERSISTENT PERSISTENT_REPLICATE DISTRIBUTED_ACK REPLICATE_PERSISTENT_OVERFLOW PERSISTENT_REPLICATE DISTRIBUTED_ACK LRU_HEAP OVERFLOW_TO_DISK REPLICATE_PROXY EMPTY DISTRIBUTED_ACK 注1：仅用于分区region</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>api on Mryqu's Notes</title><link>https://mryqu.github.io/tags/api/</link><description>Recent content in api on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 21 May 2019 06:01:23 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/api/index.xml" rel="self" type="application/rss+xml"/><item><title>体验Salesforce API</title><link>https://mryqu.github.io/post/%E4%BD%93%E9%AA%8Csalesforce-api/</link><pubDate>Tue, 21 May 2019 06:01:23 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%93%E9%AA%8Csalesforce-api/</guid><description>继前一博文[Salesforce dataLoader一览](/post/Salesforce dataLoader一览)，这次就开始体验一把Salesforce API了。
准备工作 通过developer.salesforce.com/signup获得Salesforce开发版 确保激活了API权限
创建connected app：scnydqTest1
获取scnydqTest1的sonsumer key和secret OAuth鉴权 Salesforce的OAuth鉴权支持三种流程：
web服务器流程：适用于服务器可以保存consumer secret 用户代理流程：适用于应用无法安全保存consumer secret 用户密码流程：应用使用用户凭证直接访问 OAuth鉴权之web服务器流程 验证按照Understanding the User-Agent OAuth Authentication Flow进行。
https://login.salesforce.com/services/oauth2/authorize?response_type=code&amp;amp;client_id={scnydqTest1_appConsumerKey}&amp;amp;redirect_uri=https%3A%2F%2Flogin.salesforce.com%2Fservices%2Foauth2%2Fsuccess 鉴权：
通过跳转URL获取code：
通过code、consumer key和consumer secret获取access token：
OAuth鉴权之用户代理流程 验证按照How Are Apps Authenticated with the Web Server OAuth Authentication Flow?进行。
https://login.salesforce.com/services/oauth2/authorize?response_type=token&amp;amp;client_id={scnydqTest1_appConsumerKey}&amp;amp;redirect_uri=https%3A%2F%2Flogin.salesforce.com%2Fservices%2Foauth2%2Fsuccess 认证： 鉴权：
通过跳转URL获取access_token：
返回URL为：
https://login.salesforce.com/services/oauth2/success#access_token=00D2v000000R9tt%21AXXXXXi.&amp;amp;instance_url=https%3A%2F%2Fap15.salesforce.com&amp;amp;id=https%3A%2F%2Flogin.salesforce.com%2Fid%2F00D2XXXXXC%2F005XXXXXL&amp;amp;issued_at=1XXXXX8&amp;amp;signature=iXXXXXI%3D&amp;amp;scope=id+api&amp;amp;token_type=Bearer OAuth鉴权之用户密码流程 验证按照Understanding the Username-Password OAuth Authentication Flow进行。
REST调用 此处走一下Salesforce官方的快速入门示例。
获取Salesforce版本 关于版本的介绍详见Apex Code Versions。
使用Salesforce版本获取可用资源 使用一个资源获取可用对象列表 获取一个对象的元数据描述 获取一个对象的列信息 执行SOQL查询获取Account记录的某些指定列的值 限额 REST API与SOAP API使用相同的数据模型和标准对象。REST API遵循SOAP API的限额。</description></item><item><title>初探Salesforce API</title><link>https://mryqu.github.io/post/%E5%88%9D%E6%8E%A2salesforce-api/</link><pubDate>Fri, 17 May 2019 06:00:05 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%88%9D%E6%8E%A2salesforce-api/</guid><description>最近研究一下如何从Salesforce抓取数据，首先看了一下几个ODBC driver。
DataDirect 文档 easysoft devart cdata 怎么没有Salesforce自家的驱动，都是第三方的。
再找找看，找到了Salesforce SOAP API Developer Guide和REST API Developer Guide。
既然有了SOAP/REST API，何必再看ODBC driver了。</description></item><item><title>swagger-codegen 2.2.3与2.1.5区别</title><link>https://mryqu.github.io/post/swagger-codegen_2.2.3%E4%B8%8E2.1.5%E5%8C%BA%E5%88%AB/</link><pubDate>Sun, 23 Jul 2017 06:13:46 +0000</pubDate><guid>https://mryqu.github.io/post/swagger-codegen_2.2.3%E4%B8%8E2.1.5%E5%8C%BA%E5%88%AB/</guid><description>支持的语法 $ java -jar swagger-codegen-cli-2.1.6.jar langs Available languages: [android, aspnet5, async-scala, csharp, dart, flash, python-flask, go, java, jaxrs, jaxrs-cxf, jaxrs-resteasy, inflector, javascript, javascript-closure-angular, jmeter, nodejs-server, objc, perl, php, python, qt5cpp, ruby, scala, scalatra, silex-PHP, sinatra, slim, spring-mvc, dynamic-html, html, swagger, swagger-yaml, swift, tizen, typescript-angular, typescript-node, akka-scala, CsharpDotNet2, clojure, haskell-servant] $ java -jar swagger-codegen-cli-2.2.3.jar langs Available languages: [akka-scala, android, apache2, apex, aspnet5, aspnetcore, async-scala, bash, csharp, clojure, cwiki, cpprest, CsharpDotNet2, dart, elixir, eiffel, erlang-server, finch, flash, python-flask, go, go-server, groovy, haskell, jmeter, jaxrs-cxf-client, jaxrs-cxf, java, inflector, jaxrs-cxf-cdi, jaxrs-spec, jaxrs, msf4j, java-play-framework, jaxrs-resteasy-eap, jaxrs-resteasy, javascript, javascript-closure-angular, java-vertx, kotlin, lumen, nancyfx, nodejs-server, objc, perl, php, php-symfony, powershell, pistache-server, python, qt5cpp, rails5, restbed, ruby, scala, scalatra, silex-PHP, sinatra, slim, spring, dynamic-html, html2, html, swagger, swagger-yaml, swift4, swift3, swift, tizen, typescript-angular2, typescript-angular, typescript-fetch, typescript-jquery, typescript-node, undertow, ze-ph] swagger-codegen 2.</description></item><item><title>玩玩ArcGIS REST API</title><link>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9arcgis_rest_api/</link><pubDate>Fri, 19 May 2017 05:49:55 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9arcgis_rest_api/</guid><description>了解Esri和ArcGIS 美国环境系统研究所公司（Environmental Systems Research Institute, Inc. 简称Esri公司）成立于1969年，总部设在美国加利福利亚州雷德兰兹市，是世界最大的地理信息系统技术提供商。 ArcGIS是Esri公司集40余年地理信息系统（GIS）咨询和研发经验，奉献给用户的一套完整的GIS平台产品，具有强大的地图制作、空间数据管理、空间分析、空间信息整合、发布与共享的能力。
ArcGIS REST API ArcGIS REST API可用于包括ArcGIS Online在内的ArcGIS平台，包括：
Maps—随时可用的底图、参考层等。可用于快速为您的本地或全球数据添加上下文或背景。一些ArcGIS Online地图有页面主题，可以提供出你的应用所需的全部信息。 World Geocoding Service—通过文本地址、商业名等查找位置，该服务也提供反向服务：通过地理坐标查找最近的地址。 Directions and Routing Service (Network Analysis Service)—解决各种路线规划问题，例如简单的点到点路由、复杂的船舶航线规划、及行驶时间分析。 GeoEnrichment Service—GeoEnrichment 服务借助本地化的人口、场所以及商业信息丰富了用户的地理数据。提交某个点、面、地址或地名后，可通过该服务了解该地区居民的生活习惯和生活方式、附近的商业类型以及区域邮政编码等信息。 Spatial Analysis Service—各种可用于执行通用GIS分析的任务。传统上，包括查找热点和对周边汇总在内的许多任务都需要深度学习和专业知识才能运行。而这些空间分析任务仅包含少量需要研究的参数，也能获得相当不错的结果。 Elevation Analysis service—高程分析服务允许您执行高程分析（轮廓，视角，总结高程）和水文分析（流域和跟踪下游）的各种操作。这些服务参考的数据由Esri托管和策划。 ArcGIS REST API有些是免费的，有些是付费。付费操作需要订阅ArcGIS Online，并减扣账户积分。 使用需付费API时，需要在请求中通过token参数指定访问令牌。获取ArcGIS REST API所需访问令牌的方法，请参见前一博文ArcGIS认证和登录。
响应数据格式 对于ArcGIS REST API，有些响应支持JSON、PJSON（个人理解就是完美打印版的JSON）、XML和BIN格式中的一种或多种。可在请求时通过f参数指定。
使用GeoEnrichment API GeoEnrichment服务能力、属性和限制可以通过下列请求获得：
http://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/GeoEnrichment/?f=pjson 由响应可知，GeoEnrichment端点支持Enrich、CreateReport、Reports、Countries、DataCollections、StandardGeographyLevels这几种操作。
Countries操作 首先试一下国家列表：
http://geoenrich.arcgis.com/arcgis/rest/services/World/GeoenrichmentServer/Geoenrichment/Countries?f=pjson 当然Countries操作也可用于获取单个国家信息： StandardGeographyLevels操作 StandardGeographyLevels服务返回有效地理数据层列表。服务结果是BAIDNamePairs数组，包含数据层ID及相应名称。这些ID可被用于在其他分析中指定数据层。 下面的请求示例列举CN的有效地理数据层列表：
http://geoenrich.arcgis.com/arcgis/rest/services/World/GeoenrichmentServer/Geoenrichment/StandardGeographyLevels/CN?f=pjson DataCollections操作 GeoEnrichment服务使用数据集合的概念定义服务返回的属性。更具体地说，数据集合是用于丰富输入特性的预先组合的属性列表。作为输入特性，集合属性可以描述所提交位置或区域的各种类型信息，例如人口特征和地理上下文。
http://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/Geoenrichment/dataCollections?f=pjson Reports和CreateReport操作 创建报告操作可为描述输入区域的各种用例创建各种高质量报告。如果使用一个点作为研究区域，该服务将围绕该点创建1英里的环形缓冲区以收集和附加丰富数据。或者，您可以围绕该点创建环形缓冲区或特定驾驶时间可达区域，生成包含有关人口特征、消费者支出、业务或市场潜力等相关信息的PDF或Excel报告。 报告选项可用于描述和更好地了解市场，顾客/客户以及特定领域商业竞争。 下面的请求示例列举US数据集中有效报告列表：
http://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/Geoenrichment/Reports/US?f=pjson 下面的请求示例生成以坐标-117.1956、34.0572为中心一英里区域的人口和收入概况报告(report指定为dandi，从上一示例结果中可知为人口和收入概况报告)：
http://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/GeoEnrichment/CreateReport?studyAreas=[{&amp;#34;geometry&amp;#34;:{&amp;#34;x&amp;#34;:-117.1956,&amp;#34;y&amp;#34;:34.0572}}]&amp;amp;report=dandi&amp;amp;f=bin&amp;amp;format=PDF&amp;amp;token={YOUR_TOKEN} Enrich操作 提供地点或区域的事实数据。输入可为：</description></item><item><title>玩一下Quandl API</title><link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bquandl_api/</link><pubDate>Thu, 11 May 2017 06:00:43 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bquandl_api/</guid><description>Quandl是为投资专业人士提供财务、经济和替代数据的平台。 Quandl来源于500多家出版商的数据。所有Quandl的数据都可通过API访问，也可以通过包含R、Python、Ruby等多种编程语言及Excel、SAS等软件进行原生访问。Quandl的来源包括联合国，世行和中央银行等提供商的公开数据、来自CLS集团，Zacks和ICE等供应商的核心财务数据、Dun＆Bradstreet的其他数据、以及许多机密来源。 **什么是替代数据？**替代数据的范围非常广泛，起初主要包含了未加工的、原始的公司文件、历史市场价格、投资者表现等数据，而现在替代数据已经涵盖任何从移动手机数据到职位信息再到天气预报、交通、卫星图像等能够被采集到的数据。替代数据世界由一系列模糊的数据集组成，而这些数据集可以被转换为交易信息。Quandl提供的替代数据包括企业财务压力数据、外汇数据、电子邮件收据数据、全球石油储量数据、定量股票选择数据等。 Quandl上的数据分为免费数据和高级（Premium）数据，其中高级数据只能通过订阅访问。
申请Quandl账号 除了在Quandl上注册帐号外，Quandl还支持使用GitHub、Google和LinkedIn账号进行OAuth2认证登录。登录后查看账户设置信息中的API KEY，即可用于后继API访问。 Quandl API 全部的Quandl数据产品，可通过https://www.quandl.com/search查找。Quandl的数据产品来源不同，包含时间序列和表在内的各种对象。 Guandl的大多数数据集只能以时间序列或表中的一种格式打开，其中一些则既可用时间序列格式也可用表格式访问。
时间序列是一段时间内观测或指标集合，以时间为索引且只包含数字数据类型字段。 表包含各种未排序数据类型（字符串、数字、日期等）并可用不同字段进行过滤。 Guandl可指定如下返回类型：
JSON CSV XML 速率限制 认证用户限制10秒300个调用、10分钟2000调用及每天50000调用。使用免费数据集的认证用户并发限制为1，即进行一个调用的同时可以在队列中有一个额外的调用。 高级数据订阅限制10分钟5000调用及每天720000调用。
访问时间序列 获取时间序列数据集数据 GET https://www.quandl.com/api/v3/datasets/{database_code}/{dataset_code}/data.{return_format}?api_key=YOURAPIKEY 获取时间序列数据集元数据 GET https://www.quandl.com/api/v3/datasets/{database_code}/{dataset_code}/metadata.{return_format}?api_key=YOURAPIKEY 获取时间序列数据集数据及元数据 GET https://www.quandl.com/api/v3/datasets/{database_code}/{dataset_code}.{return_format}?api_key=YOURAPIKEY 获取时间序列数据库元数据 GET https://www.quandl.com/api/v3/databases/{database_code}.{return_format}?api_key=YOURAPIKEY 获取整个时间序列数据库(仅能用于订阅的高级数据) GET https://www.quandl.com/api/v3/databases/{database_code}/data?download_type=full&amp;amp;api_key=YOURAPIKEY 查询参数 参数 必需 类型 值 描述 database_code 是 string 数据库代码 dataset_code 是 string 数据集代码 limit 否 int 使用limit=n获得数据集的头n行。使用limit=1获取最新的一行。 column_index 否 int 指定特定列。第0列是日期列且永久返回，因此该处从第1列起。
（mryqu：不指定则显示全部列，指定就显示两列，为什么没有逗号分隔了？） start_date 否 string yyyy-mm-dd 用于过滤的起始日期 end_date 否 string yyyy-mm-dd 用于过滤的结束日期 order 否 string asc</description></item><item><title>YouTube Analytics Dimensions And Mitrics Research</title><link>https://mryqu.github.io/post/youtube_analytics_dimensions_and_mitrics_research/</link><pubDate>Fri, 28 Apr 2017 06:11:11 +0000</pubDate><guid>https://mryqu.github.io/post/youtube_analytics_dimensions_and_mitrics_research/</guid><description>Dimensions GroupCore
Dim?DimensionData
TypeExampleTest
URLResourcesXvideoSTRINGNO_FORMAT
KHqrLhJPdtETestplaylistSTRINGNO_FORMAT
TestXchannelSTRINGNO_FORMAT
???group
(filter only)Time periodsXdaySTRINGYYYY-MM-DD
2016-05-03TestX7DayTotalsSTRINGYYYY-MM-DD
2014-01-01TestX30DayTotalsSTRINGYYYY-MM-DD
2014-01-01TestXmonthSTRINGYYYY-MM
2016-05TestGeographic areasXcountrySTRING2-letter ISO-3166-1 code
USTestprovince
[use country==US in filter]STRINGISO 3166-2 code
US-ZZTestcontinent
(filter only)subContinent
(filter only)Playback locationsinsightPlaybackLocationTypeSTRINGPossible Value:BROWSECHANNELEMBEDDEDEXTERNAL_APPMOBILESEARCHWATCHYT_OTHER
WATCHTestinsightPlaybackLocationDetail
[use insightPlaybackLocationType
==EMBEDDED in filter]STRINGTestPlayback detailsliveOrOnDemandSTRINGPossible Value:LIVEON_DEMAND
ON_DEMANDTestsubscribedStatusSTRINGPossible Value:SUBSCRIBEDUNSUBSCRIBEDTest?youtubeProductSTRINGPossible Values:COREGAMINGKIDSUNKNOWN
CORETestTraffic sourcesinsightTrafficSourceTypeSTRINGPossible Values:ADVERTISINGANNOTATIONCAMPAIGN_CARDEND_SCREENEXT_URLNO_LINK_EMBEDDEDNO_LINK_OTHERNOTIFICATIONPLAYLISTPROMOTEDRELATED_VIDEOSUBSCRIBERYT_CHANNELYT_OTHER_PAGEYT_PLAYLIST_PAGEYT_SEARCH
YT_CHANNELTestinsightTrafficSourceDetail
[use insightTrafficSourceType in filter]STRINGNO_FORMAT
UC-OpYDuNCwCt-AIHC6xNYdwTestDevicesdeviceTypeSTRINGPossible Values:DESKTOPGAME_CONSOLEMOBILETABLETTVUNKNOWN_PLATFORM
DESKTOPTestoperatingSystemSTRINGPossible Values:ANDROIDBADABLACKBERRYCHROMECASTDOCOMOFIREFOXHIPTOPIOSLINUXMACINTOSHMEEGONINTENDO_3DSOTHERPLAYSTATIONPLAYSTATION_VITAREALMEDIASMART_TVSYMBIANTIZENWEBOSWIIWINDOWSWINDOWS_MOBILEXBOX
WINDOWSTestDemographicsXageGroup
[use specific metric]STRINGPossible Values:age13-17age18-24age25-34age35-44age45-54age55-64age65-TestXgender
[use specific metric]STRINGPossible Values:femalemaleTestEngagement and content sharingXsharingServiceSTRINGPossible Values:AMEBAANDROID_EMAILANDROID_MESSENGERANDROID_MMSBBMBLOGGERCOPY_PASTECYWORLDDIGGDROPBOXEMBEDMAILFACEBOOKFACEBOOK_MESSENGERFACEBOOK_PAGESFOTKAGMAILGOOGOOGLEPLUSGO_SMSGROUPMEHANGOUTSHI5HTC_MMSINBOXIOS_SYSTEM_ACTIVITY_DIALOGKAKAO_STORYKIKLGE_EMAILLINELINKEDINLIVEJOURNALMENEAMEMIXIMOTOROLA_MESSAGINGMYSPACENAVERNEARBY_SHARENUJIJOTHERPINTERESTREDDITSKYPESKYBLOGSONY_CONVERSATIONSSTUMBLEUPONTELEGRAMTEXT_MESSAGETUENTITUMBLRTWITTERUNKNOWNVERIZON_MMSVIBERWECHATWEIBOWHATS_APPWYKOPYAHOOVKONTAKTEODNOKLASSNIKIRAKUTENKAKAOTestAudience retentionelapsedVideoTimeRatio
[use video in filter]FLOATrange from 0.</description></item><item><title>处理Google Analytics数据类型</title><link>https://mryqu.github.io/post/%E5%A4%84%E7%90%86google_analytics%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 17 Apr 2017 05:50:50 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%A4%84%E7%90%86google_analytics%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>发送一个Google Analytics请求 分析响应中的columnHeaders 响应中每一列头都包含数据类型信息，大致包含STRING、INTEGER、FLOAT、DATE、TIME、PERCENT、CURRENCY等。
{ &amp;#34;kind&amp;#34;: &amp;#34;analytics#gaData&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;https://www.googleapis.com/analytics/v3/data/ga?ids=ga:1XXXXX0&amp;amp;dimensions=ga:campaign,ga:source,ga:medium,ga:date&amp;amp;metrics=ga:users,ga:newUsers,ga:percentNewSessions,ga:sessions,ga:bounceRate,ga:avgSessionDuration,ga:pageviewsPerSession&amp;amp;start-date=30daysAgo&amp;amp;end-date=yesterday&amp;amp;max-results=0&amp;#34;, &amp;#34;query&amp;#34;: { &amp;#34;start-date&amp;#34;: &amp;#34;30daysAgo&amp;#34;, &amp;#34;end-date&amp;#34;: &amp;#34;yesterday&amp;#34;, &amp;#34;ids&amp;#34;: &amp;#34;ga:1XXXXX0&amp;#34;, &amp;#34;dimensions&amp;#34;: &amp;#34;ga:campaign,ga:source,ga:medium,ga:date&amp;#34;, &amp;#34;metrics&amp;#34;: [ &amp;#34;ga:users&amp;#34;, &amp;#34;ga:newUsers&amp;#34;, &amp;#34;ga:percentNewSessions&amp;#34;, &amp;#34;ga:sessions&amp;#34;, &amp;#34;ga:bounceRate&amp;#34;, &amp;#34;ga:avgSessionDuration&amp;#34;, &amp;#34;ga:pageviewsPerSession&amp;#34; ], &amp;#34;start-index&amp;#34;: 1, &amp;#34;max-results&amp;#34;: 0 }, &amp;#34;itemsPerPage&amp;#34;: 0, &amp;#34;totalResults&amp;#34;: 27400, &amp;#34;selfLink&amp;#34;: &amp;#34;https://www.googleapis.com/analytics/v3/data/ga?ids=ga:1XXXXX0&amp;amp;dimensions=ga:campaign,ga:source,ga:medium,ga:date&amp;amp;metrics=ga:users,ga:newUsers,ga:percentNewSessions,ga:sessions,ga:bounceRate,ga:avgSessionDuration,ga:pageviewsPerSession&amp;amp;start-date=30daysAgo&amp;amp;end-date=yesterday&amp;amp;max-results=0&amp;#34;, &amp;#34;nextLink&amp;#34;: &amp;#34;https://www.googleapis.com/analytics/v3/data/ga?ids=ga:1XXXXX0&amp;amp;dimensions=ga:campaign,ga:source,ga:medium,ga:date&amp;amp;metrics=ga:users,ga:newUsers,ga:percentNewSessions,ga:sessions,ga:bounceRate,ga:avgSessionDuration,ga:pageviewsPerSession&amp;amp;start-date=30daysAgo&amp;amp;end-date=yesterday&amp;amp;start-index=1&amp;amp;max-results=0&amp;#34;, &amp;#34;profileInfo&amp;#34;: { &amp;#34;profileId&amp;#34;: &amp;#34;1XXXXX0&amp;#34;, &amp;#34;accountId&amp;#34;: &amp;#34;1XXXXX8&amp;#34;, &amp;#34;webPropertyId&amp;#34;: &amp;#34;UA-XXXXXXX-1&amp;#34;, &amp;#34;internalWebPropertyId&amp;#34;: &amp;#34;1XXXX1&amp;#34;, &amp;#34;profileName&amp;#34;: &amp;#34;Corporate Site (Master Profile)&amp;#34;, &amp;#34;tableId&amp;#34;: &amp;#34;ga:1XXXXX0&amp;#34; }, &amp;#34;containsSampledData&amp;#34;: true, &amp;#34;sampleSize&amp;#34;: &amp;#34;999951&amp;#34;, &amp;#34;sampleSpace&amp;#34;: &amp;#34;3174334&amp;#34;, &amp;#34;columnHeaders&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;ga:campaign&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;DIMENSION&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;STRING&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:source&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;DIMENSION&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;STRING&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:medium&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;DIMENSION&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;STRING&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:date&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;DIMENSION&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;STRING&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:users&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;INTEGER&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:newUsers&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;INTEGER&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:percentNewSessions&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;PERCENT&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:sessions&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;INTEGER&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:bounceRate&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;PERCENT&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:avgSessionDuration&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;TIME&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;ga:pageviewsPerSession&amp;#34;, &amp;#34;columnType&amp;#34;: &amp;#34;METRIC&amp;#34;, &amp;#34;dataType&amp;#34;: &amp;#34;FLOAT&amp;#34; } ], &amp;#34;totalsForAllResults&amp;#34;: { &amp;#34;ga:users&amp;#34;: &amp;#34;2648520&amp;#34;, &amp;#34;ga:newUsers&amp;#34;: &amp;#34;1488536&amp;#34;, &amp;#34;ga:percentNewSessions&amp;#34;: &amp;#34;46.</description></item><item><title>Upload file to Google Drive using LibCurl</title><link>https://mryqu.github.io/post/upload_file_to_google_drive_using_libcurl/</link><pubDate>Fri, 06 Jan 2017 05:26:57 +0000</pubDate><guid>https://mryqu.github.io/post/upload_file_to_google_drive_using_libcurl/</guid><description>This is a sequel to my last blog &amp;ldquo;Upload file to Google Drive using Postman and cURL&amp;rdquo;.
I wrote C++ code using LibCurl to redo the three types of upload, and all of them work which shown in the below log snippet.
Simple upload =&amp;gt; Send header, 0000000309 bytes (0x00000135) 0000: 50 4f 53 54 20 2f 75 70 6c 6f 61 64 2f 64 72 69 POST /upload/dri 0010: 76 65 2f 76 33 2f 66 69 6c 65 73 3f 75 70 6c 6f ve/v3/files?</description></item><item><title>Hello Google Drive APIs</title><link>https://mryqu.github.io/post/hello_google_drive_apis/</link><pubDate>Thu, 20 Oct 2016 06:32:31 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_drive_apis/</guid><description>准备环境 当前我的Google Drive内容如下： 继续使用博文《Google Sheets API认证和鉴权》中用过的应用yquGSTest，不过需要激活Google Drive API： Google Drive API测试 方法drive.about.get测试 方法drive.about.get用于获取用户、驱动和系统容量等信息。
方法drive.files.list测试 方法drive.files.list用于列举或搜索文件。
与Microsoft OneDriveAPI仅列举请求目录下文件不同，方法drive.files.list列举文件时返回了所有目录和文件，例如子目录FolderTest1下的文件Class_cn_Tab.csv也在响应内容里面。
方法drive.files.get测试 方法drive.files.get用于通过ID获取文件元数据。下面获得Class_cn_Tab.csv文件的元数据。
方法drive.files.create测试 方法drive.files.create用于创建一个新文件。
在API Explorer中仅能指定新文件的元数据，没法上传文件内容，所以虽然测试成功且GoogleDrive里也会显示新的文件，但是打不开。这种仅指定元数据不提供内容的方式特别适合创建目录。
https://developers.google.com/drive/v3/web/manage-uploads里面说明了如何在创建或更新文件时上传文件内容。
通过Java JDK创建文件 与博文《Google Sheets API认证和鉴权》中获取访问令牌的差异如下：
GET https://accounts.google.com/o/oauth2/v2/auth? scope=**&amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;https://www.googleapis.com/auth/drive&amp;lt;/font&amp;gt;** https://www.googleapis.com/auth/drive.readonly profile&amp;amp;amp; redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;amp; response_type=code&amp;amp;amp; client_id=826380598768-5935tlo90sccvr691ofmp4nrvpthrnn6.apps.googleusercontent.com``` 代码如下： package com.yqu.gd;
import java.io.IOException; import java.util.Collections; import java.util.List;
import com.google.api.client.auth.oauth2.Credential; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.FileContent; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.jackson2.JacksonFactory; import com.google.api.services.drive.Drive; import com.google.api.services.drive.model.File; import com.google.api.services.drive.model.FileList;
public class HelloGoogleDrive {</description></item><item><title>使用OneDrive的根API资源</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8onedrive%E7%9A%84%E6%A0%B9api%E8%B5%84%E6%BA%90/</link><pubDate>Sun, 16 Oct 2016 06:40:59 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8onedrive%E7%9A%84%E6%A0%B9api%E8%B5%84%E6%BA%90/</guid><description>OneDrive的根API资源 可以使用OneDrive的这些根API资源来访问一个项目或驱动。
|路径|资源 |&amp;mdash;&amp;ndash; |/drive|用户的默认驱动。 |/drives|列举对认证用户可用的驱动。 |/drives/{drive-id}|通过ID访问一个特定驱动。 |/drives/{drive-id}/root/children|列举特定驱动根路径下项目。 |/drive/items/{item-id}|通过ID访问一个元素。 |/drive/special/{special-id}|通过已知名访问一个特殊（命名）目录。ID目前可取值为：documents、photos、cameraroll、approot、music。 |/shares/{share-id}|通过共享ID或共享URL访问一个元素。
元素可由路径定位，通过在任何元素或驱动URL后加冒号。
|路径|资源 |&amp;mdash;&amp;ndash; |/drive/root:/path/to/file|通过根绝对路径访问一个元素。 |/drive/items/{item-id}:/path/to/file|通过相对路径访问一个元素。 |/drive/root:/path/to/file:/children|通过根绝对路径列举一个元素的子项。 |/drive/items/{item-id}:/path/to/file:/children|通过相对路径列举一个元素的子项。
测试 获取默认驱动 列举可用驱动 通过ID获取指定驱动 列举特定驱动根路径下项目 通过ID访问一个目录&amp;quot;文档&amp;quot; 访问特殊目录documents 通过共享ID访问文件CN_EN_JP_KO.xlsx 将文件CN_EN_JP_KO.xlsx共享，获取其共享URL： 通过共享ID使用OneDrive API访问文件CN_EN_JP_KO.xlsx： 通过根绝对路径访问文件CN_EN_JP_KO.xlsx 注意root后有冒号： 通过相对路径访问文件CN_EN_JP_KO.xlsx 712B21FCE8E08C92!442是目录&amp;quot;文档&amp;quot;的ID，注意其后有冒号： 通过根绝对路径列举目录&amp;quot;文档&amp;quot;的子元素 注意root和路径（/文档）后都有冒号： 通过相对路径列举目录&amp;quot;FolderTest&amp;quot;的子元素 为了测试，首先我在目录&amp;quot;文档&amp;quot;创建子目录&amp;quot;FolderTest&amp;quot;，然后在目录&amp;quot;FolderTest&amp;quot;中创建mryqu.txt文件。
712B21FCE8E08C92!442是目录&amp;quot;文档&amp;quot;的ID，注意其后有冒号；路径（/FolderTest）后也有冒号。</description></item><item><title>Microsoft OneDrive API访问速率限制</title><link>https://mryqu.github.io/post/microsoft_onedrive_api%E8%AE%BF%E9%97%AE%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6/</link><pubDate>Sat, 15 Oct 2016 06:11:28 +0000</pubDate><guid>https://mryqu.github.io/post/microsoft_onedrive_api%E8%AE%BF%E9%97%AE%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6/</guid><description>一开始查看OneDrive文档Quota facet,，发现里面介绍的是OneDrive存储容量配额，跟API访问速率限制没有关系。除此之外，没有发现任何相关信息。 OneDrive文档Error response里面，看到如下跟访问速率限制相关的错误：
Status code: 429 (Too Many Requests)和509 (Bandwidth LimitExceeded) The code property: activityLimitReached (The app or user hasbeen throttled) Detailed error code: throttledRequest (Too many requests)</description></item><item><title>Hello Microsoft OneDrive API</title><link>https://mryqu.github.io/post/hello_microsoft_onedrive_api/</link><pubDate>Wed, 12 Oct 2016 06:14:09 +0000</pubDate><guid>https://mryqu.github.io/post/hello_microsoft_onedrive_api/</guid><description>OneDriveAPI提供了一套HTTP服务用以将应用连接到OneDrive个人版、OneDrive商业版及SharePoint在线文档库上的文件和目录。OneDriveAPI使应用连接Office 365上文档及访问OneDrive和SharePoint上文件高级功能变得容易。
测试源 为了省事，就用我自己私人的OneDrive做测试吧。 获取Token 最省事的方法是在OneDrive authentication and sign-in里面获得测试Token，无需注册新的应用就可以请求到与登录账户绑定的、一个有效期1小时的开发者Token。
测试API 获取默认Drive 查看Drive 根目录内容 从上图可知，根目录包含一个包含&amp;quot;050709大同&amp;quot;子目录，该子目录的id为&amp;quot;712B21FCE8E08C92!112&amp;quot;。从整个响应内容可知，根目录包含&amp;quot;文档&amp;quot;子目录，其id为&amp;quot;712B21FCE8E08C92!442&amp;quot;。
查看Drive &amp;ldquo;文档&amp;quot;目录 该目录下有一个CN_EN_JP_KO.xlsx文件，其@content.downloadUrl属性值为下载链接。
获取CN_EN_JP_KO.xlsx文件 如果将链接直接放入浏览器，下载后将文件名变更成xlsx后缀，即可用Excel打开。
参考 Develop with the OneDrive API</description></item><item><title>在线文档/存储 API/SDK</title><link>https://mryqu.github.io/post/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8_apisdk/</link><pubDate>Mon, 10 Oct 2016 06:08:44 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8_apisdk/</guid><description>本博文是社交媒体API/SDK的姊妹篇。
社交媒体API编程平台/语言OneDrive Filepicker SDK:
快速下载或链接在OneDrive中的文件，或将文件保存到OneDrive官方:
AndroidiOS （使用UIDocumentPicker约定）Web /JavaScriptWindows（使用FileOpenPicker或 FileSavePicker）
OneDrive APISDK:
操作OneDrive上的文件，无需处理认证、JSON解析、HTTP连接等细节官方:
Windows .NET / C#/ XamariniOSPython（目前不支持OneDrive for Business）AndroidGoogle SheetsAPI SDK:
访问和更新Google电子表格官方:
AndroidGoiOSJavaJavaScript.NETNode.jsPHPPythonRubyGoogle Drive APISDK:
在移动/web应用中读、写和同步在Google Drive上的文件官方:
AndroidGoiOS (Object-C&amp;amp; Swift)JavaJavaScript.NETNode.jsPHPPythonRubyDropbox API SDK:
操作Dropbox上的文件官方:
.NETJavaJavaScriptPythonSwiftObjective-C社区:
AndroidGoJavaJavaScriptObjective-CNode.jsPHPSwiftBox API SDK:
操作Box上的文件官方:
Java.NETNode.jsPythonRubyChromeSalesforceIOSAndroidWindows(Mobile)iCloud APISDK:
操作iCloud上的资源官方:
CloudKit JS库CloudKitSwift库CloudKitObjective-C库社区:
PythonJavaAmazonDrive API :
操作Amazon Drive上的文件</description></item><item><title>Dropbox API访问速率限制</title><link>https://mryqu.github.io/post/dropbox_api%E8%AE%BF%E9%97%AE%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6/</link><pubDate>Wed, 05 Oct 2016 06:06:00 +0000</pubDate><guid>https://mryqu.github.io/post/dropbox_api%E8%AE%BF%E9%97%AE%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6/</guid><description>Dropbox的Data ingress guide介绍了关于Dropbox API访问速率限制。 错误Status code: 429 (Too ManyRequests)用于表示API访问速率超限，如果响应包内容为JSON，则包含too_many_requests或too_many_write_operations值进行更进一步说明。 关联用户的应用，访问速率限制仅适用于每用户。一个用户关联多个应用，各应用互不影响。 关联团队的应用当调用商业端点（BusinessEndpoint），访问速率限制仅适用于每个团队。如果应用有团队成员文件访问权限但是正在调用用户端点（UserEndpoint），访问速率限制仅适用于每个团队成员。这意味着，对于关联团队的应用，一个团队关联多个应用，各应用互不影响；单个应用代表多个团队成员的请求，也不会影响团队成员彼此的访问速率限制。 超过速率限制后的响应包含一个Retry-After头，提供按秒计的等待间隔值，应用在这段时间内不应重试请求以免再获得速率限制响应。 Dropbox不会公布其API速率限制值，开发时要假设Dropbox会在今后调整其API速率限制。</description></item><item><title>Hello Dropbox API</title><link>https://mryqu.github.io/post/hello_dropbox_api/</link><pubDate>Tue, 04 Oct 2016 05:53:29 +0000</pubDate><guid>https://mryqu.github.io/post/hello_dropbox_api/</guid><description>本博文用来记录一下粗略体验Dropbox关于用户、文件、共享三方面API的过程。
准备环境 还是用我私人的Dropbox做测试，所以只显示Public目录下的东东了。 用户类API测试 方法get_current_account测试 方法get_account测试 方法get_space_usage测试 文件类API测试 方法list_folder测试 方法list_folder其实是列举文件和目录，而且是分层的。如果path没设，则显示根目录下的元素。
方法get_metadata测试 方法get_metadata用于获取一个元素（文件/目录）的元数据。
方法create_folder测试 方法get_preview测试 方法get_preview仅支持 .doc、 .docx、 .docm、 .ppt、 .pps、 .ppsx、 .ppsm、.pptx、.pptm、 .xls、 .xlsx、 .xlsm、.rtf文件类型。就我的测试而言，没看出跟下面的download方法有多大区别。
这里尝试了一下path的其他使用方式。除了最常规的文件路径外，path参数还可以使用id或rev。
方法download测试 方法search测试 方法upload测试 方法delete测试 方法delete用于删除一个元素（文件/目录）。
方法permanently_delete测试 方法permanently_delete是支持Dropbox商业应用，而我的是开发应用，因而测试失败。
共享类API测试 方法share_folder测试 方法list_folders测试 方法unshare_folder测试 方法unshare_folder使用的是异步任务的方式，需要通过下列的方法check_job_status查询任务进度及结果。
方法check_job_status测试 方法create_share_link测试 share_folder可以通过邮件或Dropbox账户的方式分享给其他Dropbox用户，而share_link甚至可以共享给没有安装Dropbox的使用者。
方法get_share_links测试 方法get_shared_link_file测试 方法revoke_shared_link测试 revoke_shared_link竟然不返回结果，查证文档后确实如此。
学习总结 Dropbox关于文件共享方面的API占比相对OneDrive、Google Drive要多一些。 Dropbox API相对OneDrive、GoogleDrive而言，成熟度更低。按照REST的Richardson成熟度模型来说仅在2-级别，它的REST资源还是动词，例如get_metadata、check_job_status。
参考 Dropbox Dropbox API v2 for HTTP Developers Dropbox API Explorer</description></item><item><title>在Google API中使用访问令牌的三种方式</title><link>https://mryqu.github.io/post/%E5%9C%A8google_api%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 29 Sep 2016 05:33:08 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%9C%A8google_api%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>在Google Developers OAuth 2.0 playground 中设置OAuth2.0配置时，可以发现有一个访问令牌位置的选择框，其值为：
Authorization header w/ OAuth prefix Authorization header w/ Bearer prefix Access_token URL parameter 按照前面博文《Google Sheets API认证和鉴权 》中的方法生成一个访问令牌。下面我就用这个访问令牌对这三种使用方式进行一下尝试。
认证头使用OAuth前缀 认证头使用Bearer前缀 使用access_token URL参数 结论：这三种访问令牌位置的使用都工作正常，API结果相同！</description></item><item><title>Hello Google Sheets API</title><link>https://mryqu.github.io/post/hello_google_sheets_api/</link><pubDate>Wed, 28 Sep 2016 06:00:05 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_sheets_api/</guid><description>准备环境 首先在Google Sheets创建了SpreadSheetTest1和To-do list两个电子表格，以备使用。 API测试 方法spreadsheets.get测试 方法spreadsheets.get可以获得一个电子表格中所有表单的内容和元数据。 下面是用Postman进行同样操作： 方法spreadsheets.values.get测试 方法spreadsheets.values.get可以获得一个电子表格中所有表单的内容。 方法spreadsheets.create测试 方法spreadsheets.create可以创建一个新的电子表格。 查看GoogleSheets，也可以看到新创建的电子表格SpreadSheetCreate1。由于我的请求里没有数据，因此下图中数据区也是空空。 方法spreadsheets.values.append测试 方法spreadsheets.values.append可以向电子表格中添加内容。 查看Google Sheets，也可以看到刚才创建的电子表格SpreadSheetCreate1有了九个单元格新数据。 学习结论 Google Sheets API可以创建、读取和修改电子表格，但是没有找到删除电子表格的方法。 Google SheetsAPI可以创建、读取、修改和删除一个电子表格内容，例如方法spreadsheets.batchUpdate中deleteSheet就可以删除一个表单，而deleteDimension就可以删除一个表单中的行/列。
参考 Google Sheets Google Sheets API Google API Explorer: Sheets</description></item><item><title>Google Sheets API认证和鉴权</title><link>https://mryqu.github.io/post/google_sheets_api%E8%AE%A4%E8%AF%81%E5%92%8C%E9%89%B4%E6%9D%83/</link><pubDate>Tue, 27 Sep 2016 05:44:22 +0000</pubDate><guid>https://mryqu.github.io/post/google_sheets_api%E8%AE%A4%E8%AF%81%E5%92%8C%E9%89%B4%E6%9D%83/</guid><description>玩一把用于Google Sheets API的OAuth2认证，以获得用于Sheets API的访问令牌。
注册Google Sheets应用 首先在Google API Console注册一个应用： Google Sheets API鉴权 用于用户登录的HTTPGET请求如下（scope选择了profile、对文件元数据和内容只读访问、对表单和属性只读访问）： GET https://accounts.google.com/o/oauth2/v2/auth? scope=https://www.googleapis.com/auth/spreadsheets.readonly https://www.googleapis.com/auth/drive.readonly profile&amp;amp; redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp; response_type=code&amp;amp; client_id=826380598768-5935tlo90sccvr691ofmp4nrvpthrnn6.apps.googleusercontent.com 首先要求用户登录：要求登录后用户的授权：返回页面包含授权码： 获取访问令牌的HTTPPOST请求包含上面获得的授权码（在创建Google应用时获得的client_id和client_secret）： POST https://www.googleapis.com/oauth2/v4/token Content-Type: application/x-www-form-urlencoded code=4/-qpp...qA&amp;amp; client_id=826380598768-5935tlo90sccvr691ofmp4nrvpthrnn6.apps.googleusercontent.com&amp;amp; client_secret=5...r&amp;amp; redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp; grant_type=authorization_code 参考 Google Sheets Google Sheets API Authorize Google Sheets API Requests Using OAuth 2.0 for Mobile and Desktop Applications Using OAuth 2.0 for Web Server Applications</description></item><item><title>使用SpringFox自动生成Swagger文档</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8springfox%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3/</link><pubDate>Thu, 28 Apr 2016 06:03:36 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8springfox%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3/</guid><description>前面的博文Swagger实践和总结总体上探索了一下Swagger，这里着重研究Springfox。 Springfox Java库源自MartyPitt创建的swagger-springmvc项目。Swagger是一系列对RESTful接口进行规范描述和页面展示的工具，而通过Springfox将Swagger与Spring-MVC整合,可以将代码中的注解转换为符合Swagger开放API声明(OpenAPI Specification，OAS)的swagger.json文件,springfox-swagger-ui提供了将swagger.json转换为html页面的服务。
HelloSpringfox示例 尽管springfox-demos中的boot-swagger很全面了。但是对于一个写程序的人来说，不亲自写一遍，总觉得可能会有陷阱和漏洞，缺乏那么一点点自信。 我的示例是以Building a Hypermedia-Driven RESTful Web Service为基础修改的，懒人总是要找个肩膀。
build.gradle jar { baseName = &amp;#39;hello-springfox&amp;#39; version = &amp;#39;0.1.0&amp;#39; } dependencies { compile(&amp;#34;org.springframework.boot:spring-boot-starter-actuator&amp;#34;) compile(&amp;#34;org.springframework.boot:spring-boot-starter-web&amp;#34;) compile(&amp;#34;org.springframework.boot:spring-boot-starter-hateoas&amp;#34;) compile(&amp;#34;io.springfox:springfox-swagger2:${springfoxVersion}&amp;#34;) compile(&amp;#34;io.springfox:springfox-swagger1:${springfoxVersion}&amp;#34;) compile(&amp;#34;io.springfox:springfox-swagger-ui:${springfoxVersion}&amp;#34;) testCompile(&amp;#34;com.jayway.jsonpath:json-path&amp;#34;) testCompile(&amp;#34;org.springframework.boot:spring-boot-starter-test&amp;#34;) } Application.java package com.yqu.hellospringfox; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Greeting.java package com.yqu.hellospringfox; import org.springframework.hateoas.ResourceSupport; import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty; public class Greeting extends ResourceSupport { private final String content; @JsonCreator public Greeting(@JsonProperty(&amp;#34;content&amp;#34;) String content) { this.</description></item><item><title>Facebook Graph API合集</title><link>https://mryqu.github.io/post/facebook_graph_api_notes/</link><pubDate>Mon, 04 Jan 2016 05:30:32 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api_notes/</guid><description>常用URL笔记 获取Facebook主页Id https://graph.facebook.com/v2.5/SasSoftware?access_token={accessToken}&amp;amp;format=json 上面示例是通过主页名SasSoftware获取其主页Id。
获取Facebook主页帖子
https://graph.facebook.com/v2.5/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=2015-01-01&amp;amp;util=2015-12-31 https://graph.facebook.com/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 https://graph.facebook.com/v2.0/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 通过Facebook Graph API 2.5或不带版本的API仅能获取帖子的Id、创建时间和帖子内容，而FacebookGraph API 2.0则可以获得更多内容。
获取Facebook帖子的评论信息 https://graph.facebook.com/{postId}/comments?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}
获取Facebook帖子的点赞信息 https://graph.facebook.com/{postId}/likes?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;summary=true&amp;amp;access_token={accessToken}
获取帖子订阅信息之limit参数 不同版本Facebook Graph API对获取帖子订阅信息 中limit参数要求不同：
v2.0及以下版本没有说明 v2.1、v2.2和v2.3版本上限为250 v2.4和v2.5版本上限为100 处理Facebook API访问速率超限错误 对于下列Facebook通用错误，我个人觉的#2、#4、#9、#17、#18和#32错误都可以向客户端报告FacebookAPI访问速率超限，至于#5不确定。
Error number PHP Constant name Error description Generated by methods 2 API_EC_SERVICE Service temporarily unavailable (all) 4 API_EC_TOO_MANY_CALLS Application request limit reached (all) 5 API_EC_BAD_IP Unauthorized source IP address (all) 9 API_EC_RATE User is performing too many actions 17 API_EC_USER_TOO_MANY_CALLS User request limit reached 18 API_EC_REQUEST_RESOURCES_EXCEEDED This API call could not be completed due to resourcelimits 32 Page request limit reached 参考</description></item><item><title>社交媒体API访问频次限制</title><link>https://mryqu.github.io/post/%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93api%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6/</link><pubDate>Sat, 07 Nov 2015 05:38:39 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93api%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6/</guid><description>Facebook API访问频次限制 Facebook Graph API访问频次限制 Facebook Marketing API访问频次限制 FAcebook Graph API允许每用户每60分钟200次API调用。Facebook MarketingAPI随广告用户级别变化。
Twitter API访问频次限制 TwitterAPI访问频次按15分钟为间隔。有两类桶：15分钟内允许15次调用，及15分钟内允许180次调用。Twitter搜索属于后者，在15分钟内允许180次调用。
Google Analytics API Limits and Quotas Google Analytics Core Reporting API - API Limits and Quotas
Google Analytics Real Time Reporting API - API Limits and Quotas
Google Analytics Multi-Channel Funnels Reporting API - API Limits and Quotas
每个项目每天50000个请求，可增加。
每个IP 10 QPS（query per second）。
在Developers Console上，该配额是指per-userlimit。默认设置为1秒1个查询，可被调整为最大值10。 如果你的应用从单个IP地址发出所有API请求，你需要考虑在每个请求中使用userIP或quotaUser参数以获取对每个用户QPS的满配额。 Understand YouTube Analytics API Quota Usage 暂时没有查到Youtube Analytics API固定配额，不过看起来查询维度对配额使用的影响更大。</description></item><item><title>Hello Twitter4J</title><link>https://mryqu.github.io/post/hello_twitter4j/</link><pubDate>Mon, 19 Oct 2015 06:10:11 +0000</pubDate><guid>https://mryqu.github.io/post/hello_twitter4j/</guid><description>Twitter4J是Twitter API的第三方Java库。本演示用它通过关键字搜索推文。
获取Twitter应用证书 示例代码
package com.yqu.twitter4j; import twitter4j.Query; import twitter4j.QueryResult; import twitter4j.Status; import twitter4j.Twitter; import twitter4j.TwitterFactory; public class HelloTwitter4J { // I18NOK:CLS public static void main(String[] args) { try { // The factory instance is re-useable and thread safe. Twitter twitter = TwitterFactory.getSingleton(); Query query = new Query(&amp;#34;夏洛特烦恼&amp;#34;); query.setLang(&amp;#34;zh&amp;#34;); query.setCount(10); QueryResult result = twitter.search(query); for (Status status : result.getTweets()) { System.out.println(status.getCreatedAt()+&amp;#34;:&amp;#34;+status.getText()); } } catch (Exception e) { e.printStackTrace(); } } } twitter.</description></item><item><title>Use proxy on Google Analytics API</title><link>https://mryqu.github.io/post/use_proxy_on_google_analytics_api/</link><pubDate>Fri, 09 Oct 2015 05:34:55 +0000</pubDate><guid>https://mryqu.github.io/post/use_proxy_on_google_analytics_api/</guid><description>使用Google API创建HTTP传输层是这样子的，没有可以传入代理的地方。
HttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport(); 仔细研究一下com.google.api.client.googleapis.javanet.GoogleNetHttpTransport，发现其实现是使用com.google.api.client.http.javanet.NetHttpTransport.Builder生成一个com.google.api.client.http.javanet.NetHttpTransport对象。
com.google.api.client.http.javanet.NetHttpTransport.Builder和com.google.api.client.http.javanet.NetHttpTransport是都支持代理的。不用GoogleNetHttpTransport这个封装，直接对com.google.api.client.http.javanet.NetHttpTransport.Builder设置代理即可生成使用代理的HttpTransport对象。
Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(&amp;#34;XXXX&amp;#34;, 80)); HttpTransport httpTransport = new NetHttpTransport.Builder().setProxy(proxy). trustCertificates(GoogleUtils.getCertificateTrustStore()).build();</description></item><item><title>Hello Google Analytics</title><link>https://mryqu.github.io/post/hello_google_analytics/</link><pubDate>Mon, 28 Sep 2015 05:57:14 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_analytics/</guid><description>Google Credential设置见我之前的博文Google Analytics API Error 403: &amp;ldquo;User does not have any Google Analytics Account&amp;rdquo;。
示例代码：
package com.yqu.ga; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.util.List; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.HttpRequest; import com.google.api.client.http.HttpRequestInitializer; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.gson.GsonFactory; import com.google.api.services.analytics.Analytics; import com.google.api.services.analytics.AnalyticsScopes; import com.google.api.services.analytics.model.Accounts; import com.google.api.services.analytics.model.GaData; import com.google.api.services.analytics.model.GaData.ColumnHeaders; import com.google.api.services.analytics.model.GaData.Query; import com.google.api.services.analytics.model.Profiles; import com.google.api.services.analytics.model.Webproperties; public class HelloAnalytics { // I18NOK:CLS private static enum AuthType { SERVICE_ACCOUNT, SERVICE_ACCOUNT_P12, OAUTH }; protected static final String APPLICATION_NAME = &amp;#34;Hello Analytics&amp;#34;; protected static final JsonFactory JSON_FACTORY = GsonFactory .</description></item><item><title>Twitter开发调试工具</title><link>https://mryqu.github.io/post/twitter%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Sun, 27 Sep 2015 05:58:02 +0000</pubDate><guid>https://mryqu.github.io/post/twitter%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>Twitter开发调试工具主要位于https://dev.twitter.com/下。
API status: 显示Twitter API可用性和性能 API参考文档 API控制台工具：测试TwitterAPI 管理自己的应用：对自己的应用进行配置 我用的最多的是API参考文档，其次是API控制台工具。</description></item><item><title>社交媒体API/SDK</title><link>https://mryqu.github.io/post/%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93api_sdk/</link><pubDate>Fri, 25 Sep 2015 06:04:42 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93api_sdk/</guid><description>社交媒体API编程平台/语言Facebook API:应用广告：提升应用安装量和使用率。Analytics for Apps：制定基于数据的客户和广告决策。匿名登录：用户无需分享自己的信息即可注册使用您的应用。应用邀请：方便用户直接与好友分享他们喜欢的应用。应用链接：应用间链接的开放式跨平台标准。应用盈利：Facebook 和 LiveRail 广告助您实现应用盈利。 移动应用受众网络：Facebook 广告助您实现应用盈利。游戏：实现游戏跨平台，覆盖数百万Facebook玩家。Facebook 登录：方便用户跨设备注册您的应用。Messenger：扩大展示，帮助用户发现您的应用。Parse：更快速地构建强大的移动应用。分享：借助 Facebook，提升网站和应用内容的知名度。社交插件：让您的网站和应用更具社交性和吸引力的最简单方式。ThreatExchange：分享威胁信息，保障用户安全。官方:iOSAndroidUnityJavascriptPHP
第三方: Cocos2d-x C Flash HTML5 Java JavaScript Lua Node.js Objective-C Qt Ruby Unity V-Play WinJSTwitter API：TweetsUsersEntitiesPlaces官方:iOSAndroidOSXWebJava第三方:iOSAndroidJavaASPC++ClojureColdFusion.NETGoJavascript/node.jsLua/Corona SDKObjective-CPerlPHPPythonRubyGoogle Analytics Configuration APIs：自动执行帐户和用户配置。Management API：访问和管理帐户、媒体资源、数据视图等Google Analytics（分析）实体。 Provision API：创建新的Google Analytics（分析）帐户。Google Analytics Reporting APIs：借助报告API，您可以自动化复杂的报告任务，进而节省时间。您还可以使用相应API将Google Analytics（分析）数据与您自己的业务数据整合在一起，从而获得更深入的分析数据。 Core Reporting API：通过查询维度和指标来创建自定义报告。Multi-channel Funnels Reporting API：查看您用户的归因和转化路径数据。 Real-time Reporting API：查看您的媒体资源上当前发生的活动。 Embed API：几分钟内即可将信息中心嵌入第三方网站。 Metadata API：查看 API 维度和指标列表以及属性。官方:JavaPythonPHPJavascriptLinkedIn SDK:登录LinkedIn在LinkedIn进行内容分享在用户档案上添加（学位、证书等）信息管理公司页官方:iOSAndroidJavascriptREST APIYouTube API：Youtube Play API：使用内嵌播放器在你的应用直接播放视频，定制回放体验。实际上YouTube提供的是IFRAME、Android API、iOS API、PLAYER PARAMETERS。Youtube Data API：搜索YouTube内容、上传视频、创建和管理播放列表等功能。Youtube Analytics and Reporting API：获取YouTube视频和频道的统计、流行指标等信息。Youtube Analytics API：支持生成定制YouTube分析报告的实时有针对性的查询。API提供过滤和排序参数，因此调用程序无需支持这些功能。每个API请求指定数据范围，也能获取每周和每月的数据集，调用程序无需存储获得的数据集，也无需跨数据范围汇总统计信息。Youtube Reporting API：为频道或内容所有人获取包含YouTube分析数据的一批报告。用于能够导入大数据集并进行过滤、排序、数据挖据的应用。每个报告包含预定义字段集合。开发者使用该API预定报表任务，每个任务标识YouTube所要生成的报告。YouTube生成可以异步下载的日报告。每个报告包含唯一的一天数据。YouTube Live Streaming API：预定YouTube现场直播，管理直播视频流。官方:Java JavaScript .</description></item><item><title>Google Analytics API Error 403: "User does not have any Google Analytics Account"</title><link>https://mryqu.github.io/post/google_analytics_api_error_403_user_does_not_have_any_google_analytics_account/</link><pubDate>Sat, 19 Sep 2015 06:05:53 +0000</pubDate><guid>https://mryqu.github.io/post/google_analytics_api_error_403_user_does_not_have_any_google_analytics_account/</guid><description>试用Google Analytics API，使用service account的认证方式，结果它报错:“User doesnot have any Google Analytics Account”。
解决方法：
在Google开发者控制台中确认Analytics API已经使能 Service account的邮箱域为@developer.gserviceaccount.com 拥有适当的AccountID和ProfileID，并将serviceaccount（至少以读取和分析权限）添加到Google Analytics profile 参考 Google&amp;rsquo;s instructions for adding an email address to an Analytics profile</description></item><item><title>第三方开源Facebook Java API</title><link>https://mryqu.github.io/post/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90facebook_java_api/</link><pubDate>Sun, 13 Sep 2015 06:14:26 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90facebook_java_api/</guid><description>|API|许可类型|活跃度|最后更新|文档|注释 |&amp;mdash;&amp;ndash; |SpringSocial|Apache 2.0|活跃||有|良好 |RestFB|MIT|活跃||有|良好 |BatchFB|MIT|一般||有|良好 |Facebook BlackBerry SDK|MIT|停止更新|2011-8-22|无|老项目，停止更新较早 |FB4J|GPLv2|停止更新|2010-02-14|无|老项目，停止更新较早 |FB Java API|MIT|项目宣布停止|2013-2-5|有|主页建议转到RestFB |JFALibrary|GPLv3|停止更新|2011-5-22|无|很少的提交，且停止更新较早 |Javabook|Apache 2.0|停止更新|2007-9-5|有一点|项目在停止更新前未完成</description></item><item><title>Swagger实践和总结</title><link>https://mryqu.github.io/post/swagger%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 11 May 2015 05:54:33 +0000</pubDate><guid>https://mryqu.github.io/post/swagger%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%80%BB%E7%BB%93/</guid><description>Swagger学习和实践 最近安装并使用了一下Swagger-ui、Swagger-editor和Swagger-codegen，感觉还不错。 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web服务。Swagger的目标是对RESTAPI定义一个标准的和语言无关的接口，可让人和计算机无需访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过Swagger进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger消除了调用服务时可能会有的猜测。 Swagger是一组开源项目，其中主要要项目如下：
Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger1.2文档转换成Swagger 2.0文档等功能。 Swagger-core:用于、Servlets和Play框架进行集成。 Swagger-js:用于JavaScript的Swagger实现。 Swagger-node-express:Swagger模块，用于node.js的Express web应用框架。 Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。 Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。 C:\tools\swagger-codegen&amp;gt;mvn package C:\tools\swagger-codegen\modules\swagger-codegen-cli&amp;gt;mvn package C:\tools\swagger-codegen\modules\swagger-generator&amp;gt;mvn package C:\tools\swagger-codegen&amp;gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i http://petstore.swagger.io/v2/swagger.json -l spring-mvc -o yqu/petstore/spring-mvc C:\tools\swagger-codegen\yqu\petstore\spring-mvc&amp;gt;mvn package 上述操作通过底层使用SpringFox库，会创建带有Swagger注释的SpringMVC框架代码，包括Controller和DTO类。这样将Swagger-ui部署到Web应用内，就可以通过http://server:8002/v2/sdoc.jsp 在线访问API文档了。 Swagger-editor：可让使用者在浏览器里以YAML格式编辑SwaggerAPI规范并实时预览文档。可以生成有效的SwaggerJSON描述，并用于所有Swagger工具（代码生成、文档等等）中。 除了Swagger项目自身支持的Java、Scala和JavaScript语言，Swagger社区中还提供了很多支持其他语言的第三方工具，覆盖了Clojure、ColdFusion/ CFML、Eiffel、Go、Groovy、.Net、Perl、PHP、Python、Ruby等各种编程语言。
Swagger总结 Swagger这类API文档工具可以满足下列需求：
支持API自动生成同步的在线文档 这些文档可用于项目内部API审核 方便测试人员了解API 这些文档可作为客户产品文档的一部分进行发布 支持API规范生成代码，生成的客户端和服务器端骨架代码可以加速开发和测试速度 跟下列其他API文档工具相比，Swagger各有优缺点，但它功能最多、也是最流行的。
RESTful API Modeling Language (RAML) apiary的API Blueprint I/O Docs Web Application Description Language (WADL) 参考 Swagger官网 GitHub：Swagger Swagger规范 SpringFox官网 GitHub：SpringFox Spring Boot &amp;amp; Swagger UI</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>annotation on Mryqu's Notes</title><link>https://mryqu.github.io/tags/annotation/</link><description>Recent content in annotation on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 27 Dec 2016 05:46:09 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/annotation/index.xml" rel="self" type="application/rss+xml"/><item><title>学习Java Annotation</title><link>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0java_annotation/</link><pubDate>Tue, 27 Dec 2016 05:46:09 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0java_annotation/</guid><description>以前看过Java Annotation，走马观花，现在印象已经不深刻了。这次好好看一下Java Annotation和Spring Annotation。
阅读列表： The Java Tutorials - Annotations
Java Annotation认知(包括框架图、详细介绍、示例说明)
Annotations Gotchas and Best Practices
Annotations: Don&amp;rsquo;t Mess with Java
Java Annotations Are a Big Mistake
Spring Annotation-based container configuration
Spring Framework Annotations cheat sheet
Spring Without XML: The Basics of Spring Annotations vs. Spring XML Files
Spring Annotation Tutorial
Spring Annotations [ Quick Reference ]</description></item><item><title>通过Java反射操作注解</title><link>https://mryqu.github.io/post/%E9%80%9A%E8%BF%87java%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3/</link><pubDate>Sun, 29 Jun 2014 09:47:16 +0000</pubDate><guid>https://mryqu.github.io/post/%E9%80%9A%E8%BF%87java%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3/</guid><description>注解是Java5加入的特性，它是可以插入Java代码的注释或元数据，可被预编译工具在编译时进行处理，或在运行态通过Java反射进行操作。开发者可以通过元编程（Metaprogramming）等技术提高生产率，注解在其中扮演了核心角色。其思想是通过注解够告诉工具如何生成新代码、转换代码或者决定运行期的行为。
MyAnnotation.java package com.yqu.reflection.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) //@Target(ElementType.TYPE) public @interface MyAnnotation { public String name() default &amp;#34;[unknown name]&amp;#34;; public String value() default &amp;#34;[unassigned value]&amp;#34;; } 定义注解类有点类似于定义Java接口类interface，但和一般的接口类比起来，interface前面多了一个@，这样就声明了注解是一个Annotation类。另外，Stringname()和Stringvalue()这个写法是@interface中一个比较独特的地方。它实际上定义的不并是注解类的方法，而是注解类的属性。 @Target指定此注解的作用域：
TYPE：用于类、接口、注解类和枚举 CONSTRUCTOR：用于构造方法 LOCAL_VARIABLE：用于本地变量 FIELD：用于类的属性(包括枚举常量) METHOD：用于方法 PACKAGE：用于包 PARAMETER：用于方法的参数 ANNOTATION_TYPE：用于注解类 TYPE_PARAMETER：使用类型参数，表示注解可以用在Type的声明式前 TYPE_USE： 使用类型注解。表示注解所有使用Type的地方（如泛型、类型转换等）@Retention指定此注解的生命周期： SOURCE：代表此注解仅在代码编译前存活。比如@Deprecated，仅在编译前提供一些提示信息。在编译时，这些注解并不会编译到class文件中。 CLASS：与SOURCE不同，这类标记会编译到class文件中，但不会成为程序的一部分，也不可以通过代码在运行时调用到。 RUNTIME： 这类标记将成为代码的一部分，并会在实际运行时起到作用。 TheClass.java package com.yqu.reflection.annotation; import java.lang.annotation.Annotation; import java.lang.reflect.Field; import java.lang.reflect.Method; @MyAnnotation(name = &amp;#34;classAnnotation&amp;#34;, value = &amp;#34;Hello Class&amp;#34;) // I18NOK:CLS public class TheClass { @MyAnnotation(name = &amp;#34;fieldAnnotation&amp;#34;, value = &amp;#34;Hello Field&amp;#34;) public String theField = null; public TheClass() { } @MyAnnotation(name = &amp;#34;methodAnnotation&amp;#34;, value = &amp;#34;Hello Method&amp;#34;) public void doSomething() { System.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>file on Mryqu's Notes</title><link>https://mryqu.github.io/tags/file/</link><description>Recent content in file on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 29 Dec 2016 06:10:45 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/file/index.xml" rel="self" type="application/rss+xml"/><item><title>在Google Drive上创建存在多个目录下的文件</title><link>https://mryqu.github.io/post/%E5%9C%A8google_drive%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Thu, 29 Dec 2016 06:10:45 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%9C%A8google_drive%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>准备环境 在Google Drive上创建两个目录: parent1和parent2 代码 package com.yqu.gd; import java.io.IOException; import java.util.ArrayList; import java.util.List; import com.google.api.client.auth.oauth2.Credential; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.FileContent; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.jackson2.JacksonFactory; import com.google.api.services.drive.Drive; import com.google.api.services.drive.model.File; import com.google.api.services.drive.model.FileList; public class FileWithMultiParents { private static final String APPLICATION_NAME = &amp;#34;Hello Google Drive API&amp;#34;; private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance(); private static HttpTransport HTTP_TRANSPORT; static { try { HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport(); } catch (Throwable t) { t.</description></item><item><title>恢复误删文件内容</title><link>https://mryqu.github.io/post/%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link><pubDate>Fri, 02 Dec 2016 05:49:46 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid><description>昨天鼠标有毛病，本意是选择Ultraedit中的文件，结果莫名其妙关闭了。重新打开后，内容都丢了，而且还认为是正藏保存的。傻眼了，记了一年多的内容呀！ 今天终于找到恢复方法了，右键点击文件-查看属性-选择以前版本-选择版本并恢复。我的天呀，终于不必愁眉苦脸了！</description></item><item><title>[Git] 操作Git仓库已删除文件</title><link>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 11 Nov 2015 05:49:56 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</guid><description>忙着工作，忽然出了一下神，觉得自己对Git仓库已删除文件的操作还没有练习过，决定找资料学习一下。
列举所有Git仓库已删除文件 下列命令可以列举出所有提交信息及被删除的文件：
git log --diff-filter=D --summary 下列命令可以列举出所有被删除的文件，不显示提交信息：
git log --diff-filter=D --summary | grep delete 列举一个Git仓库已删除文件的提交历史信息 仅使用git log无法查看Git仓库已删除文件的提交历史信息。
git log $deletedFile fatal: ambiguous argument &amp;#39;deletedFile&amp;#39;: unknown revision or path not in the working tree. 下列命令则可以：
git log -- $deletedFile 恢复一个Git仓库已删除文件 找到删除该文件的提交哈希值
git rev-list -n 1 HEAD -- $deletedFile 通过删除该文件提交（$deletingCommit）的前一个提交($deletingCommit~1)恢复已删除文件:
git checkout $deletingCommit~1 -- $deletedFile 参考 Is there a way in Git to list all deleted files in the repository
Git: Getting the history of a deleted file</description></item><item><title>[JavaScript] Open/SaveAs File</title><link>https://mryqu.github.io/post/javascript_%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%A6%E5%AD%98%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 31 Jan 2015 12:42:22 +0000</pubDate><guid>https://mryqu.github.io/post/javascript_%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%A6%E5%AD%98%E6%96%87%E4%BB%B6/</guid><description>看了一下HTML5应用中如何打开文件或另存文件。与Swing/EclipseRCP应用不同，有些操作由于安全的原因无法在HTML5应用内使用，而是浏览器与客户交互。例如HTML5应用往本地写文件。下面的显示了在新窗口打开文件、在当前窗口打开文件以及a标签的download属性。 学习了下面链接中的代码和文章，其中FileSaver.js是一个跨浏览器的JS库，但是在各个浏览器上保存文件的用户体验却不相同。目前为止，我还没发现更好的跨浏览器/设备的另存文件解决方案。 Google HTML5 Download Demo
An HTML5 saveAs() FileSaver implementation
New HTML5 Attributes for Hyperlinks: download, media, and ping
Save files on disk using JavaScript or JQuery!
JavaScript Question:Opening Save As Dialog
Internet media type</description></item><item><title>[Linux] 判断可执行文件或动态库是否包含符号表</title><link>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Thu, 24 Oct 2013 22:48:09 +0000</pubDate><guid>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description>在Linux下生成一个可执行文件或动态库，可以使用gcc/g++的&amp;quot;-g&amp;quot;选项使文件包含调试符号表。 要在Linux下判断一个第三方的可执行文件或动态库是否包含调试符号表，可以通过file命令实现：
srv01&amp;gt; file libcurl.so.6 libcurl.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (FreeBSD), dynamically linked, not stripped srv01&amp;gt; file /usr/bin/X11/curl /usr/bin/X11/curl: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked (uses shared libs), for FreeBSD 8.0 (800107), stripped 显示not stripped，表明文件带调试符号表；而显示stripped，表明文件已去除符号表。
如果文件包含调试符号表，可以通过objdump -t命令及选项打印文件的符号表：
srv01&amp;gt; objdump -t libcurl.so.6 libcurl.so.6: file format elf64-x86-64 SYMBOL TABLE: 0000000000000120 l d .hash 0000000000000000 00000000000012b0 l d .dynsym 0000000000000000 0000000000004b08 l d .dynstr 0000000000000000 0000000000006f36 l d .</description></item><item><title>FilenameFilter和FileFilter介绍</title><link>https://mryqu.github.io/post/filenamefilter%E5%92%8Cfilefilter%E4%BB%8B%E7%BB%8D/</link><pubDate>Fri, 18 Oct 2013 19:26:35 +0000</pubDate><guid>https://mryqu.github.io/post/filenamefilter%E5%92%8Cfilefilter%E4%BB%8B%E7%BB%8D/</guid><description>FilenameFilter和FileFilter说明 java.io.File类提供了四个方法用于列举某个路径下的文件和目录，但不会递归列举子目录下的内容。其中两个是列举路径下的所有文件和目录。
String[] list() File[] listFiles()另外两个是列举路径满足指定过滤器的文件和目录。 String[] list(FilenameFilter filter) File[] listFiles(FileFilter filter) 示例 要求：返回当前目录下所有以yqu开头且以.tmp结尾的文件和目录。
代码 package com.yqu.file; import java.io.File; import java.io.FileFilter; import java.io.FilenameFilter; public class HelloFileListing { public static void main(String[] args) { File f = new File(&amp;#34;c:/test&amp;#34;); System.out.println(&amp;#34;\n====Method listFiles() example====&amp;#34;); File[] files = f.listFiles(); for (File fl : files) { String type = fl.isFile() ? &amp;#34;File: &amp;#34; : &amp;#34;Directory: &amp;#34;; try { System.out.println(type + fl.getCanonicalPath()); } catch (Exception e) { e.</description></item></channel></rss>
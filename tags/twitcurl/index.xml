<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Twitcurl on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/twitcurl/</link>
    <description>Recent content in Twitcurl on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 31 Jul 2017 05:46:44 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/twitcurl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;] 优化twitcurl项目中的HMAC_SHA1</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</link>
      <pubDate>Mon, 31 Jul 2017 05:46:44 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</guid>
      <description>twitcurl开源项目中包含SHA1.cpp和HMAC_SHA1.cpp用于计算Twitter认证所需的HMAC-SHA1签名。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC_SHA1需要一个密钥，而SHA1不需要。HMAC_SHA1的公式为：SHA1(Key XOR opad, SHA1(Key XOR ipad, text)) 通过分析oauthlib.cpp和HMAC_SHA1.cpp可知： 1. 对于HMAC_SHA1算法，请求URL及参数信息作为文本输入，ConsumerSecret和AccessTokenSecret组合作为密钥输入； 2. 第一步：如果密钥输入大小超过64字节，则先做一次SHA1获取其摘要用于后继操作；否则直接使用密钥进行后继操作； 3. 第二步：密钥输入（/密钥输入摘要）XOR ipad（即0x36）； 4. 第三步：将上一步的[Key XOR ipad]和文本输入并入缓存AppendBuf1； 5. 第四步：使用上一步生成的缓存AppendBuf1一起进行SHA1以产生内部摘要； 6. 第五步：密钥输入（/密钥输入摘要）XOR opad（即0x5C）； 7. 第六步：将上一步的[Key XOR opad]和第四步产生的内部摘要并入缓存AppendBuf2； 8. 第七步：使用上一步生成的缓存AppendBuf2一起进行SHA1以产生外部摘要。
HMAC_SHA1.h中定义的AppendBuf1和AppendBuf2都有4K大小，合计8K。能不能省点空间呢？
下面我们可以看一个小示例：
char srcTest[] = &amp;quot;abcdef&amp;quot;; int srcTestL = strlen(srcTest); char srcTest1[] = &amp;quot;abc&amp;quot;; int srcTestL1 = strlen(srcTest1); char srcTest2[] = &amp;quot;def&amp;quot;; int srcTestL2 = strlen(srcTest2); unsigned char dst1[20] = &amp;quot;&amp;quot;; unsigned char dst2[20] = &amp;quot;&amp;quot;; CSHA1 sha1A = CSHA1(); sha1A.</description>
    </item>
    
    <item>
      <title>twitcurl获取访问令牌（AccessToken和AccessTokenSecret）的实现流程</title>
      <link>https://mryqu.github.io/post/twitcurl%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8Caccesstoken%E5%92%8Caccesstokensecret%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 01 Jul 2016 05:34:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/twitcurl%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8Caccesstoken%E5%92%8Caccesstokensecret%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description>twitterClient.cpp中有一段代码是没有AccessToken和AccessTokenSecret的情况下，通过ConsumerKey、ConsumerKeySecret、UserName和UaserPassword获取AccessToken和AccessTokenSecret。 一般实现是通过重定向到Twitter页面去授权应用，通过callbackURL获得Twitter传过来的AccessToken和AccessTokenSecret信息。twitcurl既可以通过访问twitter.com获取PIN，也可以交由twitcurl自动获得。 如果通过twitter.com处理PIN，twitcurl会提供授权链接。进入链接后输入用户名和密码，会重定向到Twitter应用的callbackURL（例如http://www.mryqu.com/test.html?oauth_token={OAuthToken}&amp;amp;oauth_verifier={OAuthVerifier} ），其中oauth_verifier值即为所谓的PIN。 下面我们看一下twitcurl是如何实现不访问twitter.com获取AccessToken和AccessTokenSecret的。 - GET https://api.twitter.com/oauth/request_tokentwitCurl::oAuthRequestToken 方法实现该HTTP请求，允许消费者应用获得一个OAuth请求令牌以请求用户授权。除了HTTP OAuth头外，twitcurl实现没有其他HTTP头，也没有消息体内容。HTTP OAuth头包含如下项： - oauth_consumer_key - oauth_nonce - oauth_signature - oauth_signature_method - oauth_timestamp - oauth_version
通过如下HTTP响应可以获得oauth_token和oauth_token_secret，保存在oAuth对象的m_oAuthTokenKey和m_oAuthTokenSecret变量中：
 oauth_token=XXXXXX&amp;amp;oauth_token_secret=XXXXXX&amp;amp;oauth_callback_confirmed=true   GET https://api.twitter.com/oauth/authorize?oauth_token=XXXXXXtwitterObj.oAuthHandlePIN 方法实现该HTTP请求，获取响应页面中表单的authenticity_token和oauth_token元素的值。除了HTTP OAuth头外，twitcurl实现没有其他HTTP头，也没有消息体内容。HTTP OAuth头包含如下项：  oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token （取自上一HTTP响应） oauth_version    HTTP响应片段：- POST https://api.twitter.com/oauth/authorize?oauth_token=XXXXXXtwitterObj.oAuthHandlePIN 方法实现该HTTP请求，允许消费者应用使用OAuth请求令牌请求用户授权。HTTP OAuth头包含如下项： - oauth_consumer_key - oauth_nonce - oauth_signature - oauth_signature_method - oauth_timestamp - oauth_token （取自上一HTTP响应） - oauth_version
HTTP请求消息体内容为：
 oauth_token=XXXXXX&amp;amp;authenticity_token=XXXXXX&amp;amp;session[username_or_email]=**XXXXX**X&amp;amp;session[password]=XXXXXX  HTTP响应片段：通过如下HTTP响应可以获得oauth_verifier，保存在oAuth对象的m_oAuthPin变量中。 - GET https://api.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 给twitcurl添加访问频次限制信息获取功能</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</link>
      <pubDate>Thu, 24 Mar 2016 06:05:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E7%BB%99twitcurl%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%A2%91%E6%AC%A1%E9%99%90%E5%88%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%8A%9F/</guid>
      <description>在我之前的博文Twitter API访问频次限制处理中，描述了Twitter API访问频次限制及Twitter4J对其处理。twitcurl项目并没有这样的功能，今天我将getLastRateLimitStatus功能添加到了twitcurl。 通过添加如下代码，我可以获取响应头信息：
curl_easy_setopt( m_curlHandle, CURLOPT_HEADERFUNCTION, curlHeaderCallback ); curl_easy_setopt( m_curlHandle, CURLOPT_HEADERDATA, this );  输出的调试信息如下：
Enter string to search: va Limit search results to: 2 twitCurl::curlHeaderCallback headers: HTTP/1.1 200 OK twitCurl::curlHeaderCallback headers: cache-control: no-cache, no-store, must-revalidate, pre-check=0, post-check=0 twitCurl::curlHeaderCallback headers: content-disposition: attachment; filename=json.json twitCurl::curlHeaderCallback headers: content-encoding: gzip twitCurl::curlHeaderCallback headers: content-length: 1301 twitCurl::curlHeaderCallback headers: content-type: application/json;charset=utf-8 twitCurl::curlHeaderCallback headers: date: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: expires: Tue, 31 Mar 1981 05:00:00 GMT twitCurl::curlHeaderCallback headers: last-modified: Thu, 24 Mar 2016 04:59:41 GMT twitCurl::curlHeaderCallback headers: pragma: no-cache twitCurl::curlHeaderCallback headers: server: tsa_b twitCurl::curlHeaderCallback headers: set-cookie: guest_id=v1:145879558114535127; Domain=.</description>
    </item>
    
    <item>
      <title>解决使用twitcurl.lib遇到的LNK1112和LNK2038链接错误</title>
      <link>https://mryqu.github.io/post/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8twitcurl.lib%E9%81%87%E5%88%B0%E7%9A%84lnk1112%E5%92%8Clnk2038%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</link>
      <pubDate>Wed, 30 Dec 2015 14:52:38 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8twitcurl.lib%E9%81%87%E5%88%B0%E7%9A%84lnk1112%E5%92%8Clnk2038%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/</guid>
      <description>在使用twitcurl.lib时，遭遇下列链接错误：
fatal error LNK1112: module machine type &#39;X86&#39; conflicts with target machine type &#39;x64&#39; libtwitcurl.lib(twitcurl.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MD_DynamicRelease&#39; doesn&#39;t match value &#39;MT_StaticRelease&#39; in xxxxx.obj  解决方法： </description>
    </item>
    
    <item>
      <title>twitcurl生成HTTP OAuth头的实现流程</title>
      <link>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 27 Dec 2015 06:12:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid>
      <description>对twitcurl代码做了一些修改，结果遇到了认证失败的错误：
{“errors”:[{“message”:”Could not authenticate you”,”code”:32}]}  通过继续修改twitcurl代码改正问题，学习了twitcurl的认证授权部分代码。其授权部分主要在oauthlib.h和oauthlib.cpp中的oAuth类实现中。下面主要分析一下oAuth::getOAuthHeader方法。
外部数据 Http URL: https://api.twitter.com/1.1/search/tweets.json Http头参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |q|va |count|23 |result_type|recent
Http授权参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |oauth_consumer_key|xvz1evFS4wEEPTGEFPHBog |oauth_signature_method|HMAC-SHA1 |oauth_token|370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |oauth_version|1.0
oAuth::getOAuthHeader方法  通过buildOAuthHttpParameterKeyValPairs(params, true,rawKeyValuePairs);对Http头参数中参数值进行百分号编码（URL编码），编码后结果放在哈希表rawKeyValuePairs中 rawKeyValuePairs: 键值qvacount23result_typerecent
 假定HTTP内容是经过百分号编码的，通过buildOAuthRawDataKeyValPairs( rawData,false, rawKeyValuePairs );找到内容中的键值对，放入哈希表rawKeyValuePairs中 rawKeyValuePairs: 键值qvacount23result_typerecent 通过buildOAuthTokenKeyValuePairs( includeOAuthVerifierPin,std::string( &amp;ldquo;&amp;rdquo; ), rawKeyValuePairs, true );创建认授权证： rawKeyValuePairs: 键值说明qvacount23result_typerecentoauth_consumer_keyxvz1evFS4wEEPTGEFPHBogoauth_nonce131862295819ctwitcurl实现就是时戳项加一个随机数oauth_signature_methodHMAC-SHA1固定值oauth_timestamp1318622958oauth_token370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEboauth_version1.0固定值 通过getSignature( eType, pureUrl, rawKeyValuePairs,oauthSignature );获得签名  生成 sigBase： 使用consumer_secret和token_secret组成signing_key，使用HMAC_SHA1算法通过sigBase和signing_key生成摘要strDigest：B6 79 C0 AF 18 F4 E9 C5 87 AB 8E 20 0A CD 4E 48 A9 3F 8C B6(非真实计算而得数据) 通过base64_encode进行编码：tnnArxj06cWHq44gCs1OSKk/jLY= (非真实计算而得数据) 通过百分比编码获得最终签名：(非真实计算而得数据)  通过rawKeyValuePairs.</description>
    </item>
    
  </channel>
</rss>
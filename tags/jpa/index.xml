<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jpa on Mryqu's Notes</title><link>https://mryqu.github.io/tags/jpa/</link><description>Recent content in jpa on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 30 Aug 2015 08:56:57 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/jpa/index.xml" rel="self" type="application/rss+xml"/><item><title>[Hibernate Tools] 通过数据库表生成JPA Entity类</title><link>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%94%9F%E6%88%90jpa_entity%E7%B1%BB/</link><pubDate>Sun, 30 Aug 2015 08:56:57 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%94%9F%E6%88%90jpa_entity%E7%B1%BB/</guid><description>本文与前一博文[Hibernate Tools] 通过JPA Entity类生成数据库表 正好相反，实践一下如何通过数据库表生成JPA Entity类。
在Eclipse中安装JBoss Tools中的Hibernate Tools插件 创建JPA项目PetStoreDemo 使用向导创建JPA项目 项目基本设置 设置JPA Facet 此处选用了Generatic 2.1平台，用户库HIBERNATE_JPA包含如下jar文件：
hibernate-commons-annotations.jar hibernate-core.jar hibernate-jpa-2.1-api.jar 通过数据库表生成JPA Entity类 执行“Generate Entities from Tables” 选择库表 设置库表关联关系 定制生成Entity的默认行为 设置单个Entity 生成结果 下面以Item为例，展示生成结果。
package com.yqu.jpetstore; import java.io.Serializable; import javax.persistence.*; import java.math.BigDecimal; @Entity @Table(name=&amp;#34;item&amp;#34;) @NamedQuery(name=&amp;#34;Item.findAll&amp;#34;, query=&amp;#34;SELECT i FROM Item i&amp;#34;) public class Item implements Serializable { private static final long serialVersionUID = 1L; private String itemid; private String attr1; private String attr2; private String attr3; private String attr4; private String attr5; private BigDecimal listprice; private String status; private BigDecimal unitcost; private Product product; private Supplier supplierBean; public Item() { } @Id @GeneratedValue(strategy=GenerationType.</description></item><item><title>[Hibernate Tools] 通过JPA Entity类生成数据库表</title><link>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87jpa_entity%E7%B1%BB%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/</link><pubDate>Sat, 29 Aug 2015 07:19:26 +0000</pubDate><guid>https://mryqu.github.io/post/hibernate_tools_%E9%80%9A%E8%BF%87jpa_entity%E7%B1%BB%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/</guid><description>以前用过hbm2ddlAnt任务通过Hibernate映射文件生成数据库DDL。现在使用JPA后，不知道还有没有标准工具了。找了一圈，还是HibernateTools。
在Eclipse中安装JBoss Tools中的Hibernate Tools插件 创建JPA项目CustomerDemo 使用向导创建JPA项目 项目基本设置 设置JPA Facet 此处选用了EclipseLink 2.5.x平台。如选择Generatic2.1平台，在生成数据库Schema时会报“Generate Tables from Entities is notsupported by the Generic Platform”。 用户库ECLIPSELINK_JPA包含如下jar文件：
eclipselink.jar javax.persistence.jar org.eclipse.persistence.jpa.modelgen.jar org.eclipse.persistence.jpars.jar Entity类代码及设置 Customer类 package hello; import javax.persistence.*; @Entity @Table(name=&amp;#34;CUSTOMER&amp;#34;) public class Customer { @Id @Column(name=&amp;#34;CUSTOMER_ID&amp;#34;, nullable=false, updatable=false, unique=true) @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(name = &amp;#34;CUSTOMER_FNAME&amp;#34;) private String firstName; @Column(name = &amp;#34;CUSTOMER_LNAME&amp;#34;) private String lastName; protected Customer() {} public Customer(String firstName, String lastName) { this.firstName = firstName; this.</description></item><item><title>[JPA] 重温CascadeType</title><link>https://mryqu.github.io/post/jpa_%E9%87%8D%E6%B8%A9cascadetype/</link><pubDate>Sat, 18 Apr 2015 00:18:50 +0000</pubDate><guid>https://mryqu.github.io/post/jpa_%E9%87%8D%E6%B8%A9cascadetype/</guid><description>今天看了一篇帖子A beginner’s guide to JPA and Hibernate Cascade Types，对JPA/Hibernate中OneToOne、OneToMany、Many-To-Many关系下CascadeType的使用讲的很详尽，有代码示例也有SQL输出。作者VladMihalcea，著有High-Performance Java Persistence一书，应该淘一本学习学习。</description></item><item><title>[JPA] CascadeType.REMOVE与orphanRemoval的区别</title><link>https://mryqu.github.io/post/jpa_cascadetype.remove%E4%B8%8Eorphanremoval%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 26 Oct 2013 13:15:59 +0000</pubDate><guid>https://mryqu.github.io/post/jpa_cascadetype.remove%E4%B8%8Eorphanremoval%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>Cascading Remove 将引用字段标注为CascadeType.REMOVE（或包含REMOVE的CascadeType.ALL）表明删除操作将应该自动级联到由该字段引用的实体对象（多个实体对象可以由集合字段引用）:
@Entity class Employee { : @OneToOne(cascade=CascadeType.REMOVE) private Address address; : } Orphan Removal JPA2额外支持一种更积极的删除级联模式，可以通过@OneToOne和@OneToMany注释的orphanRemoval元素设置:
@Entity class Employee { : @OneToOne(orphanRemoval=true) private Address address; : } 区别 两个设置的区别在于关系断开的响应。 例如，将地址字段设置为null或另一个Address对象时，不同设置的结果是不同。
如果指定了 orphanRemoval = true，则断开关系的的Address实例将被自动删除。这对于清除没有所有者对象（例如Employee）引用的、不该存在的依赖对象（例如Address）很有用。 如果仅指定 cascade = CascadeType.REMOVE，则不会执行上述自动删除操作，因为断开关系不是删除操作。 参考 Deleting JPA Entity Objects</description></item></channel></rss>
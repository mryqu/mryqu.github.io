<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>symbol on Mryqu's Notes</title><link>https://mryqu.github.io/tags/symbol/</link><description>Recent content in symbol on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 31 Oct 2013 22:22:34 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/symbol/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux/Unix下显示二进制目标文件的符号表</title><link>https://mryqu.github.io/post/linux%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Thu, 31 Oct 2013 22:22:34 +0000</pubDate><guid>https://mryqu.github.io/post/linux%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description>nm 查看二进制目标文件符号表的标准工具是nm，可以执行下列命令查看二进制目标文件（.o）/静态库（.a）/动态库（.so）的符号表：
nm -g yourObj.o nm -g yourLib.a nm -g yourLib.so C/C++语言在C++编译器编译以后，函数的名字会被编译器修改，改成编译器内部的名字，这个名字会在链接的时候用到。例如std::string::size()经过修饰后是_ZNKSs4sizeEv。通过添加&amp;quot;-C&amp;quot;选项，可以对底层符号表译成用户级名称（demangle），具有更好的可读性。
以test.cpp为例： 将其编译后，通过nm查看符号表，带&amp;quot;-C&amp;quot;选项与否的结果如下：
readelf 如果你的二进制目标文件（.o）/静态库（.a）/动态库（.so）是ELF（Executableand linkingformat）格式，则可以使用readelf命令提取符号表信息。
readelf -Ws usr/lib/yourLib.so 如果仅想输出函数名，可以通过awk命令进行解析：
readelf -Ws test.o | awk &amp;#39;$4==&amp;#34;FUNC&amp;#34; {print $8}&amp;#39;; 以上面的test.o为例：
显示test.o的elf文件头信息： 显示test.o的符号表：
参考 How do I list the symbols in a .so file nm - Linux man page readelf - Linux man page</description></item><item><title>[Linux] 判断可执行文件或动态库是否包含符号表</title><link>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Thu, 24 Oct 2013 22:48:09 +0000</pubDate><guid>https://mryqu.github.io/post/linux_%E5%88%A4%E6%96%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%88%96%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description>在Linux下生成一个可执行文件或动态库，可以使用gcc/g++的&amp;quot;-g&amp;quot;选项使文件包含调试符号表。 要在Linux下判断一个第三方的可执行文件或动态库是否包含调试符号表，可以通过file命令实现：
srv01&amp;gt; file libcurl.so.6 libcurl.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (FreeBSD), dynamically linked, not stripped srv01&amp;gt; file /usr/bin/X11/curl /usr/bin/X11/curl: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), dynamically linked (uses shared libs), for FreeBSD 8.0 (800107), stripped 显示not stripped，表明文件带调试符号表；而显示stripped，表明文件已去除符号表。
如果文件包含调试符号表，可以通过objdump -t命令及选项打印文件的符号表：
srv01&amp;gt; objdump -t libcurl.so.6 libcurl.so.6: file format elf64-x86-64 SYMBOL TABLE: 0000000000000120 l d .hash 0000000000000000 00000000000012b0 l d .dynsym 0000000000000000 0000000000004b08 l d .dynstr 0000000000000000 0000000000006f36 l d .</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Virtual on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/virtual/</link>
    <description>Recent content in Virtual on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 26 Oct 2013 08:23:25 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/virtual/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;] 重温函数隐藏和重写</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</link>
      <pubDate>Sat, 26 Oct 2013 08:23:25 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E5%92%8C%E9%87%8D%E5%86%99/</guid>
      <description>首先回顾一下C++的重载、隐藏和重写概念：
 在相同作用域中，同名不同参的函数称为重载，这是c++多态的一种表现。对相同名字的成员函数，编译器可以根据传递的参数类型调用相应的成员函数。同名不同参的全局函数和类成员函数由于作用域不同，不是重载。不能通过函数返回值进行重载。像int和float这样不同的参数类型，可能会由于隐式转换隐患而无法通过编译。 当派生类中的成员函数/变量和基类中的成员函数/变量同名时，会隐藏基类的成员函数/变量，也就是指在派生类调用这个同名的成员函数/变量，调用的是派生类的成员函数/变量，而不是基类的那个成员函数/变量。可以通过类名::成员函数/变量去访问基类中同名的成员函数/变量。 派生类中的成员函数与基类的成员函数同名同参，就称为重写。当直接访问成员函数调用的是在派生类中重写的函数而不是从基类继承下来的成员函数，如果要访问从基类继承下来的成员函数也是通过类名::成员函数这种方式去调用基类的成员函数。  下面的小示例testOverride.cpp用于测试添加virtual与否对重写的影响：
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } BaseClass(const BaseClass&amp;amp;) { cout &amp;lt;&amp;lt; &amp;quot;BaseClass(BaseClass) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } virtual ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void vfun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun1() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun1() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: void vfun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:vfun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } void fun2() { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass:fun2() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); bo1-&amp;gt;vfun1(); bo1-&amp;gt;vfun2(); bo1-&amp;gt;fun1(); bo1-&amp;gt;fun2(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); do1-&amp;gt;vfun1(); // error: &#39;virtual void DerivedClass::vfun2()&#39; is private // within this context // do1-&amp;gt;vfun2(); do1-&amp;gt;fun1(); // error: &#39;void DerivedClass::fun2()&#39; is private // within this context // do1-&amp;gt;fun2(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); bo2-&amp;gt;vfun1(); bo2-&amp;gt;vfun2(); bo2-&amp;gt;fun1(); bo2-&amp;gt;fun2(); delete bo2; return 0; }  vfun2和fun2在BaseClass类中是public访问权限，而在DerivedClass类中是private访问权限。 - 对DerivedClass指针，vfun2和fun2无法访问，这个满足期望。 - 对于指向DerivedClass对象的BaseClass指针，vfun2和fun2仍然可以访问。我只能在心里留一个&amp;rdquo;?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] 重温析构函数</title>
      <link>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 25 Oct 2013 21:11:16 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/c&#43;&#43;_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>创建一个C++对象时，一般先调用父类构造函数，再调用自己的构造函数；而在销毁一个C++对象时，一般先调用自己的析构函数，再调用父类的析构函数。我用如下testDestructor.cpp进行测试。
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~BaseClass() { cout &amp;lt;&amp;lt; &amp;quot;~BaseClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;quot;NULL&amp;quot;)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass() on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;quot;DerivedClass(string) on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;quot;~DerivedClass(): name has been deleted on &amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;quot;=== test bo1 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); delete bo1; cout &amp;lt;&amp;lt; &amp;quot;=== test do1 ===&amp;quot; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); delete do1; cout &amp;lt;&amp;lt; &amp;quot;=== test bo2 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;quot;123&amp;quot;); delete bo2; cout &amp;lt;&amp;lt; &amp;quot;=== test bo3 ===&amp;quot; &amp;lt;&amp;lt; endl; BaseClass bo3 = DerivedClass(&amp;quot;321&amp;quot;); return 0; }  输出结果如下：</description>
    </item>
    
  </channel>
</rss>
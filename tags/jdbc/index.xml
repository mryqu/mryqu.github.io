<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jdbc on Mryqu's Notes</title><link>https://mryqu.github.io/tags/jdbc/</link><description>Recent content in jdbc on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 30 Jul 2015 05:35:26 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/jdbc/index.xml" rel="self" type="application/rss+xml"/><item><title>[Hive] Hive JDBC实践</title><link>https://mryqu.github.io/post/hive_hive_jdbc%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 30 Jul 2015 05:35:26 +0000</pubDate><guid>https://mryqu.github.io/post/hive_hive_jdbc%E5%AE%9E%E8%B7%B5/</guid><description>HiveJdbcClient.java 使用参考一中的示例代码:
import java.sql.SQLException; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import java.sql.DriverManager; public class HiveJdbcClient { private static String driverName = &amp;#34;org.apache.hive.jdbc.HiveDriver&amp;#34;; public static void main(String[] args) throws SQLException { try { Class.forName(driverName); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); System.exit(1); } //&amp;#34;hadoop&amp;#34; is the name of the user the queries should run as in my cluster. Connection con = DriverManager.getConnection( &amp;#34;jdbc:hive2://localhost:10000/default&amp;#34;, &amp;#34;hadoop&amp;#34;, &amp;#34;{PASSWORD_OF_USER_HADOOP}&amp;#34;); Statement stmt = con.</description></item><item><title>JDBC连接池的testQuery/validationQuery设置</title><link>https://mryqu.github.io/post/jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84testquery%E5%92%8Cvalidationquery%E8%AE%BE%E7%BD%AE/</link><pubDate>Wed, 07 May 2014 21:20:32 +0000</pubDate><guid>https://mryqu.github.io/post/jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84testquery%E5%92%8Cvalidationquery%E8%AE%BE%E7%BD%AE/</guid><description>在《Tomcat中使用Connector/J连接MySQL的超时问题》帖子中想要增加对连接池中连接的测试/验证，防止数据库认为连接已死而Web应用服务器认为连接还有效的问题，Mysql文档中提到Tomcat文档中的例子中用的是validationQuery，但是网上还有很多帖子写的是testQuery，到底用哪一个呢？ 原来这跟连接池的实现有关：
|连接池实现|该功能属性名 |&amp;mdash;&amp;ndash; |The Tomcat JDBC Connection Pool|validationQuery |The Apache Commons DBCP Connection Pool|validationQuery |c3p0 - JDBC3 Connection and Statement Pooling|preferredTestQuery | Atomikos：Tomcat Spring ActiveMQ MySQL JMX Integration
分析Atomikos数据连接池源码，弄清testQuery|testQuery
此外，测试/验证连接池连接的SQL语句也因数据库而异： Efficient SQL test query or validation query that will work across all (or most) databases DBCP - validationQuery for different Databases
综合上述两个帖子，汇总结果如下：
|数据库|测试/验证查询 |&amp;mdash;&amp;ndash; |MySQL|SELECT 1 |PostgreSQL|SELECT 1 |Microsoft SQL Server|SELECT 1 |SQLite|SELECT 1 |H2|SELECT 1 |Ingres|SELECT 1 |Oracle|select 1 from dual |DB2|select 1 from sysibm.</description></item><item><title>数据库非XA驱动和XA驱动列表</title><link>https://mryqu.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%9Exa%E9%A9%B1%E5%8A%A8%E5%92%8Cxa%E9%A9%B1%E5%8A%A8%E5%88%97%E8%A1%A8/</link><pubDate>Thu, 17 Oct 2013 19:44:55 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%9Exa%E9%A9%B1%E5%8A%A8%E5%92%8Cxa%E9%A9%B1%E5%8A%A8%E5%88%97%E8%A1%A8/</guid><description>数据库非XA驱动XA驱动Postgresorg.postgresql.Driverorg.postgresql.xa.PGXADataSourceMySQLcom.mysql.jdbc.Drivercom.mysql.jdbc.jdbc2.optional.MysqlXADataSourceOracleoracle.jdbc.OracleDriveroracle.jdbc.xa.client.OracleXADataSourceDB2com.ibm.db2.jcc.DB2Drivercom.ibm.db2.jcc.DB2XADataSourceSQL Servercom.microsoft.sqlserver.jdbc.SQLServerDrivercom.microsoft.sqlserver.jdbc.SQLServerXADataSourceTeradatacom.teradata.jdbc.TeraDriver</description></item><item><title>PostgreSQL JDBC setFetchSize</title><link>https://mryqu.github.io/post/postgresql_jdbc_setfetchsize/</link><pubDate>Fri, 14 Jun 2013 17:56:08 +0000</pubDate><guid>https://mryqu.github.io/post/postgresql_jdbc_setfetchsize/</guid><description>今天看到我们的Hiberante配置没有设hibernate.jdbc.fetch_size。 Fetch Size是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数。例如一次查询1万条记录，对于Oracle的JDBC驱动来说，是不会1次性把1万条取出来的，而只会取出FetchSize条数，当纪录集遍历完了这些记录以后，再去数据库取Fetch Size条数据。因此大大节省了无谓的内存消耗。当然FetchSize设的越大，读数据库的次数越少，速度越快；FetchSize越小，读数据库的次数越多，速度越慢。这有点像平时我们写程序写硬盘文件一样，设立一个缓冲，每次写入缓冲，等缓冲满了以后，一次写入硬盘，道理相同。 看了一下Postgres，它的JDBC驱动却是一次将查询的所有结果都返回。相反使用游标、设置fetchsize倒是麻烦不少。 http://jdbc.postgresql.org/documentation/head/query.html</description></item></channel></rss>
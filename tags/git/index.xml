<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>git on Mryqu's Notes</title><link>https://mryqu.github.io/tags/git/</link><description>Recent content in git on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 19 Mar 2021 12:31:23 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>go get github.comjessevdkgo-assets解决记录</title><link>https://mryqu.github.io/post/go-get-github.comjessevdkgo-assets%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 19 Mar 2021 12:31:23 +0000</pubDate><guid>https://mryqu.github.io/post/go-get-github.comjessevdkgo-assets%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</guid><description>在我的Cenos服务器上无法获取go-assets，结果如下：
MRYQULAX&amp;gt; go get github.com/jessevdk/go-assets # cd .; git clone -- https://github.com/jessevdk/go-assets /users/mryqu/go/src/github.com/jessevdk/go-assets Cloning into &amp;#39;/users/mryqu/go/src/github.com/jessevdk/go-assets&amp;#39;... fatal: unable to access &amp;#39;https://github.com/jessevdk/go-assets/&amp;#39;: SSL connect error package github.com/jessevdk/go-assets: exit status 128 看了一下我的git版本是1.7.1，先升级一下试试吧。
export VER=&amp;#34;2.31.0&amp;#34; wget https://github.com/git/git/archive/v${VER}.tar.gz tar -xvf v${VER}.tar.gz rm -f v${VER}.tar.gz cd git-* make configure sudo ./configure --prefix=/usr sudo make sudo make install 升级完成后，还是无法获取go-assets。
调试一下ssh方式：
MRYQULAX&amp;gt; ssh -vT git@github.com OpenSSH_5.3p1, OpenSSL 1.0.0-fips 29 Mar 2010 debug1: Reading configuration data /users/mryqu/.ssh/config debug1: Reading configuration data /etc/ssh/ssh_config debug1: Applying options for * debug1: Connecting to github.</description></item><item><title>[Gradle] 遭遇 Unable to process incoming event 'ProgressComplete' (ProgressCompleteEvent)</title><link>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</link><pubDate>Thu, 30 Nov 2017 06:08:53 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</guid><description>最近开始玩一个项目，结果gradle build总是报错：
FAILURE: Build failed with an exception. * What went wrong: Unable to process incoming event &amp;#39;ProgressComplete &amp;#39; (ProgressCompleteEvent) 参考了帖子Build fails with “Unable to process incoming event ‘ProgressComplete ’ (ProgressCompleteEvent)”：
The Workaround: use the --console plain gradle command line switch The Fix: If you use git + git-bash, upgrade to git 2.x.x (2.9.3 is current and works for me) If you use DOS, try increasing your screen buffer size.(mine is 1024 x 1024) 将Git Window从2.</description></item><item><title>升级Windows版Git客户端</title><link>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7windows%E7%89%88git%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Thu, 17 Mar 2016 06:10:33 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7windows%E7%89%88git%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>今天在公司收到通知，说Git又有安全漏洞了，需要升级到最新的2.7.3。扫了一眼Get ready to patch Git servers, clients – nasty-looking bugs surface，漏洞涉及到2.x、1.9和1.7版本。 我本机装的是git version 1.9.5.msysgit.0，这才发现MsysGit去年八月份就被Git for Windows 2.x取代了。这次顺手把Git Extensions也给升级到2.48.05了。</description></item><item><title>[Git] 操作Git仓库已删除文件</title><link>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 11 Nov 2015 05:49:56 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E6%93%8D%E4%BD%9Cgit%E4%BB%93%E5%BA%93%E5%B7%B2%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</guid><description>忙着工作，忽然出了一下神，觉得自己对Git仓库已删除文件的操作还没有练习过，决定找资料学习一下。
列举所有Git仓库已删除文件 下列命令可以列举出所有提交信息及被删除的文件：
git log --diff-filter=D --summary 下列命令可以列举出所有被删除的文件，不显示提交信息：
git log --diff-filter=D --summary | grep delete 列举一个Git仓库已删除文件的提交历史信息 仅使用git log无法查看Git仓库已删除文件的提交历史信息。
git log $deletedFile fatal: ambiguous argument &amp;#39;deletedFile&amp;#39;: unknown revision or path not in the working tree. 下列命令则可以：
git log -- $deletedFile 恢复一个Git仓库已删除文件 找到删除该文件的提交哈希值
git rev-list -n 1 HEAD -- $deletedFile 通过删除该文件提交（$deletingCommit）的前一个提交($deletingCommit~1)恢复已删除文件:
git checkout $deletingCommit~1 -- $deletedFile 参考 Is there a way in Git to list all deleted files in the repository
Git: Getting the history of a deleted file</description></item><item><title>[Git] 分支笔记</title><link>https://mryqu.github.io/post/git_%E5%88%86%E6%94%AF%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 08 Nov 2015 05:44:25 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E5%88%86%E6%94%AF%E7%AC%94%E8%AE%B0/</guid><description>最近接触了一些Git远程分支的操作和管理，做个笔记。
创建本地分支 git branch [branch] 切换本地分支 git checkout [branch] 删除本地分支 git branch -D [branch] 重命名本地分支 git branch -m [oldbranch] [newbranch] 查看分支 # 查看本地分支 （-v选项可以显示sha1和提交消息标题） git branch git branch -v # 查看远程分支 git branch -r git branch -rv # 查看本地和远程分支 git branch -a git branch -av 向远程分支推送（远程分支不存在则会创建远程分支） # 期望本地分支与远程分支同名，可以先切换到本地分支进行提交 git push [remote] [branch] # 通过-u选项同时使新创建的远程分支成为本地分支的上游分支 git push -u [remote] [branch] # 期望本地分支与远程分支使用不同名称 git push [remote] [localbranch]:[remotebranch] # 例子： git push origin v9:v9 使用存在的远程分支创建本地分支，远程分支也成为新创建的本地分支的上游分支 # 期望本地分支与远程分支同名 git checkout --track [remote]/[remotebranch] # 例子： git checkout --track origin/v9 # 当git checkout [branch]执行时，本地分支不存在且仅与一个远程分支名匹配事， # 其效果等同上面--track选项。 # 期望本地分支与远程分支使用不同名称 git checkout -b [localbranch] [remote]/[remotebranch] # 例子： git checkout -b v9test origin/v9 本地分支和远程分支都存在的情况下，使远程分支也成为本地分支的上游分支 # 使远程分支成为当前本地分支的上游分支 git branch -u [remote]/[remotebranch] # 使远程分支成为某一特定本地分支的上游分支 git branch --set-upstream-to=[remote]/[remotebranch] [localbranch] 去除本地分支的上游分支 git branch --unset-upstream [branch] 删除远程分支 git push [remote] :[remotebranch] # 或 git push --delete [remote] [remotebranch] 在本地库删除已废弃的远程分支 # 远程分支被别人删除后，自己本地库中该远程分支为废弃状态，可使用下列命令移除该远程分支 git remote prune [remote] 参考 Git Branching - Branches in a Nutshell</description></item><item><title>安装Gerrit的commit-msg钩子</title><link>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85gerrit%E7%9A%84commit-msg%E9%92%A9%E5%AD%90/</link><pubDate>Wed, 19 Aug 2015 05:34:23 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%AE%89%E8%A3%85gerrit%E7%9A%84commit-msg%E9%92%A9%E5%AD%90/</guid><description>对Gerrit进行首次提交前需要安装commit-msg钩子，每次总忘，每次都总是搜邮件，还是记博客里方便些。
gitdir=$(git rev-parse --git-dir); scp -p -P 29418 [your username]@[your Gerrit review server]:hooks/commit-msg {gitdir}/hooks/ 参考
Gerrit：commit-msg Hook
Gerrit工作流</description></item><item><title>Gradle Git Plugin介绍</title><link>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Sun, 12 Jul 2015 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</guid><description>Grgit和gradle-git Git是一个很流行的分布式版本管理工具。能在构建过程中与Git进行交互，可以提供更强大和更一致的结果。
JGit提供了与Git仓库交互的强大JavaAPI。然而，在Groovy上下本使用它会笨重，需要在所要执行的表达式包一堆换七八糟的东东。Grgit是Andre wOberstar实现的JGit封装器，为基于Groovy的工具与Git仓库交互提供了更简洁流畅的API。 gradle-git同样是由Andrew Oberstar实现的一系列Gradle插件：
org.ajoberstar.grgit - 提供一个Grgit实例，允许与Gradle项目所在的Git仓库交互 org.ajoberstar.github-pages - 向Github仓库的gh-pages分支发布文件 org.ajoberstar.release-base -提供用于从项目状态和所在Git仓库推断当前项目版本和创建新版本的通用结构 org.ajoberstar.release-opinion -用于org.ajoberstar.release-base的默认选项，遵从语义版本控制（Semantic Versioning）下面是一个Gradle任务示例，用于从Git仓库克隆项目。 build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;org.ajoberstar:gradle-git:1.2.0&amp;#39; } } import org.ajoberstar.gradle.git.tasks.* task cloneGitRepo(type: GitClone) { def destination = file(&amp;#34;destination_folder&amp;#34;) uri = &amp;#34;your_git_repo_uri&amp;#34; destinationPath = destination bare = false enabled = !destination.exists() //to clone only once } 参考 GitHub：ajoberstar/gradle-git
GitHub：ajoberstar/grgit</description></item><item><title>Git+Gerrit+Gradle+Jenkins持续集成</title><link>https://mryqu.github.io/post/git+gerrit+gradle+jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link><pubDate>Sun, 26 Apr 2015 07:45:11 +0000</pubDate><guid>https://mryqu.github.io/post/git+gerrit+gradle+jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid><description>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile）在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。
Gerrit Gerrit是基于GWT web应用的开源代码审查系统，为使用Git版本控制系统的项目提供在线代码审查。安卓开源项目（AOSP）用其来管理多代码库的庞大项目。Gerrit通过在自身代码库跟踪提交的Git变更集来提供代码审查的。它并排显示新旧文件，让审查者更容易对变更进行审查，并允许审查者添加内嵌注释。 提交的变更既可以被Jenkins这样的自动系统进行审查，也可以由同事进行审查。每个审查者检查代码变更、添加注释，然后将变更标记为“在我看来代码不错”(“没有打分”或“我期望你不要提交代码”)。验证者(例如Jenkins或其他人)通过构建和测试代码来验证变更。如果他们认为代码可行，则设置“在我看来代码不错”标记，Gerrit将尝试将变更合并到公开的“权威”代码库。文章Life of a Patch描述了这一工作流: Gradle 在Java构建工具的世界里，先有了Ant，然后有了Maven。Maven的CoC（约定优于配置）、依赖管理以及项目构建规则重用性等特点，让Maven几乎成为Java构建工具的事实标准。然而，冗余的依赖管理配置、复杂并且难以扩展的构建生命周期，都成为使用Maven的困扰。Gradle作为新的构建工具，是基于Groovy语言的构建工具，既保持了Maven的优点，又通过使用Groovy定义的DSL克服了Maven中使用XML繁冗以及不灵活等缺点，支持依赖管理和多项目，而且它有非常完善的说明文档。目前，SpringSource、Hibernate等都采用Gradle来构建。
Jenkins Jenkins，之前叫做Hudson，是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时Jenkins能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins通过Gerrit触发器插件可在新的Gerrit补丁集创建时开始使用Gerrit代码库中的代码进行构建项目，通过Gradle插件调用Gradle构建脚本，以帮助变更验证。
参考 Git权威指南-第5篇-第32章 Gerrit 代码审核服务器 Git+Gerrit+Gradle+Jenkins持续集成设置</description></item><item><title>[Git] Create patch with untracked files</title><link>https://mryqu.github.io/post/git_create_patch_with_untracked_files/</link><pubDate>Tue, 27 Jan 2015 20:10:27 +0000</pubDate><guid>https://mryqu.github.io/post/git_create_patch_with_untracked_files/</guid><description>前一博文Create patch with untracked files using Git format-patch/diff/stash中的方案比较绕，今天有了一个更好一点的法子:
git add . git diff --cached &amp;gt; yqu.patch git reset origin/master</description></item><item><title>[Git] Create patch with untracked files using Git format-patch/diff/stash</title><link>https://mryqu.github.io/post/git_create_patch_with_untracked_files_using_git_format-patch_diff_stash/</link><pubDate>Mon, 26 Jan 2015 20:03:22 +0000</pubDate><guid>https://mryqu.github.io/post/git_create_patch_with_untracked_files_using_git_format-patch_diff_stash/</guid><description>Setup testing environment I created 123.txt at branch master, then modified 123.txt and added321.txt at branch yqu
C:\test&amp;gt;mkdir GitTest C:\test&amp;gt;cd GitTest C:\test\GitTest&amp;gt;git init Initialized empty Git repository in C:/test/GitTest/.git/ C:\test\GitTest&amp;gt;echo &amp;#34;this is a file at mast branch&amp;#34; &amp;gt; 123.txt C:\test\GitTest&amp;gt;git add 123.txt C:\test\GitTest&amp;gt;git commit -m &amp;#34;initial commit&amp;#34; [master (root-commit) f140825] initial commit 1 file changed, 1 insertion(+) create mode 100644 123.txt C:\test\GitTest&amp;gt;git push origin HEAD:master C:\test\GitTest&amp;gt;git checkout -b yqu Switched to a new branch &amp;#39;yqu&amp;#39; C:\test\GitTest&amp;gt;echo &amp;#34;bye&amp;#34; &amp;gt;&amp;gt; 123.</description></item><item><title>从TortoiseGit切换到Git Extensions</title><link>https://mryqu.github.io/post/%E4%BB%8Etortoisegit%E5%88%87%E6%8D%A2%E5%88%B0git_extensions/</link><pubDate>Sun, 07 Sep 2014 12:13:06 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BB%8Etortoisegit%E5%88%87%E6%8D%A2%E5%88%B0git_extensions/</guid><description>一开始使用GitHub的服务，除了安装了msysGit&amp;rsquo;s Git for Windows，GUI客户端就是GitHub的Web界面。后来使用bitbucket的服务时，想要安装一个好使又通用的GUI客户端。由于使用TortoiseCVS和TortoiseSVN，自然就选择了TortoiseGit。由于三者界面风格一致，使用无障碍上手。最近开始使用公司的git仓库，公司指定的是Git Extensions。好吧，Bye， TortoiseGit。 好奇了一下，上网搜了两者的对比。貌似相当一部分人使用TortoiseGit的理由跟我一样，不过有一些人更推荐Git Extensions。此外还有一个商业产品SmartGit，但貌似使用的人更少。搜索结果：What is the Best Git GUI (Client) for Windows? TortoiseGit vs Git ExtensionsAsk HN: Best Git GUI For Windows?</description></item><item><title>[Git] 裸代码仓库和镜像代码仓库</title><link>https://mryqu.github.io/post/git_%E8%A3%B8%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E5%92%8C%E9%95%9C%E5%83%8F%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</link><pubDate>Sat, 15 Feb 2014 00:38:47 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E8%A3%B8%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E5%92%8C%E9%95%9C%E5%83%8F%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</guid><description>注：本文中操作都没有设置$GIT_DIR环境变量。
Git init和clone命令对bare和mirror参数的支持 ||&amp;ndash;bare参数|&amp;ndash;mirror参数 |&amp;mdash;&amp;ndash; |git init命令|支持|/ |git clone命令|支持|支持
裸代码仓库与普通代码仓库的区别 从技术的角度上讲，理论上无论Git代码仓库是否为裸代码仓库都可以接受push。可Git的策略是仅向裸代码仓库发送push。在Mercurial中，任何普通代码仓库都可以用于远程代码仓库，接受push。这是因为push所含的变化仅影响Mercurial代码仓库的版本控制，而不会影响其工作树。在Git中，如果向普通代码仓库push的话，Git会将推送的内容与工作文件进行比较，它会认为工作文件发生改变，从而影响工作树。而裸代码仓库由于没有工作树，所以push所含的变化仅影响裸代码仓库的版本控制。Git FAQ提到：A quick rule ofthumb is to never push into a repository that has a work treeattached to it, until you know what you are doing.
镜像代码仓库 git clone&amp;ndash;mirror命令会创建一个后缀为&amp;quot;.git&amp;quot;的目录，直接包含hooks、info、objects和refs子目录和config、description和HEAD文件，不包含远程Git代码仓库的工作树。config文件内容如下：
[core] repositoryformatversion = 0 filemode = false bare = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly [remote &amp;#34;origin&amp;#34;] url = https://github.com/usr1/demo.git fetch = +refs/*:refs/* mirror = true 镜像代码仓库也是裸代码仓库，它与裸代码仓库的区别在于：它不仅将源代码仓库的本地分支映射到目标代码仓库的本地分支，而且将所有引用（包括远程跟踪分支、备注等）都进行映射并建立refspec配置以使目标代码仓库的所有引用可被gitremote update命令覆盖。裸代码仓库在克隆命令结束后，所有源代码仓库的本地分支映射到目标代码仓库的本地分支，但是不包含远程分支。它就被完全独立地建立，不再期望后继fetch操作，所有远程分支及其他引用会被忽略掉。镜像代码仓库类似源代码仓库被完整复制，当执行git remote update命令时类似源代码仓库再次被完整复制。</description></item><item><title>[Git] Git代理配置</title><link>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 01 Dec 2013 22:00:58 +0000</pubDate><guid>https://mryqu.github.io/post/git_git%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>设置Git的http和https代理 git config --global http.proxy http://proxyUser:proxyPwd@proxyServer:proxyPort git config --global https.proxy https://proxyUser:proxyPwd@proxyServer:proxyPort 查询Git的http和https代理 git config --global --get http.proxy git config --global --get https.proxy 移除Git的http和https代理 git config --global --unset http.proxy git config --global --unset https.proxy</description></item><item><title>[Git] 查看某文件历史记录</title><link>https://mryqu.github.io/post/git_%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 09 Nov 2013 06:38:12 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid><description>在Git中查看某个文件历史记录，方式如下：
git log [filename]：显示对该文件的提交记录 git log -p [filename]：显示对该文件的提交记录及每次提交增量内容 gitk [filename]：图形显示对该文件的提交记录及每次提交增量内容</description></item><item><title>[Git] 预览远程仓库与本地仓库的差异</title><link>https://mryqu.github.io/post/git_%E9%A2%84%E8%A7%88%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%B7%AE%E5%BC%82/</link><pubDate>Mon, 23 Sep 2013 20:19:12 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E9%A2%84%E8%A7%88%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%B7%AE%E5%BC%82/</guid><description>首先使用git fetch更新远程分支的本地副本，这不会对任何本地分支造成影响。
使用git log HEAD..origin可以显示本地分支与origin远程分支之间的提交日志。
使用git log -p HEAD..origin除了显示上述提交日志外，还会显示每个提交的补丁。
使用git diff HEAD...origin显示整个补丁。此外如果有本地未提交的修改，可以使用git diff origin/master显示整个补丁。
如果不想使用git pull来合并所有远程提交，可以使用git cherry-pick接受所需要的指定远程提交。最后当准备好接受所有远程提交再使用git pull合并剩余远程提交。</description></item><item><title>[Git] 获取两个版本间所有变更的文件列表</title><link>https://mryqu.github.io/post/git_%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E9%97%B4%E6%89%80%E6%9C%89%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/</link><pubDate>Sun, 22 Sep 2013 07:25:11 +0000</pubDate><guid>https://mryqu.github.io/post/git_%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E9%97%B4%E6%89%80%E6%9C%89%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8/</guid><description>git diff commit-SHA1 commit-SHA2 &amp;ndash;name-status返回变更的文件列表，每个文件前带有变更状态：
&amp;rsquo; &amp;rsquo; = unmodified M = modified A = added D = deleted R = renamed C = copied U = updated but unmergedgit diff commit-SHA1 commit-SHA2 &amp;ndash;stat返回变更的文件列表，每个文件后面带有变更统计信息。</description></item><item><title>SSH keys for Git System</title><link>https://mryqu.github.io/post/ssh_keys_for_git_system/</link><pubDate>Wed, 18 Sep 2013 22:58:33 +0000</pubDate><guid>https://mryqu.github.io/post/ssh_keys_for_git_system/</guid><description>SSH keys An SSH key allows you to establish a secure connection betweenyour computer and Git system such as GitHub, GitLab. Before generating an SSH key, check if your system already hasone by running cat ~/.ssh/id_rsa.pub . If you see a long string startingwith ssh-rsa or ssh-dsa ,you can skip the ssh-keygen step. To generate a new SSH key, just open your terminal and use codebelow. The ssh-keygen command prompts you for a location andfilename to store the key pair and for a password.</description></item><item><title>git资料</title><link>https://mryqu.github.io/post/git%E8%B5%84%E6%96%99/</link><pubDate>Sat, 13 Jul 2013 18:52:24 +0000</pubDate><guid>https://mryqu.github.io/post/git%E8%B5%84%E6%96%99/</guid><description>综合 Pro Git 英文版 中文版
Git Community Book 英文版 中文版
GotGitHub
Git使用详解
项目主页 Creating Project Pages manually
Setup GitHub Pages &amp;ldquo;gh-pages&amp;rdquo; branch and &amp;ldquo;master&amp;rdquo; branch as subfolders of a parent project folder (&amp;ldquo;grandmaster&amp;rdquo;).
Setup GitHub Pages &amp;ldquo;gh-pages&amp;rdquo; branch as a subfolder within the &amp;ldquo;master&amp;rdquo; project on your local checkout - a step-by-step guide.
其他 Collaborative Github Workflow
如何理解git reset 取消提交的操作？
Git Document
Atlassian Git Tutorial
版本管理svn,git,cvs比较
learnGitBranching
a successful git branching model</description></item></channel></rss>
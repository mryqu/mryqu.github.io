<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>区别 on Mryqu's Notes</title><link>https://mryqu.github.io/tags/%E5%8C%BA%E5%88%AB/</link><description>Recent content in 区别 on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 23 Oct 2015 05:57:46 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/%E5%8C%BA%E5%88%AB/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring 框架: @RestController vs @Controller</title><link>https://mryqu.github.io/post/spring%E6%A1%86%E6%9E%B6_@restcontroller_vs_@controller/</link><pubDate>Fri, 23 Oct 2015 05:57:46 +0000</pubDate><guid>https://mryqu.github.io/post/spring%E6%A1%86%E6%9E%B6_@restcontroller_vs_@controller/</guid><description>今天扫了一眼RestController注解的实现，它是@Controller和@ResponseBody的合体。
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { String value() default &amp;#34;&amp;#34;; } 至于@RestController与@Controller的所有区别，还不是完全明了。看了Srivatsan Sundararajan和Swapna Sagi的大作Spring Framework: @RestController vs @Controller，感觉豁然开朗。
Spring MVC框架和REST Spring基于MVC框架的注解简化了创建RESTful web服务流程。传统MVS控制器和RESTfulweb服务控制器关键区别在于HTTP响应体创建方式。传统MVC控制器依赖试图技术，而RESTfulweb服务控制器仅仅返回对象并将对象数据作为JSON/XML直接写到HTTP响应中。关于使用Spring框架创建RESTfulWEB服务的技术细节，点击这里。 图1: Spring MVC传统工作流
Spring MVC REST工作流 传统Spring MVC REST工作流步骤如下:
客户端以URI形式向web服务发送一个请求。The client sends a request to a webservice in URI form. 请求被DispatcherServlet拦截用于查找处理器映射（Handler Mappings）及类型。 在应用上下文文件中定义的处理器映射会告知DispatcherServlet用于基于请求查找控制器的策略。 Spring MVC支持三种类型的请求URI与控制器间的映射：注解、名称转换和显式映射。 请求由控制器处理后，响应返回给DispatcherServlet后分发给视图。 在图1中，注意在传统工作流中ModelAndView对象由控制器转发给客户端。在方法上使用@ResponseBody注解，Spring可让应用直接从控制器返回数据，不再查找视图。从第4版起，引入@RestController注解进一步简化处理流程。两种使用方式解释如下。
使用@ResponseBody注解 当对一个方法使用@ResponseBody注解后，Spring将返回值进行转换并自动写入Http响应中。控制器类的每个方法必须使用@ResponseBody进行注解。 图2: Spring 3.x MVC RESTful web服务工作流
幕后工作 Spring在幕后注册了一系列HttpMessageConverters。HTTPMessageConverter负责根据预先定义的MIME类型将请求体转换成特定类及将特定类转换成响应体。每次一个请求匹配上@ResponseBody，Spring遍历所有已注册的HTTPMessageConverter，查找到第一个匹配上给定MIME类型和类的HTTPMessageConverter用之进行实际转换。
代码示例 下面过一个使用@ResponseBody的简单示例。
创建名为Employee的Java POJO类。
package com.example.spring.model; import javax.</description></item><item><title>WebStorm与IntelliJ IDEA的区别</title><link>https://mryqu.github.io/post/webstorm%E4%B8%8Eintellij_idea%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 06 Dec 2014 16:35:23 +0000</pubDate><guid>https://mryqu.github.io/post/webstorm%E4%B8%8Eintellij_idea%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>WebStorm与IntelliJ IDEA都被很多JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScriptIDE”等，用了一点IntelliJ IDEA，还真不知道两者有什么联系和区别。网上搜了一下，WebStorm FAQ和PhpStorm FAQ解答了我的疑问。JetBrains旗下的产品：
IntelliJ IDEA偏重于Java开发，旗舰产品，它可以通过（捆绑的或可下载的）插件的方式提供WebStorm和PhpStorm所有的功能。支持Scala和Groovy开发，也可以通过插件支持Ruby和Python语言。 PhpStorm侧重于PHP开发 WebStorm侧重于JS开发 RubyMine侧重于Ruby和Rails开发 PyCharm侧重于Python和Djanjo开发WebStorm与IntelliJ IDEA相比，功能少，集中于JS开发这一块，更加轻量级，新项目配置起来更简单。 下面两个链接是WebStorm和IntelliJ IDEA的官方报价，WebStorm的价格大概是IntelliJIDEA的五分之一。
https://www.jetbrains.com/webstorm/buy/ https://www.jetbrains.com/idea/buy/</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>difference on Mryqu's Notes</title><link>https://mryqu.github.io/tags/difference/</link><description>Recent content in difference on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 23 Oct 2015 05:57:46 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/difference/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring 框架: @RestController vs @Controller</title><link>https://mryqu.github.io/post/spring%E6%A1%86%E6%9E%B6_restcontroller_vs_controller/</link><pubDate>Fri, 23 Oct 2015 05:57:46 +0000</pubDate><guid>https://mryqu.github.io/post/spring%E6%A1%86%E6%9E%B6_restcontroller_vs_controller/</guid><description>今天扫了一眼RestController注解的实现，它是@Controller和@ResponseBody的合体。
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { String value() default &amp;#34;&amp;#34;; } 至于@RestController与@Controller的所有区别，还不是完全明了。看了Srivatsan Sundararajan和Swapna Sagi的大作Spring Framework: @RestController vs @Controller，感觉豁然开朗。
Spring MVC框架和REST Spring基于MVC框架的注解简化了创建RESTful web服务流程。传统MVS控制器和RESTfulweb服务控制器关键区别在于HTTP响应体创建方式。传统MVC控制器依赖试图技术，而RESTfulweb服务控制器仅仅返回对象并将对象数据作为JSON/XML直接写到HTTP响应中。关于使用Spring框架创建RESTfulWEB服务的技术细节，点击这里。 图1: Spring MVC传统工作流
Spring MVC REST工作流 传统Spring MVC REST工作流步骤如下:
客户端以URI形式向web服务发送一个请求。The client sends a request to a webservice in URI form. 请求被DispatcherServlet拦截用于查找处理器映射（Handler Mappings）及类型。 在应用上下文文件中定义的处理器映射会告知DispatcherServlet用于基于请求查找控制器的策略。 Spring MVC支持三种类型的请求URI与控制器间的映射：注解、名称转换和显式映射。 请求由控制器处理后，响应返回给DispatcherServlet后分发给视图。 在图1中，注意在传统工作流中ModelAndView对象由控制器转发给客户端。在方法上使用@ResponseBody注解，Spring可让应用直接从控制器返回数据，不再查找视图。从第4版起，引入@RestController注解进一步简化处理流程。两种使用方式解释如下。
使用@ResponseBody注解 当对一个方法使用@ResponseBody注解后，Spring将返回值进行转换并自动写入Http响应中。控制器类的每个方法必须使用@ResponseBody进行注解。 图2: Spring 3.x MVC RESTful web服务工作流
幕后工作 Spring在幕后注册了一系列HttpMessageConverters。HTTPMessageConverter负责根据预先定义的MIME类型将请求体转换成特定类及将特定类转换成响应体。每次一个请求匹配上@ResponseBody，Spring遍历所有已注册的HTTPMessageConverter，查找到第一个匹配上给定MIME类型和类的HTTPMessageConverter用之进行实际转换。
代码示例 下面过一个使用@ResponseBody的简单示例。
创建名为Employee的Java POJO类。
package com.example.spring.model; import javax.</description></item><item><title>[Gradle] buildScript块与allprojects块及根级别的repositories区别</title><link>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 29 Jun 2015 00:03:59 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</guid><description>一直对为什么buildScript块里定义了repositories而allprojects段或根还定义repositories没有思考过，偶然有了念头想要探究一下。
build.gradle：
buildScript块主要是为了Gradle脚本自身的执行，获取脚本依赖插件。我在写的一篇博客《尝试Artifactory》中Gradle脚本需要com.jfrog.artifactory插件才能执行成功，而这个插件是从URL为https://plugins.gradle.org/m2/的Maven仓库获得。 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。 allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。
参考 What&amp;rsquo;s the difference between buildscript and allprojects in build.gradle?
Gradle buildscript dependencies
Gradle: Project</description></item><item><title>[Hadoop] mapred和mapreduce包的区别</title><link>https://mryqu.github.io/post/hadoop_mapred%E5%92%8Cmapreduce%E5%8C%85%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Fri, 12 Jul 2013 16:55:48 +0000</pubDate><guid>https://mryqu.github.io/post/hadoop_mapred%E5%92%8Cmapreduce%E5%8C%85%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>背景介绍 在Hadoop的代码中，存在org.apache.hadoop.mapred和org.apache.hadoop.mapreduce两个包。mapred包下是老的API，在Hadoop0.20时被废弃了，引入了新包mapreduce，但是由于新的API迟迟没有完成，所以在Hadoop0.21中取消了mapred包的废弃状态。原来的设想中老包mapred在Hadoop0.22和1.0中将再次设成废弃状态，但时至今日也没有被废弃。
区别 本文将通过WordCount示例代码，介绍一下二者的区别。WordCount示例代码分别取自0.19和0.23.9版本的Hadoop源码。
0.19版WordCount示例 0.23.9版WordCount示例 注意事项 尽量使用新API。在mapred和mapreduce两个包下存在FileInputFormat、FileOutputFormat等名字一样的类，如果引入错误的话，程序会无法通过编译。
参考 Upgrading To The New Map Reduce API
Difference between Hadoop OLD API and NEW API</description></item></channel></rss>
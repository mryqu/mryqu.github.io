<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>组件 on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/%E7%BB%84%E4%BB%B6/</link>
    <description>Recent content in 组件 on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 18 Feb 2013 12:49:30 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/%E7%BB%84%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>尝试了一下jacob</title>
      <link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95%E4%BA%86%E4%B8%80%E4%B8%8Bjacob/</link>
      <pubDate>Mon, 18 Feb 2013 12:49:30 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95%E4%BA%86%E4%B8%80%E4%B8%8Bjacob/</guid>
      <description>JACOB开源项目 Jacob是Java与COM组件桥接的缩写，即JAVA-COMBridge。通过使用Jacob类库，我们可以很方便地在Java程序中使用JNI来进行本地调用COM库。它可运行在x86和（支持32位和64位Java虚拟机的）X64环境。Jacob最初是由美国人DanAlder在Inventure公司担任CTO时编写的，目的是为了方便众多的程序员在Java2虚拟机上，调用Win32平台上COM自动化服务器中的组件。当Jacob项目以开源的方式在网络上公布以后，越来越多的人开始参与项目的研发与改进中去。
JACOB 相关博文： Jacob的简单介绍
Jacob使用入门及问题解析</description>
    </item>
    
    <item>
      <title>Flex启动次序</title>
      <link>https://mryqu.github.io/post/flex%E5%90%AF%E5%8A%A8%E6%AC%A1%E5%BA%8F/</link>
      <pubDate>Wed, 18 Jul 2012 13:28:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/flex%E5%90%AF%E5%8A%A8%E6%AC%A1%E5%BA%8F/</guid>
      <description>所有Flex组件在启动过程都会触发一些事件。这些事件指示何时组件首次被创建、在内部进行描绘、在屏幕上进行绘制。这些事件也指示何时组件结束创建，当组件为容器时指示何时子组件被创建。 组件被实例化、加入或链接父组件，之后在容器内确定大小并布局。组件创建顺序如下： 下例展示了组件创建生命期内分发的一些重要事件： 容器和组件的创建顺序是不同的，因为容器可为其他组件的父组件。容器内的组件也必须经历创建顺序。如果一个容器是另一个容器的父组件，内部容器的子组件也必须经历创建顺序。 下例展示了容器创建生命期内分发的一些重要事件： 当所有组件被创建并在屏幕绘制，Application对象会分发一个applicationComplete事件。这是程序启动的最后一个被分发的事件。 multiview容器(navigators)的启动顺序与标准容器不同。默认情况下，导航器(navigator)的所有顶级视图会被实例化。然而，Flex仅创建初始可见视图的子组件。当用户切到导航器的其他视图，Flex才会为此视图创建子组件。</description>
    </item>
    
    <item>
      <title>FLEX组件的生命周期</title>
      <link>https://mryqu.github.io/post/flex%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 16 Jul 2012 13:19:52 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/flex%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>组件实例化生命周期描述了用组件类创建组件对象时所发生的一系列步骤,作为生命周期的一部分,flex自动调用组件的的方法,发出事件,并使组件可见。 下面例子用as创建一个btn控件,并将其加入容器中
var boxContainer:Box = new Box(); //设置Box容器 ... //创建btn var b:Button = new Button(); b.label = &amp;quot;Submit&amp;quot;; ... //将btn添加到Box容器中 boxContainer.addChild(b);  下面的步骤显示了用代码创建一个Button控件，并将这个控件添加到Box容器中时所发生的一切： 1. 调用了组件的构造函数; var b:Button = new Button(); 2. 通过设置组件的属性对组件进行设置: //Configure the button control. b.label = &amp;rdquo;Submit&amp;rdquo;; 组件的setter方法将会调用invalidateProperties()、invalidateSize()、invalidateDisplayList()方法。 3. 调用addChild()方法将该组件添加到父组件。 //Add the Button control to the Box container. boxContainer.addChild(b); 4. 将component的parent的属性设置为对父容器的引用. 5. 计算组件样式(style)设置。 6. 在组件上发布priininialize事件。 7. 调用组件的createChildren()方法。 8. 调用invalidateProperties(),invalidateSize(),invalidateDisplayList()方法以触发后续到来的,下一个&amp;rdquo;渲染事件&amp;rdquo;(render event)期间对commitProperties(),measure(),updateDisplayList()方法的调用.这个规则唯一一个例外就是当用户设置组件的height和width属性时,Flex不会调用measure()方法。 9. 在组件上分发initialize事件。此时，组件所有的子组件都被初始化，但是组件没有改更size和处理布局。可以利用这个事件在组件布局之前执行一些附加的处理。 10. 在父容器上分发childAdd事件。 11. 在父容器上分发initialize事件。 12. 在下一个&amp;rdquo;渲染事件&amp;rdquo;(render event)中,Flex执行以下动作: - 调用组件的commitProperties()方法。 - 调用组件的measure()方法。 - 调用组件的layoutChrome方法。 - 调用组件的updateDisplayList()方法。 - 在组件上发布updateComplete事件。 13.</description>
    </item>
    
  </channel>
</rss>
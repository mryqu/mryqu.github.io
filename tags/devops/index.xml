<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>devops on Mryqu's Notes</title><link>https://mryqu.github.io/tags/devops/</link><description>Recent content in devops on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 16 Sep 2015 06:09:37 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>kitematic代理设置</title><link>https://mryqu.github.io/post/kitematic%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</link><pubDate>Wed, 16 Sep 2015 06:09:37 +0000</pubDate><guid>https://mryqu.github.io/post/kitematic%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</guid><description>在DockerToolbox目录下创建一个批处理脚本文件kitematic_proxy.cmd，插入下面代码，将&amp;quot;YOUR_PROXY&amp;quot;替换为所用的代理（http://host:port）。
set proxy=YOUR_PROXY SET HTTP_PROXY=%proxy% SET HTTPS_PROXY=%proxy% for /f %%i in (&amp;#39;docker-machine.exe ip default&amp;#39;) do set DOCKER_HOST=%%i SET NO_PROXY=%DOCKER_HOST% set DOCKER_HOST=tcp://%DOCKER_HOST%:2376 cd Kitematic Kitematic.exe 参考 kitematic Proxy/VPN error reports #1031</description></item><item><title>试用了一下Kitematic</title><link>https://mryqu.github.io/post/%E8%AF%95%E7%94%A8%E4%BA%86%E4%B8%80%E4%B8%8Bkitematic/</link><pubDate>Fri, 28 Aug 2015 06:31:06 +0000</pubDate><guid>https://mryqu.github.io/post/%E8%AF%95%E7%94%A8%E4%BA%86%E4%B8%80%E4%B8%8Bkitematic/</guid><description>Kitematic是一个一个简单的 Docker容器管理GUI程序，它可以在Windows/Mac上更快速、更简单的运行Docker。Kitematic 完全自动化了 Docker安装和设置过程，并提供了一个直观的图形用户接口（GUI）来在Windows/Mac上运行 Docker。Kitematic集成了Docker Machine来在Windows/Mac上分发一个虚拟机并安装 Docker引擎。 在Kitematic上可以在DockerHub上查询Docker镜像、并用之创建容器。也可以对特定Docker容器进行环境变量、Volume和端口等配置。对记不住Docker命令的懒人是一个福利。
参考 Kitematic官网
Github：Kitematic
DOCKER ONLINE MEETUP: KITEMATIC IN ACTION</description></item><item><title>[Gradle] 列举插件</title><link>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 27 Jul 2015 06:17:30 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</guid><description>下列方法可以列举出当前build.gradle牵涉的插件:
project.plugins.each { println it }</description></item><item><title>整理贴：八卦一下CoreOS</title><link>https://mryqu.github.io/post/%E6%95%B4%E7%90%86%E8%B4%B4%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bcoreos/</link><pubDate>Fri, 17 Jul 2015 06:10:11 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%95%B4%E7%90%86%E8%B4%B4%E5%85%AB%E5%8D%A6%E4%B8%80%E4%B8%8Bcoreos/</guid><description>CoreOS是一个轻量级容器化Linux发行版，专为大型数据中心而设计，旨在通过轻量的系统架构和灵活的应用程序部署能力简化数据中心的维护成本和复杂度。
CoreOS的历史 2013年2月，美国的dotCloud公司发布了一款新型的Linux容器软件Docker，并建立了一个网站发布它的首个演示版本（见Docker第一篇官方博客）。而几乎同时，2013年3月，美国加州，年轻的帅小伙Alex Polvi正在自己的车库开始他的第二次创业。此前，他的首个创业公司Cloudkick卖给了云计算巨头Rackspcace（就是OpenStack的东家）。 有了第一桶金的Alex这次准备干一票大的，他计划开发一个足以颠覆传统的服务器系统的Linux发行版。为了提供能够从任意操作系统版本稳定无缝地升级到最新版系统的能力，Alex急需解决应用程序与操作系统之间的耦合问题。因此，当时还名不见经传的Docker容器引起了他的注意，凭着敏锐直觉，Alex预见了这个项目的价值，当仁不让地将Docker做为了这个系统支持的第一套应用程序隔离方案。不久以后，他们成立了以自己的系统发行版命名的组织：CoreOS。事实证明，采用Docker这个决定，后来很大程度上成就了CoreOS的生态系统。 CoreOS特点 首先，CoreOS没有提供包管理工具，而是通过容器化的运算环境向应用程序提供运算资源。应用程序之间共享系统内核和资源，但是彼此之间又互不可见。这样就意味着应用程序将不会再被直接安装到操作系统中，而是通过Docker 运行在容器中。这种方式使得操作系统、应用程序及运行环境之间的耦合度大大降低。相对于传统的部署方式而言，在 CoreOS集群中部署应用程序更加灵活便捷，应用程序运行环境之间的干扰更少，而且操作系统自身的维护也更加容易。 其次， CoreOS 采用双系统分区 (dual root partition)设计。两个分区分别被设置成主动模式和被动模式并在系统运行期间各司其职。主动分区负责系统运行，被动分区负责系统升级。一旦新版本的操作系统被发布，一个完整的系统文件将被下载至被动分区，并在系统下一次重启时从新版本分区启动，原来的被动分区将切换为主动分区，而之前的主动分区则被切换为被动分区，两个分区扮演的角色将相互对调。同时在系统运行期间系统分区被设置成只读状态，这样也确保了CoreOS 的安全性。CoreOS 的升级过程在默认条件下将自动完成，并且通过 cgroup对升级过程中使用到的网络和磁盘资源进行限制，将系统升级所带来的影响降至最低。 另外，CoreOS 使用 Systemd 取代 SysV 作为系统和服务的管理工具。与 SysV 相比，Systemd不但可以更好的追踪系统进程，而且也具备优秀的并行化处理能力，加之按需启动等特点，并结合 Docker 的快速启动能力，在 CoreOS集群中大规模部署 Docker容器与使用其他操作系统相比在性能上的优势将更加明显。Systemd 的另一个特点是引入了“target” 的概念，每个 target 应用于一个特定的服务，并且可以通过继承一个已有的 target扩展额外的功能，这样使得操作系统对系统上运行的服务拥有更好的控制力。 通过对系统结构的重新设计，CoreOS剔除了任何不必要的软件和服务。在一定程度上减轻了维护一个服务器集群的复杂度，帮助用户从繁琐的系统及软件维护工作中解脱出来。虽然CoreOS最初源自于Google ChromeOS，但是从一开始就决定了 CoreOS更加适合应用于一个集群环境而不是一个传统的服务器操作系统。 CoreOS相关工具 除了操作系统之外，CoreOS 团队和其他团队还提供了若干工具帮助用户管理 CoreOS 集群以及部署Docker容器。
etcd 在CoreOS 集群中处于骨架地位的是 etcd。 etcd 是一个分布式 key/value存储服务，CoreOS 集群中的程序和服务可以通过 etcd 共享信息或做服务发现 。etcd 基于非常著名的 raft一致性算法：通过选举形式在服务器之中选举 Lead 来同步数据，并以此确保集群之内信息始终一致和可用。etcd 以默认的形式安装于每个CoreOS 系统之中。在默认的配置下，etcd使用系统中的两个端口：4001和7001，其中4001提供给外部应用程序以HTTP+Json的形式读写数据，而7001则用作在每个etcd 之间进行数据同步。用户更可以通过配置 CA Cert让 etcd 以 HTTPS的方式读写及同步数据，进一步确保数据信息的安全性。
fleet fleet 是一个通过Systemd对CoreOS 集群中进行控制和管理的工具。fleet 与 Systemd 之间通过 D-Bus API 进行交互，每个fleet agent 之间通过 etcd 服务来注册和同步数据。fleet提供的功能非常丰富，包括查看集群中服务器的状态、启动或终止 Docker容器、读取日志内容等。更为重要的是 fleet可以确保集群中的服务一直处于可用状态。当出现某个通过 fleet创建的服务在集群中不可用时，如由于某台主机因为硬件或网络故障从集群中脱离时，原本运行在这台服务器中的一系列服务将通过fleet被重新分配到其他可用服务器中。虽然当前 fleet 还处于非常早期的状态，但是其管理 CoreOS集群的能力是非常有效的，并且仍然有很大的扩展空间，目前已提供简单的 API 接口供用户集成。</description></item><item><title>Gradle Docker Plugin介绍</title><link>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 Jul 2015 05:57:33 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</guid><description>gradle-docker-plugin gradle-docker-plugin是由《Gradle实战》作者BenjaminMuschko实现的Gradle插件，用来管理Docker镜像和容器。gradle-docker-plugin实际上包括两个插件：
com.bmuschko.docker-remote-api:提供通过远程API与Docker进行交互的定制任务 com.bmuschko.docker-java-application:为Java应用创建和上传Docker镜像 build.gradle buildscript { repositories { jcenter() } dependencies { classpath &amp;#39;com.bmuschko:gradle-docker-plugin:2.4.1&amp;#39; } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-java-application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-remote-api&amp;#39; 参考 GitHub：bmuschko/gradle-docker-plugin</description></item><item><title>Gradle Git Plugin介绍</title><link>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Sun, 12 Jul 2015 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</guid><description>Grgit和gradle-git Git是一个很流行的分布式版本管理工具。能在构建过程中与Git进行交互，可以提供更强大和更一致的结果。
JGit提供了与Git仓库交互的强大JavaAPI。然而，在Groovy上下本使用它会笨重，需要在所要执行的表达式包一堆换七八糟的东东。Grgit是Andre wOberstar实现的JGit封装器，为基于Groovy的工具与Git仓库交互提供了更简洁流畅的API。 gradle-git同样是由Andrew Oberstar实现的一系列Gradle插件：
org.ajoberstar.grgit - 提供一个Grgit实例，允许与Gradle项目所在的Git仓库交互 org.ajoberstar.github-pages - 向Github仓库的gh-pages分支发布文件 org.ajoberstar.release-base -提供用于从项目状态和所在Git仓库推断当前项目版本和创建新版本的通用结构 org.ajoberstar.release-opinion -用于org.ajoberstar.release-base的默认选项，遵从语义版本控制（Semantic Versioning）下面是一个Gradle任务示例，用于从Git仓库克隆项目。 build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;org.ajoberstar:gradle-git:1.2.0&amp;#39; } } import org.ajoberstar.gradle.git.tasks.* task cloneGitRepo(type: GitClone) { def destination = file(&amp;#34;destination_folder&amp;#34;) uri = &amp;#34;your_git_repo_uri&amp;#34; destinationPath = destination bare = false enabled = !destination.exists() //to clone only once } 参考 GitHub：ajoberstar/gradle-git
GitHub：ajoberstar/grgit</description></item><item><title>apt-get在基于Ubuntu基础镜像Dockerfile中的常见用法</title><link>https://mryqu.github.io/post/apt-get%E5%9C%A8%E5%9F%BA%E4%BA%8Eubuntu%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8Fdockerfile%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</link><pubDate>Sun, 05 Jul 2015 21:32:25 +0000</pubDate><guid>https://mryqu.github.io/post/apt-get%E5%9C%A8%E5%9F%BA%E4%BA%8Eubuntu%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8Fdockerfile%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</guid><description>首先，在Ubuntu的Docker官方镜像中是没有缓存Apt的软件包列表的。因此在做其他任何基础软件的安装前，都需要至少先做一次apt-get update。 有时为了加快apt-get安装软件的速度，还需要修改Apt源的列表文件/etc/apt/sources.list。相应的操作用命令表示如下：
# 使用Ubuntu官方的Apt源，也可以根据实际需要修改为国内源的地址 echo &amp;#34;deb http://archive.ubuntu.com/ubuntu trusty main universe\n&amp;#34; &amp;gt; /etc/apt/sources.list echo &amp;#34;deb http://archive.ubuntu.com/ubuntu trusty-updates main universe\n&amp;#34; &amp;gt;&amp;gt; /etc/apt/sources.list 在容器构建时，为了避免使用apt-get install安装基础软件的过程中需要进行的交互操作，使用-y参数来避免安装非必须的文件，从而减小镜像的体积。
apt-get -y --no-install-recommends install 使用apt-get autoremove命令移除为了满足包依赖而安装的、但不再需要的包；使用apt-get clean命令清除所获得包文件的本地仓库。 DEBIAN_FRONTEND这个环境变量，告知操作系统应该从哪儿获得用户输入。如果设置为&amp;quot;noninteractive&amp;quot;，你就可以直接运行命令，而无需向用户请求输入（所有操作都是非交互式的）。这在运行apt-get命令的时候格外有用，因为它会不停的提示用户进行到了哪步并且需要不断确认。非交互模式会选择默认的选项并以最快的速度完成构建。请确保只在Dockerfile中调用的RUN命令中设置了该选项，而不是使用ENV命令进行全局的设置。因为ENV命令在整个容器运行过程中都会生效，所以当你通过BASH和容器进行交互时，如果进行了全局设置那就会出问题。
# 正确的做法 - 只为这个命令设置ENV变量 RUN DEBIAN_FRONTEND=noninteractive apt-get install -y python3 # 错误地做法 - 为接下来的任何命令都设置ENV变量，包括正在运行地容器 ENV DEBIAN_FRONTEND noninteractive RUN apt-get install -y python3 我的示例如下：
FROM ubuntu:trusty MAINTAINER mryqu RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;amp;&amp;amp; \ DEBIAN_FRONTEND=noninteractive apt-get clean 参考 Ubuntu manuals: apt-get man page</description></item><item><title>Docker的镜像存储在哪里和长什么样子</title><link>https://mryqu.github.io/post/docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%92%8C%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</link><pubDate>Sun, 05 Jul 2015 00:27:30 +0000</pubDate><guid>https://mryqu.github.io/post/docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E5%92%8C%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</guid><description>接触docker后，我就有个疑问：我们用docker pull镜像后，该镜像是存储在哪里的？是以一个特俗的二进制类型存储的么？后来阅读了Docker的镜像存储在哪里这篇博文，得以解惑，并进行了验证。 Docker的镜像存储在/var/lib/docker目录下，存储方式有点像Git那样有reference和实际的objects，并且是实际内容是diff那样的增量存放。 Docker的镜像存储在哪里 有个疑问就是我们用docker pull镜像后，该镜像是存储在哪里的？ 当你仅仅是使用docker启动一个实例的时候，是超级简单的，但是当你制作自己的Dockerfile时，可能会有一些迷惑，那就是我的docker镜像存储在哪里了。这个听起来让我感觉有点一筹莫展，对于dockerimage的存储我还是一无所知。最后你只能把镜像发布到公共DockerIndex上面，但是，在过去一段时间内你是无法删除它的，但是现在你可以通过官方的WEB界面来删除它了。
Image VS Dockerfile 这个看起来有点混淆，但是它们是有差别的，docke使用images运行你的代码，而不是Dockerfile。Dockerfile是你用dockerbuild命令来构建image的。如果你在浏览器中浏览DockerIndex，你会发现有很多images显示在上面，但是你不能看见构建它们的Dockerfile。当你使用dockerpush命令发布image时，它不会发布你的源代码，它只会发布从你源代码构建出来的镜像。
Registry VS Index 下一个混淆的是Registry和Index，它们是怎么样区分的？index是管理公共web接口上的accounts、permission、search、tagging和所有精细的方面的。而registry是存储和提供实际image的，它委托index进行身份验证。当你运行dockersearch命令的时候，它搜索的是index，而不是registry。实际上，它可能搜索的是index知道的多个registry。当你运行dockerpush或者dockerpull命令时，index决定你是否有权限访问和修改images，当index同意你操作后，registry是提供images存储的地方，index会计算出哪个registry有你需要的镜像，并把请求转发过去。当你在本地运行dockerimages命令时，你可能是同时和index和registry进行交互。
Repository docker&amp;rsquo;s使用镜像就像使用GitHub一样容易，但是有三个混淆的地方：
repository和registry之间的区别 repository和image之间的区别 repository和index username之间的区别 其实repository并不是其中任何一个组件，而是指所有的组件。当你运行dockerimages命令时，你会看到如下： images列表看起来像repositories列表？实际上images是GUIDs，但这并不是如何和他们交互。当你执行dockerbuild或者dockercommit命令时，你可以指定image的名称，这个名称的格式是username/image_name，但这并不一定，它可以是任何形式的，他甚至可以是你已经知道的发布的镜像名称。当你执行dockerpush的时候，index会查看镜像名称，检查该镜像是否在repository中，如果在，接着检查你是否有权限访问该repository，如果有权限，则允许你push新版本的image到该repository上。因此，一个registry保留了它收集到的repository的名称，它本身跟踪收集到的images的GUIDs。thisis also where tags comein，你可以tag一个image，并且存储多个版本使用不同的GUIDs在同一个repository中，访问不同的标记的版本image，可以使用username/image_name:tag。 从上图中你可以看到我们有三个不同版本的image叫ubuntu12，每个的tag都是不同的，repository使用ubuntu12的名称来保存这些，因此，当我们看到ubuntu12的时候，它像一个image名称，但是实际上它使repository名称，repository名称有特殊的设计架构，index可以从第一部分解析出username，并且找出他在哪里。因此，当出现一个guol/ubuntu时会产生混淆，官方的repository名称是类似username/image_name这样的，我们想当然的认为repository名称是image_name，但是根据docker的文档发现repository的名称有时指的是全部的名称，有时指的是image_name。比如就像ubuntu，它就没有username，是不是有点乱了&amp;hellip;&amp;hellip;&amp;hellip;
Local Storage on the Docker Host 我们已经了解完如何和远程存储进行交互了，但是当你运行dockerimages的时候，仅仅给你看到的是你的机器上有哪些image。这些镜像在哪里呢？第一个要查看的地方是/var/lib/docker/。 查看repositories-aufs文件的内容，它的内容是在你本机上的repositories。 看看，它完全匹配了docker images的输出内容。 现在我们来看看/var/lib/docker/graph/的内容。 我倒，显示的非常不友好啊，看看docker是怎样跟踪这些镜像的，是基于repositories-aufs文件，构建了一个映射到repository名称和tag的关系表。我们看看ubuntu12的仓库，它有三个镜像，标记分别是12.04、precise、latest。采用的是IDd431f556799d35dfae1278a1ee41a393db70058dedb9a7fc554b0506b5b241cb，我们看看这个目录里面有什么。 只有两个文件：
json：保存image的metadata layersize：只是一个数字，表明layer的大小 主要镜像的差异在/var/lib/docker/aufs/diff/目录下，每次都会把镜像改变的部分存储在该目录下的相关ID目录里面。 参考：Where are Docker images stored?</description></item><item><title>了解Registrator</title><link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3registrator/</link><pubDate>Thu, 18 Jun 2015 05:50:21 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3registrator/</guid><description>支持 DNS和基于HTTP发现机制的服务发现工具Consul让我们印象深刻。它提供了定制化的注册服务健康检查并标记不健康实例的功能远胜于其他类似的工具。更多时兴的工具与Consul的集成使其功能更加强大。在使用Docker的场景里，有了Registrator的帮助，只需要很小的工作量就可以自动化地向Consul注册Docker容器，使得管理基于容器技术的配置更加容易。 Registrator通过检查Docker容器是否上线，自动为Docker容器注册/注销服务。Registrator支持可插拔服务注册中心，当前包括Consul、etcd和SkyDNS 2。
用法 运行Consul容器 $ docker run -d --name=consul --net=host consul-server -bootstrap 运行Registrator容器 Registrator被设计为在每个主机运行一次。也可以在每个集群仅运行一个Registrator，但是通过确保Registrator运行在每个主机上可以获得更好的伸缩性和更简化的配置。假定使用某种程度的自动化，在所有地方都运行反而讽刺性地比某个地方运行更简单。 $ docker run -d \ --name=registrator \ --net=host \ --volume=/var/run/docker.sock:/tmp/docker.sock \ gliderlabs/registrator:latest \ consul://localhost:8500 &amp;ndash;volume=/var/run/docker.sock:/tmp/docker.sock可以让Registrator访问DockerAPI； &amp;ndash;net=host有助于Registrator获得主机级IP和主机名； consul://localhost:8500是服务注册中心URI。 运行其他服务的容器 $ docker run -d -P --name=redis redis Registrator通过Docker API可以监听Docker容器的启动/关闭，并自动注册/注销服务: $ curl $(boot2docker ip):8500/v1/catalog/services {&amp;#34;consul&amp;#34;:[],&amp;#34;redis&amp;#34;:[]} $ curl $(boot2docker ip):8500/v1/catalog/service/redis [{&amp;#34;Node&amp;#34;:&amp;#34;boot2docker&amp;#34;,&amp;#34;Address&amp;#34;:&amp;#34;10.0.2.15&amp;#34;,&amp;#34;ServiceID&amp;#34;:&amp;#34;boot2docker:redis:6379&amp;#34;,&amp;#34;ServiceName&amp;#34;:&amp;#34;redis&amp;#34;,&amp;#34;ServiceTags&amp;#34;:null,&amp;#34;ServiceAddress&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;ServicePort&amp;#34;:32768}] 参考 Github：gliderlabs/registrator
Registrator Quickstart
Docker Hub：gliderlabs/registrator
Scalable Architecture DR CoN: Docker, Registrator, Consul, Consul Template and Nginx</description></item><item><title>了解Consul template</title><link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3consul_template/</link><pubDate>Wed, 17 Jun 2015 06:22:19 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3consul_template/</guid><description>支持 DNS 和基于HTTP发现机制的服务发现工具Consul让我们印象深刻。它提供了定制化的注册服务健康检查并标记不健康实例的功能远胜于其他类似的工具。更多时兴的工具与Consul的集成使其功能更加强大。ConsulTemplate守护进程提供了一个便捷方式直接使用Consul的信息来填充配置文件。 consul-template 查询一个Consul实例并对文件系统任意数量模板进行更新。此外，consul-template 在更新过程结束后可选地执行任意多个命令。 consul-template 项目提供了一些例子，通过Consul信息生成负载均衡器HAProxy、缓存引擎Varnish和web服务器Apachehttpd的配置文件。
参考 Github：hashicorp/consul-template Scalable Architecture DR CoN: Docker, Registrator, Consul, Consul Template and Nginx</description></item><item><title>使用Consul的十二要素应用（Twelve-Factor App）</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</link><pubDate>Tue, 16 Jun 2015 05:36:28 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</guid><description>十二要素应用（The Twelve-Factor App）主张web应用应该从环境变量里获取其配置。这一实践很快被现代PaaS服务采用以用于允许简单的配置变更。 使用Consul，很容易将这一实践用于你自己的数据中心。如果你基础架构的某些方面部分使用PaaS，Consul是配置数据中心化的一个很好的方式。 在这篇文章中，我们将展示Consul和envconsul如何在不修改应用程序的情况下被用于设置配置值和在配置变更时触发自动重启。
为什么使用环境变量? 根据十二要素应用，web应用配置应该使用环境变量。跟配置文件或Java系统属性这样的机制比，环境变量有很多优点：
环境变量是一个与开发语言和操作系统无关的标准。 环境变量更难被意外提交到代码库。 环境变量跟易于在development、staging、QA这样不同的环境之间改变。 无论如何部署，环境变量易于设置和更新。 例如Heroku这样的完整PaaS解决方案公开一些有用的API以用于为应用自动设置/读取环境变量。 当手动部署应用时，以往这样的事会更复杂一些。而使用Consul，程序员就可以很容易地设置和读取配置，运营工程师就可以很容易地提供支持和维护。
Consul键值对和Envconsul Consul能够存储键值对数据。对于设置和获取键值对数据，Consul拥有简单的API和美丽且直观的web界面。对于存储配置数据来说，它是完美的。 很容易看到如何设置和读取配置数据，但是对于配置数据如何变成应用的环境变量还不是很清楚。envconsul是一个解决该类问题的轻量级解决方案。 使用envconsul，环境变量存储在ConsulKV中并具有某些（以&amp;quot;/&amp;ldquo;分割的）前缀。例如，为了配置服务&amp;quot;foo&amp;rdquo;，我们可能存储如下配置：
$ curl -X PUT -d &amp;#39;false&amp;#39; http://localhost:8500/v1/kv/foo/enabled true 这会在键foo/enabled中存储值false。 之后，使用envconsul, 我们可以将这些键转换为环境变量：
$ envconsul foo env ENABLED=false envconsul是一个对UNIX非常友好的应用。他有两个必需的参数：一个用于查找数据的KV前缀和一个应用及其可选参数。在上例中，我们告诉envconsul配置位于前缀foo下，且我们想运行应用env，该应用仅仅是输出环境变量。 在示例结果中，我们可以清楚地看到ENABLED如我们在ConsulKV中所设置的false。
如果将env改成你自己的应用，那么环境变量将暴露给你的应用。例如，为了运行一个Rails服务器你可能做如下操作。注意在真实生产场景中，你可能不直接运行Rails内建服务器，但是它不失为一个好案例：
$ envconsul foo bin/rails server ... 自动重载 使用PaaS，当你修改任何配置时你的应用将自动重启。我们可以以最小的代价通过Consul和Envconsul实现相同效果。 通过对envconsul添加-reload标志，一旦配置键发生增删改，envconsul将中断(SIGTERM)并重启你的应用：
$ envconsul -reload foo bin/rails server ... 注：该功能已经在0.4.0版本移除。 Consul HTTP API支持对给定前缀KV中的变更进行长轮询。一旦KV中发生变更，Envconsul通过这种方式可以高效地进行检测。
改良流程 对应用配置使用Consul和envconsul可以将PaaS化应用配置易用性带入你自己的原生环境。 对于开发者而言，他们可以无需跟运营工程师沟通或重新部署应用就可以设置配置。 对于运营来说，Consul对整个基础架构的服务发现和配置提供了统一的解决方案。Consul自动复制数据并存储在磁盘上以方便备份，运营工程师也可以高枕无忧了。
我的实践 Envconsul获取的环境变量既可以直接给启动服务器的命令使用（例如上面启动Rails内建服务器的bin/rails命令）；也可以通过python之类的脚本存成Java系统属性文件，通过chpst这样可以加载环境变量/系统属性文件的命令间接给Java命令使用。
envconsul \ -once \ -log-level info \ -consul localhost:8500 \ -upcase=false \ -prefix config/foo/jvm \ foo env /usr/local/tomcat/bin/catalina.</description></item><item><title>Vagrant运行Docker的几种方法</title><link>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 15 Jun 2015 06:15:31 +0000</pubDate><guid>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>Vagrant的docker provisioner能够自动安装Docker、下载Docker容器、随着vagrant up命令自动运行容器。 Vagrantfile Vagrant.configure(&amp;#34;2&amp;#34;) do |config| config.vm.provision &amp;#34;docker&amp;#34; do |d| d.pull_images &amp;#34;consul&amp;#34; d.run &amp;#34;consul&amp;#34; d.pull_images &amp;#34;rabbitmq&amp;#34; d.run &amp;#34;rabbitmq&amp;#34; end end 仅使用Vagrant的docker provisioner安装Docker，使用脚本下载并运行Docker容器 Vagrantfile # Install Docker config.vm.provision &amp;#34;docker&amp;#34; # Download Docker images, create and start containers config.vm.provision :shell, :path =&amp;gt; &amp;#34;runMyDockers.sh&amp;#34; runMyDockers.sh #!/bin/bash docker rm -f consul 2&amp;gt;/dev/null docker create --hostname consul --name consul -v /data/consul1:/data --dns 127.0.0.1 --restart always -p 8500:8500 --env CONSUL_OPTIONS=-bootstrap consul:dev docker start consul docker rm -f rabbitmq 2&amp;gt;/dev/null docker create --name rabbitmq --hostname rabbitmq -p 5672:5672 -v /data/rabbitmq:/data --dns 127.</description></item><item><title>cAdvisor实践</title><link>https://mryqu.github.io/post/cadvisor%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 11 Jun 2015 00:40:08 +0000</pubDate><guid>https://mryqu.github.io/post/cadvisor%E5%AE%9E%E8%B7%B5/</guid><description>cAdvisor (Container Advisor)为运行容器的用户提供出色的资源使用和性能特征。这是一个运行守护进程，能够搜集、集料、处理和导出运行中的容器的信息。特别需要指出，每个容器都有资源隔离参数、历史资源使用、以及完整历史数据的柱状图。 cAdvisor目前支持Docker容器和lmctfy容器。
运行cAdvisor容器 配置boot2docker与宿主机之间的端口转移 查看cAdvisor 参考 GitHub：cAdvisor</description></item><item><title>DockerUI实践</title><link>https://mryqu.github.io/post/dockerui%E5%AE%9E%E8%B7%B5/</link><pubDate>Wed, 10 Jun 2015 06:08:47 +0000</pubDate><guid>https://mryqu.github.io/post/dockerui%E5%AE%9E%E8%B7%B5/</guid><description>DockerUI是Docker远程API的Web接口,它是由下列技术栈构成的纯客户端，因此很容易连接和管理Docker。
Angular.js Bootstrap Gritter Spin.js Golang Vis.js 运行DockerUI容器 配置boot2docker与宿主机之间的端口转移 另一种方式是在启动容器之前执行：
boot2docker ssh -L 9000:localhost:9000 查看DockerUI 直接使用Docker远程API 参考 GitHub：crosbymichael/dockerui
Docker Remote API</description></item><item><title>Docker Compose笔记</title><link>https://mryqu.github.io/post/docker_compose%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 06 Jun 2015 05:33:22 +0000</pubDate><guid>https://mryqu.github.io/post/docker_compose%E7%AC%94%E8%AE%B0/</guid><description>Docker Compose概述 **DockerCompose**
**前身 Fig**
Compose是用于在Docker内定义和运行多容器应用程序的工具。使用Compose，可以在一个文件内定义多容器应用程序，然后使用一个命令运行应用。 Compose对开发环境、交付准备服务器（stagingservers）和持续集成（CI）很有帮助，不建议用于生产环境。 使用Compose基本上是三步流程： - 通过一个`Dockerfile`定义应用环境，以便在其他地方复制； - 在`docker-compose.yml`中定义组成应用的服务，因此他们可以在一个隔离的环境一起运行； - 最后，运行`docker-compose up`，Compose将启动并运行整个应用。 docker-compose.yml大概是这个样子的:
web: build: . ports: - &amp;#34;5000:5000&amp;#34; volumes: - .:/code links: - redis redis: image: redis Compose包含管理应用整个生命周期的命令:
启动、停止和重建服务 查看运行的服务状态 对运行的服务的日志输出生成数据流 对一个服务运行一次性命令 Docker Compose安装 curl -L https://github.com/docker/compose/releases/download/VERSION_NUM/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose Docker Compose命令 更新整个应用 mryqu$ docker-compose stop # stop the containers mryqu$ docker-compose pull # download updated images mryqu# docker-compose up -d # creates new containers and starts them 更新单个服务 mryqu$ docker-compose stop foo # stop the foo service mryqu$ docker-compose pull foo # download foo service mryqu$ docker-compose up -d foo # start the new foo service 参考 Overview of Docker Compose</description></item><item><title>使用Docker的现代十二要素应用</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</link><pubDate>Thu, 04 Jun 2015 05:26:36 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</guid><description>【编者的话】“十二要素应用”为开发SaaS应用提供了方法上的指导，而Docker能够提供打包依赖，解耦后端服务等特性，使得两者非常吻合。这篇文章介绍了Docker特性怎样满足了开发“十二要素应用”的对应要点。Docker非常适合开发“十二要素应用”。
“十二要素应用”为构建SaaS应用提供了方法论，是由知名PaaS云计算平台Heroku的创始人AdamWiggins提出的。请参考这篇[文章](http://www.infoq.com/cn/news/2012/09/12-factor-app)。 Dockerfile与docker-compose.yml正在成为用代码定义服务的标准，通过它们可以定义服务的所有内容：依赖、环境、端口、各种进程以及后端服务。Docker镜像和容器为操作系统提供了保证，使得开发环境和生产环境可以有效地保持一致。这篇文章简单地介绍了Docker是怎样满足“十二要素应用”的核心要点的。它解释了用Docker开发一个典型的“Rails/Postgres/Redis/web/worker”所应用的技术。后续文章将通过代码深入介绍如何应用这些技术。
II. 依赖—显示地声明和隔离依赖关系 Docker镜像基于显示的Dockerfile构建，而Docker容器作为独立的运行环境。Dockerfile提供了显示声明基础操作系统的方法（FROM）,而且通过运行命令来安装附加的系统包以及应用的依赖包（RUN）。通过这些方法，你可以声明你需要ubuntu 14.04、Ruby 2.2.2、Node 0.11，然后一次性安装。
III. 配置—在环境中储存配置 Docker容器非常依赖Linux的环境变量进行配置。docker-compose.yml有一个环境变量的哈希表，你可以通过它显示的定义容器的环境变量。这些默认的或者未定义的值将在运行时从主机中继承。另外，还有Dokckerfile的ENV命令以及『docker run –env=[]』和『docker run–env-file=[]』运行选项可以设置环境变量。通过这些方法，你可以声明你的应用需要环境变量GITHUB_AUTH_TOKEN。 VII. 端口绑定—通过端口绑定来提供服务 Docker非常依赖端口绑定。docker-compose.yml有一个端口阵列，可以通过它显示的定义“主机:容器”的端口绑定。『docker run –pHOST:CONTAINER』让你可以在运行时定义端口绑定。通过这些方法，你可以声明你的应用的网络服务器将监听端口5000，而且你可以通过主机的端口5000获取服务。
IV. 后端服务—把后端服务当作附加资源 Docker容器与其它容器几乎完全隔离，所以需要通过网络与后端服务进行通信。docker-compse.yml有一个链接哈希表，你可以通过它指定你的应用所需要依赖的其他容器服务。‘docker-composeup’命令将首先开启这些后端服务，然后配置应用容器中网络连接信息的环境变量。通过这些方法，你可以声明你的应用需要Postgres 9.4和Redis3.0服务，让你的应用通过主机名和端口号与他们建立连接。
VI. 进程—以一个或者多个无状态进程运行应用 默认情况下，Docker容器是不带储存的进程。docker-compose.yml定义了一系列服务，每一个服务都有自己的镜像或者构建文件(Dockerfile)以及命令。通过这些方法，你可以声明你的应用同时有一个网络进程和工作进程。
XII. 管理进程—后台管理任务当做一次性进程运行 Docker镜像可以很容易地运行一次性进程。‘docker run myapp CMD’可以在与你的网络进程一致的环境中运行任意命令。通过这些方法，你可以基于你的Postgres数据库运行交互式的bash或者运行一次性的’rakedb:migrate’进程。
现有技术 若没有Docker，OS X的开发工具链是这样的：Homebrew作为系统依赖包， Postgres和Redis作为开发服务,Ruby的Bundler作为跨平台开发依赖，一系列的Shell脚本和foreman让所有工具在本地同时运行起来，以及一个独立的基于Linux的构建服务负责将应用打包到生产环境。这样的工作流并没有错误，但是Docker提供一个更简洁的方式。有了Dockerfile和docker-compose.yml文件，我们将不再需要任何OSX系统依赖，服务包或者跨平台的语言依赖。一个简单的“dicker-composeup”命令可以提供一个完整的Linux开发环境，并且能够轻易地将“十二要素应用”移植到生产机器。
原英文链接：Modern Twelve-Factor Apps With Docker
原译文链接：现代“十二要素应用”与Docker</description></item><item><title>读八种Docker开发模式</title><link>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 03 Jun 2015 06:22:55 +0000</pubDate><guid>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</guid><description>Eight Docker Development Patterns（原文）
八种Docker开发模式（译文）
八种Docker开发模式（介绍）
目前，我对可重用的基础容器和支持共享文件夹的开发容器这两种模式接触的多一些。</description></item><item><title>找不到TTY而导致的Vagrant destroy失败</title><link>https://mryqu.github.io/post/%E6%89%BE%E4%B8%8D%E5%88%B0tty%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_destroy%E5%A4%B1%E8%B4%A5/</link><pubDate>Wed, 06 May 2015 05:50:21 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%89%BE%E4%B8%8D%E5%88%B0tty%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_destroy%E5%A4%B1%E8%B4%A5/</guid><description>在Windows的Git Bash上想要够过vagrant destroy命令删除一个Vagrant虚拟机，结果碰到了这个错误：
Vagrant is attempting to interface with the UI in a way that requires a TTY. Most actions in Vagrant that require a TTY have configuration switches to disable this requirement. Please do that or run Vagrant with TTY. 据说Windows上的Cygwin以一种奇怪的方式处理stdin导致Ruby以为没有TTY，没想到Git Bash所基于的MinGW也有这样的问题。 权变措施是使用vagrant destroy --force。</description></item><item><title>遭遇由VT-x设置导致的vagrant up失败</title><link>https://mryqu.github.io/post/%E9%81%AD%E9%81%87%E7%94%B1vt-x%E8%AE%BE%E7%BD%AE%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_up%E5%A4%B1%E8%B4%A5/</link><pubDate>Tue, 05 May 2015 06:06:28 +0000</pubDate><guid>https://mryqu.github.io/post/%E9%81%AD%E9%81%87%E7%94%B1vt-x%E8%AE%BE%E7%BD%AE%E5%AF%BC%E8%87%B4%E7%9A%84vagrant_up%E5%A4%B1%E8%B4%A5/</guid><description>我在同事申请的一台机器上安装Vagrant box，结果vagrant up失败，报如下错误：
The guest machine entered an invalid state while waiting for it to boot. Valid states are 'starting, running'. The machine is in the 'poweroff' state. Please verify everything is configured properly and try again. If the provider you're using has a GUI that comes with it, it is often helpful to open that and watch the machine, since the GUI often has more helpful error messages than Vagrant can retrieve.</description></item></channel></rss>
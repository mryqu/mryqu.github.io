<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c on Mryqu's Notes</title><link>https://mryqu.github.io/tags/c/</link><description>Recent content in c on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 22 Jan 2015 20:59:59 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>[C] 了解printf中的%.s</title><link>https://mryqu.github.io/post/c_%E4%BA%86%E8%A7%A3printf/</link><pubDate>Thu, 22 Jan 2015 20:59:59 +0000</pubDate><guid>https://mryqu.github.io/post/c_%E4%BA%86%E8%A7%A3printf/</guid><description>偶尔看到C代码printf(&amp;quot;%.*s&amp;quot;,dataL,data);，对printf中的格式化字符串&amp;quot;%.*s&amp;quot;有点不解。
查看了http://www.cplusplus.com/reference/cstdio/printf/文档后，有所理解。
| width |description |&amp;mdash;&amp;ndash; | (number) |Minimum number of characters to be printed. If the value tobe printed is shorter than this number, the result is padded withblank spaces. The value is not truncated even if the result islarger. | * |The width is not specified in the format string, but as an additional integer value argument preceding theargument that has to be formatted.
| .precision |description |&amp;mdash;&amp;ndash; | .</description></item><item><title>[C++] 重温析构函数</title><link>https://mryqu.github.io/post/c++_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link><pubDate>Fri, 25 Oct 2013 21:11:16 +0000</pubDate><guid>https://mryqu.github.io/post/c++_%E9%87%8D%E6%B8%A9%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid><description>创建一个C++对象时，一般先调用父类构造函数，再调用自己的构造函数；而在销毁一个C++对象时，一般先调用自己的析构函数，再调用父类的析构函数。我用如下testDestructor.cpp进行测试。
class BaseClass { public: BaseClass() { cout &amp;lt;&amp;lt; &amp;#34;BaseClass() on &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~BaseClass() { cout &amp;lt;&amp;lt; &amp;#34;~BaseClass() on &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } }; class DerivedClass : public BaseClass { public: DerivedClass():name(new string(&amp;#34;NULL&amp;#34;)) { cout &amp;lt;&amp;lt; &amp;#34;DerivedClass() on &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } DerivedClass(const string&amp;amp; n):name(new string(n)) { cout &amp;lt;&amp;lt; &amp;#34;DerivedClass(string) on &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } ~DerivedClass() { delete name; cout &amp;lt;&amp;lt; &amp;#34;~DerivedClass(): name has been deleted on &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } private: string* name; }; int main() { cout &amp;lt;&amp;lt; &amp;#34;=== test bo1 ===&amp;#34; &amp;lt;&amp;lt; endl; BaseClass* bo1 = new BaseClass(); delete bo1; cout &amp;lt;&amp;lt; &amp;#34;=== test do1 ===&amp;#34; &amp;lt;&amp;lt; endl; DerivedClass* do1 = new DerivedClass(); delete do1; cout &amp;lt;&amp;lt; &amp;#34;=== test bo2 ===&amp;#34; &amp;lt;&amp;lt; endl; BaseClass* bo2 = new DerivedClass(&amp;#34;123&amp;#34;); delete bo2; cout &amp;lt;&amp;lt; &amp;#34;=== test bo3 ===&amp;#34; &amp;lt;&amp;lt; endl; BaseClass bo3 = DerivedClass(&amp;#34;321&amp;#34;); return 0; } 输出结果如下：</description></item><item><title>[C] Exec format error</title><link>https://mryqu.github.io/post/c_exec_format_error/</link><pubDate>Sun, 20 Oct 2013 17:28:57 +0000</pubDate><guid>https://mryqu.github.io/post/c_exec_format_error/</guid><description>很久没用g++了，结果编个小程序还出错。
mryqu:~/ctest$ g++ -g -c wvc.cpp -o wvc mryqu:~/ctest$ chmod a+x wvc mryqu:~/ctest$ ./wvc -bash: ./wvc: cannot execute binary file: Exec format error mryqu:~/ctest$ file wvc wvc: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 查了查gcc的帮助，才发现用了-c选项后其实是只编译不链接的：
-c Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</description></item><item><title>[C] #和##宏操作符</title><link>https://mryqu.github.io/post/c_%E5%AE%8F%E6%93%8D%E4%BD%9C%E7%AC%A6/</link><pubDate>Sun, 20 Oct 2013 10:45:24 +0000</pubDate><guid>https://mryqu.github.io/post/c_%E5%AE%8F%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid><description>在看# and ## in macros之前觉得对#和##宏操作符挺明白的，看了之后才感觉需要重新学习一下。
#define f(a,b) a##b #define g(a) #a #define h(a) g(a) int main() { printf(&amp;#34;%s\n&amp;#34;,h(f(1,2))); printf(&amp;#34;%s\n&amp;#34;,g(f(1,2))); return 0; } 如果你能确保自己能写出正确答案的话，那么你可以略过这篇帖子。 C/C++语言中对宏的处理属于编译器预处理的范畴，属于编译期概念而非运行期概念。其中#操作符用于对指定的宏参数进行字符串化，而##操作符用来将两个符号连接为一个符号。
struct command { char *name; void (*function) (void); }; ``` #define COMMAND(NAME) \ { #NAME, NAME ## _command } struct command commands[] = { COMMAND (quit), COMMAND (help), … };
&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;等同&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; struct command commands[] = { { &amp;ldquo;quit&amp;rdquo;, quit_command }, { &amp;ldquo;help&amp;rdquo;, help_command }, … };</description></item></channel></rss>
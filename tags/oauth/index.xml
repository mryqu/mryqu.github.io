<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>oauth on Mryqu's Notes</title><link>https://mryqu.github.io/tags/oauth/</link><description>Recent content in oauth on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 18 May 2017 05:43:22 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/oauth/index.xml" rel="self" type="application/rss+xml"/><item><title>ArcGIS认证和登录</title><link>https://mryqu.github.io/post/arcgis%E8%AE%A4%E8%AF%81%E5%92%8C%E7%99%BB%E5%BD%95/</link><pubDate>Thu, 18 May 2017 05:43:22 +0000</pubDate><guid>https://mryqu.github.io/post/arcgis%E8%AE%A4%E8%AF%81%E5%92%8C%E7%99%BB%E5%BD%95/</guid><description>申请ArcGIS Online账户 创建应用 点击创建第一个应用： 输入应用所需信息： 查看应用信息： 设置redirect URI： 获取应用访问令牌 默认情况下，访问令牌2小时过期。可在获取访问令牌的请求中加入expiration参数，指定以分钟为单位的过期间隔（响应中单位为秒），最大为14天。 应用登录具有几个内建限制：
通过应用获取的访问令牌仅能读取公开内容和服务。 通过应用获取的访问令牌有可能读取Esri托管的高级内容和服务，并消费代表应用所有者的点数。 应用无法创建、更新、共享、修改和删除在ArcGIS Online或ArcGIS门户网站上的内容（层、文件、服务、地图）。 使用应用登录方式的应用无法列于ArcGIS软件商店。 获取用户访问令牌 用于用户登录的HTTP GET请求如下：
https://www.arcgis.com/sharing/rest/oauth2/authorize?client_id={YOUR_APP_CLIENT_ID}&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;response_type=code 请求用户授权： 返回地址包含code参数，内容中也有一含有code值的文本框： 获取访问令牌的HTTP GET请求包含上面获得的code参数：：
https://www.arcgis.com/sharing/rest/oauth2/token?client_id={YOUR_APP_CLIENT_ID}&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;grant_type=authorization_code&amp;amp;code={GOTTEN_CODE} 访问令牌使用 不同的ArcGIS REST API使用的访问令牌类型可能不同。例如在Accessing the GeoEnrichment service中提到使用GeoEnrichment服务需要用户访问令牌；而在 Authenticate a request to the World Geocoding Service中提到使用Geocoding服务需要应用访问令牌。 下面的示例使用用户访问令牌执行Geocoding服务的操作，结果返回403错误，提示Token is valid but access is denied，具体信息为User does not have permissions to access geocodeAddresses。 参考 ArcGIS: Implementing App Login
ArcGIS: Implementing Named User Login
ArcGIS: Mobile and Native Named User Login</description></item><item><title>在Google API中使用访问令牌的三种方式</title><link>https://mryqu.github.io/post/%E5%9C%A8google_api%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Thu, 29 Sep 2016 05:33:08 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%9C%A8google_api%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>在Google Developers OAuth 2.0 playground 中设置OAuth2.0配置时，可以发现有一个访问令牌位置的选择框，其值为：
Authorization header w/ OAuth prefix Authorization header w/ Bearer prefix Access_token URL parameter 按照前面博文《Google Sheets API认证和鉴权 》中的方法生成一个访问令牌。下面我就用这个访问令牌对这三种使用方式进行一下尝试。
认证头使用OAuth前缀 认证头使用Bearer前缀 使用access_token URL参数 结论：这三种访问令牌位置的使用都工作正常，API结果相同！</description></item><item><title>twitcurl获取访问令牌（AccessToken和AccessTokenSecret）的实现流程</title><link>https://mryqu.github.io/post/twitcurl%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8Caccesstoken%E5%92%8Caccesstokensecret%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 01 Jul 2016 05:34:09 +0000</pubDate><guid>https://mryqu.github.io/post/twitcurl%E8%8E%B7%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8Caccesstoken%E5%92%8Caccesstokensecret%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid><description>twitterClient.cpp中有一段代码是没有AccessToken和AccessTokenSecret的情况下，通过ConsumerKey、ConsumerKeySecret、UserName和UaserPassword获取AccessToken和AccessTokenSecret。 一般实现是通过重定向到Twitter页面去授权应用，通过callbackURL获得Twitter传过来的AccessToken和AccessTokenSecret信息。twitcurl既可以通过访问twitter.com获取PIN，也可以交由twitcurl自动获得。 如果通过twitter.com处理PIN，twitcurl会提供授权链接。进入链接后输入用户名和密码，会重定向到Twitter应用的callbackURL（例如http://www.mryqu.com/test.html?oauth_token={OAuthToken}&amp;amp;oauth_verifier={OAuthVerifier} ），其中oauth_verifier值即为所谓的PIN。 下面我们看一下twitcurl是如何实现不访问twitter.com获取AccessToken和AccessTokenSecret的。
GET https://api.twitter.com/oauth/request_tokentwitCurl::oAuthRequestToken 方法实现该HTTP请求，允许消费者应用获得一个OAuth请求令牌以请求用户授权。除了HTTP OAuth头外，twitcurl实现没有其他HTTP头，也没有消息体内容。HTTP OAuth头包含如下项： oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_version 通过如下HTTP响应可以获得oauth_token和oauth_token_secret，保存在oAuth对象的m_oAuthTokenKey和m_oAuthTokenSecret变量中：
oauth_token=XXXXXX&amp;amp;oauth_token_secret=XXXXXX&amp;amp;oauth_callback_confirmed=true GET https://api.twitter.com/oauth/authorize?oauth_token=XXXXXXtwitterObj.oAuthHandlePIN 方法实现该HTTP请求，获取响应页面中表单的authenticity_token和oauth_token元素的值。除了HTTP OAuth头外，twitcurl实现没有其他HTTP头，也没有消息体内容。HTTP OAuth头包含如下项： oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token （取自上一HTTP响应） oauth_version HTTP响应片段：
POST https://api.twitter.com/oauth/authorize?oauth_token=XXXXXXtwitterObj.oAuthHandlePIN 方法实现该HTTP请求，允许消费者应用使用OAuth请求令牌请求用户授权。HTTP OAuth头包含如下项： oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token （取自上一HTTP响应） oauth_version HTTP请求消息体内容为：
oauth_token=XXXXXX&amp;amp;authenticity_token=XXXXXX&amp;amp;session[username_or_email]=**XXXXX**X&amp;amp;session[password]=XXXXXX HTTP响应片段：通过如下HTTP响应可以获得oauth_verifier，保存在oAuth对象的m_oAuthPin变量中。
GET https://api.twitter.com/oauth/access_tokentwitterObj.oAuthAccessToken 方法实现该HTTP请求，允许消费者应用使用OAuth请求令牌交换OAuth访问令牌。HTTP OAuth头包含如下项： oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_verifier （取自上一HTTP响应） oauth_version HTTP响应：
oauth_token=XXXXXX&amp;amp;oauth_token_secret=XXXXXX&amp;amp;user_id=XXXXXX&amp;amp;screen_name=XXXXXX&amp;amp;x_auth_expires=0 通过HTTP响应可以获得oauth_token、oauth_token_secret和user_id，保存在oAuth对象的m_oAuthTokenKey、m_oAuthTokenSecret和m_oAuthScreenName变量中，可以将此OAuth访问令牌保存下来以备之后的使用，下次就无需再次申请访问令牌了。
参考 Twitter OAuth Overview Twitter PIN-based authorization Github: mryqu/twitcurl OAuth Core 1.</description></item><item><title>twitcurl生成HTTP OAuth头的实现流程</title><link>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 27 Dec 2015 06:12:09 +0000</pubDate><guid>https://mryqu.github.io/post/twitcurl%E7%94%9F%E6%88%90http_oauth%E5%A4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</guid><description>对twitcurl代码做了一些修改，结果遇到了认证失败的错误：
{“errors”:[{“message”:”Could not authenticate you”,”code”:32}]} 通过继续修改twitcurl代码改正问题，学习了twitcurl的认证授权部分代码。其授权部分主要在oauthlib.h和oauthlib.cpp中的oAuth类实现中。下面主要分析一下oAuth::getOAuthHeader方法。
外部数据 Http URL: https://api.twitter.com/1.1/search/tweets.json Http头参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |q|va |count|23 |result_type|recent
Http授权参数:
|参数键|参数值 |&amp;mdash;&amp;ndash; |oauth_consumer_key|xvz1evFS4wEEPTGEFPHBog |oauth_signature_method|HMAC-SHA1 |oauth_token|370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb |oauth_version|1.0
oAuth::getOAuthHeader方法 通过buildOAuthHttpParameterKeyValPairs(params, true,rawKeyValuePairs);对Http头参数中参数值进行百分号编码（URL编码），编码后结果放在哈希表rawKeyValuePairs中 rawKeyValuePairs: 假定HTTP内容是经过百分号编码的，通过buildOAuthRawDataKeyValPairs( rawData,false, rawKeyValuePairs );找到内容中的键值对，放入哈希表rawKeyValuePairs中 rawKeyValuePairs: 通过buildOAuthTokenKeyValuePairs( includeOAuthVerifierPin,std::string( &amp;quot;&amp;quot; ), rawKeyValuePairs, true );创建认授权证： rawKeyValuePairs: 通过getSignature( eType, pureUrl, rawKeyValuePairs,oauthSignature );获得签名 生成 sigBase： 使用consumer_secret和token_secret组成signing_key，使用HMAC_SHA1算法通过sigBase和signing_key生成摘要strDigest：B6 79 C0 AF 18 F4 E9 C5 87 AB 8E 20 0A CD 4E 48 A9 3F 8C B6(非真实计算而得数据) 通过base64_encode进行编码：tnnArxj06cWHq44gCs1OSKk/jLY= (非真实计算而得数据) 通过百分比编码获得最终签名： (非真实计算而得数据) 通过rawKeyValuePairs.</description></item><item><title>利用curl完成Google API、Facebook、DropBox、OneDrive等社交媒体的OAuth认证</title><link>https://mryqu.github.io/post/%E5%88%A9%E7%94%A8curl%E5%AE%8C%E6%88%90google_apifacebookdropboxonedrive%E7%AD%89%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93%E7%9A%84oauth%E8%AE%A4%E8%AF%81/</link><pubDate>Mon, 14 Sep 2015 06:22:41 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%88%A9%E7%94%A8curl%E5%AE%8C%E6%88%90google_apifacebookdropboxonedrive%E7%AD%89%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93%E7%9A%84oauth%E8%AE%A4%E8%AF%81/</guid><description>Twitter 没法用curl完成Twitter认证，可以尝试witter/twurl。
Facebook 通过curl命令获取访问密钥：
curl &amp;#34;https://graph.facebook.com/oauth/access_token?client_id={YOUR_APP_ID}&amp;amp;client_secret={YOUR_APP_SECRET}&amp;amp;grant_type=client_credentials&amp;#34; Google API 这里Google应用的客户端ID格式大概为XXX-YYY.apps.googleusercontent.com。
Google Analytics 首先通过浏览器访问下列链接获取code：
https://accounts.google.com/o/oauth2/v2/auth?scope=https://www.googleapis.com/auth/analytics.readonly%20profile&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;response_type=code&amp;amp;client_id={YOUR_APP_ID} 通过curl命令获取访问密钥：
curl -X POST -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; -H &amp;#34;Cache-Control: no-cache&amp;#34; -d &amp;#39;code={GOTTEN_CODE}&amp;amp;client_id={YOUR_APP_ID}&amp;amp;client_secret={YOUR_APP_SECRET}&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;grant_type=authorization_code&amp;#39; &amp;#34;https://www.googleapis.com/oauth2/v4/token&amp;#34; Youtube Analytics 首先通过浏览器访问下列链接获取code：
https://accounts.google.com/o/oauth2/v2/auth?scope=https://www.googleapis.com/auth/yt-analytics.readonly%20profile&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;response_type=code&amp;amp;client_id={YOUR_APP_ID} 通过curl命令获取访问密钥：
curl -X POST -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; -H &amp;#34;Cache-Control: no-cache&amp;#34; -d &amp;#39;code={GOTTEN_CODE}&amp;amp;client_id={YOUR_APP_ID}&amp;amp;client_secret={YOUR_APP_SECRET}&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;grant_type=authorization_code&amp;#39; &amp;#34;https://www.googleapis.com/oauth2/v4/token&amp;#34; Google drive &amp;amp; sheets 首先通过浏览器访问下列链接获取code：
https://accounts.google.com/o/oauth2/v2/auth?scope=https://www.googleapis.com/auth/spreadsheets%20https://www.googleapis.com/auth/drive%20profile&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;response_type=code&amp;amp;client_id={YOUR_APP_ID} 通过curl命令获取访问密钥：
curl -X POST -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; -H &amp;#34;Cache-Control: no-cache&amp;#34; -d &amp;#39;code={GOTTEN_CODE}&amp;amp;client_id={YOUR_APP_ID}&amp;amp;client_secret={YOUR_APP_SECRET}&amp;amp;redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;grant_type=authorization_code&amp;#39; &amp;#34;https://www.googleapis.com/oauth2/v4/token&amp;#34; DropBox 首先通过浏览器访问下列链接获取code：
https://api.dropbox.com/1/oauth2/authorize?client_id={YOUR_APP_ID}&amp;amp;response_type=code&amp;amp;state=kx123 通过curl命令获取访问密钥：
curl -X POST -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; -H &amp;#34;Cache-Control: no-cache&amp;#34; -d &amp;#39;code={GOTTEN_CODE}&amp;amp;client_id={YOUR_APP_ID}&amp;amp;client_secret={YOUR_APP_SECRET}&amp;amp;grant_type=authorization_code&amp;#39; &amp;#34;https://api.</description></item></channel></rss>
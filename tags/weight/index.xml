<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>weight on Mryqu's Notes</title><link>https://mryqu.github.io/tags/weight/</link><description>Recent content in weight on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 16 Jan 2016 07:02:17 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/weight/index.xml" rel="self" type="application/rss+xml"/><item><title>[算法] 汉明重量（Hamming Weight）</title><link>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8Fhamming_weight/</link><pubDate>Sat, 16 Jan 2016 07:02:17 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8Fhamming_weight/</guid><description>LeetCode题191是算整数中比特1的个数，即汉明重量或汉明权重。
汉明重量 汉明重量是一串符号中非零符号的个数。因此它等同于同样长度的全零符号串的汉明距离。在最为常见的数据位符号串中，它是1的个数。 汉明重量是以理查德·卫斯里·汉明的名字命名的，它在包括信息论、编码理论、密码学等多个领域都有应用。
算法 位移实现 我自己的实现就是这种。通过判别n是否为0作为循环退出条件，如果n为0x1的话就位移一次，可是n为0x80000000还是需要位移32次。
public int hammingWeight(int n) { int res = 0; while(n!=0) { res+= (n &amp;amp; 0x1); n &amp;gt;&amp;gt;&amp;gt;=1; } return res; } n &amp;amp; (n-1)实现 public int hammingWeight(int n) { int res = 0; for(;n!=0;n = n &amp;amp; (n-1)) { res++; } return res; } 减1操作将最右边的符号从0变到1，从1变到0，与操作将会移除最右端的1。如果最初n有X个1，那么经过X次这样的迭代运算，n将减到0。n&amp;amp; (n-1)实现在大多数比特为0的情况下是效率最高的。 此外n &amp;amp; (n-1)常用于判断数是否为2的幂数（LeetCode题231）：
----- binary ---- n n n-1 n&amp;amp;(n-1) -- ---- ---- ------- 0 0000 0111 0000 * 1 0001 0000 0000 * 2 0010 0001 0000 * 3 0011 0010 0010 4 0100 0011 0000 * 5 0101 0100 0100 6 0110 0101 0100 7 0111 0110 0110 8 1000 0111 0000 * 9 1001 1000 1000 10 1010 1001 1000 11 1011 1010 1010 12 1100 1011 1000 13 1101 1100 1100 14 1110 1101 1100 15 1111 1110 1110 JDK实现 java.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>graph on Mryqu's Notes</title><link>https://mryqu.github.io/tags/graph/</link><description>Recent content in graph on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 13 Apr 2017 05:53:26 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>Making Nested Requests using Facebook Graph API</title><link>https://mryqu.github.io/post/making_nested_requests_using_facebook_graph_api/</link><pubDate>Thu, 13 Apr 2017 05:53:26 +0000</pubDate><guid>https://mryqu.github.io/post/making_nested_requests_using_facebook_graph_api/</guid><description>今天又玩了一把Facebook Graph API。当我们抓取Page上的帖子后，之后会发起API请求获取帖子的评论及回复。
获取Page SASsoftware（ID为193453547355388）下的帖子 https://graph.facebook.com/193453547355388/feed?fields=id,XXXX,likes.limit(0).summary(1),comments,XXXX,with_tags&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;since=XXXX&amp;amp;until=XXXX&amp;amp;access_token={YOUR_TOKEN} 获取帖子193453547355388_951786161522119的评论 https://graph.facebook.com/193453547355388_951786161522119/comments?fields=id,from,message,created_time,like_count&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;access_token={YOUR_TOKEN} 获取评论951786161522119_951787458188656的回复 https://graph.facebook.com/951786161522119_951787458188656/comments?fields=id,from,message,created_time,like_count&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;access_token={YOUR_TOKEN} 试用嵌套请求 https://graph.facebook.com/193453547355388/feed?fields=id,XXXX,likes.limit(0).summary(1),comments{id,from,message,type,created_time,like_count,comments{id,from,message,type,created_time,like_count}},XXXX,with_tags&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;since=XXXX&amp;amp;until=XXXX&amp;amp;access_token={YOUR_TOKEN} 这里的请求使用了两级嵌套请求，第一级获取帖子的评论，第二季获取评论的回复，那结果如何？ 一个API请求就能够获得了帖子、评论及回复的信息。但是，考虑到一个帖子的评论或一个评论的回复都可能很多，返回结果是第一个分页结果，还是需要通过/{object-id}/comments API 请求获取，考虑到设计复杂性和性价比，决定放弃这种方案。</description></item><item><title>Facebook Graph API之分享数</title><link>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E5%88%86%E4%BA%AB%E6%95%B0/</link><pubDate>Fri, 13 May 2016 05:56:49 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E5%88%86%E4%BA%AB%E6%95%B0/</guid><description>现在Facebook帖子上有一个分享计数，下面这个湖南卫视的帖子可以看到总共有3个。 点进去可以查看这3个分享的具体情况： 使用Facebook Graph Explorer却可以得到分享数为7： 差4个分享，有点醉！ 其实我刚才刚刚用消息给朋友共享了这个帖子，由于是不是公开的，所以Facebook网页显示上是不计入的，但是API却是统计的。</description></item><item><title>Facebook Graph API之点赞数</title><link>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E7%82%B9%E8%B5%9E%E6%95%B0/</link><pubDate>Thu, 12 May 2016 06:24:44 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E7%82%B9%E8%B5%9E%E6%95%B0/</guid><description>现在Facebook帖子上有一个心情计数，下面这个湖南卫视的帖子可以看到总共有293个。 通过Facebook Graph API获得的点赞数为275个。 示例里的帖子心情计数293包括点赞数275、大爱数13、笑趴数4、【未知表情计数】1。 这里可以看到点赞可以细分为点赞、大爱、笑趴、哇、心碎和怒这六种表情。</description></item><item><title>Facebook Graph API之主页名</title><link>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E4%B8%BB%E9%A1%B5%E5%90%8D/</link><pubDate>Mon, 09 May 2016 06:32:07 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E4%B8%BB%E9%A1%B5%E5%90%8D/</guid><description>今天Alisa同学说搜中国湖南卫视的主页报错，我一直都只是用SASsoftware和我的YquTest做的开发测试。赶紧赶过去看了一眼，实验证明搜hntvchina好使，搜中国湖南卫视就会出错。 感觉中国湖南卫视就像是hntvchina的显示名，而SASsoftware的显示名其实是SAS software。 又和小伙伴一起创建了一个主页玩玩，让我们输入的名字最后成了显示名，而真正生成的名字将空格用&amp;quot;-&amp;ldquo;代替然后又加了一串数字，感觉像防止主键冲突。</description></item><item><title>Get comments count using Facebook Graph API</title><link>https://mryqu.github.io/post/get_comments_count_using_facebook_graph_api/</link><pubDate>Fri, 06 May 2016 05:50:38 +0000</pubDate><guid>https://mryqu.github.io/post/get_comments_count_using_facebook_graph_api/</guid><description>通过fields参数获取评论/回复个数 通过预判评论/回复个数，以决定是否发起/{object-id}/commentsAPI请求，可以显著减少API请求个数。
获取帖子的评论数 https://graph.facebook.com/{YOUR_PAGE_ID}/feed?fields=id,XXXX,likes.limit(0).summary(1),comments.limit(0).summary(1),XXXX,with_tags&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;since=XXXX&amp;amp;until=XXXX&amp;amp;include_hidden=true&amp;amp;access_token={YOUR_ACCESS_TOKEN} 获取评论的回复数 https://graph.facebook.com/{YOUR_POST_ID}/comments?fields=id,from,message,created_time,like_count,comments.limit(0).summary(1)&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;limit=100&amp;amp;since=XXXX&amp;amp;until=XXXX&amp;amp;include_hidden=true&amp;amp;access_token={YOUR_ACCESS_TOKEN} comments.summary.total_count解读 在Facebook Graph指南中/{object-id}/comments提到了total_count数值是随filter变动的。
filter为stream，total_count为该节点下所有评论及其回复的总数； filter为toplevel，total_count为该节点下顶层评论/回复的总数。 由于在我的使用场景中为设置filter，而其默认值为toplevel，则total_count为该节点下顶层评论/回复的总数。</description></item><item><title>Get likes count using fields parameters in Facebook Graph API</title><link>https://mryqu.github.io/post/get_likes_count_using_fields_parameters_in_facebook_graph_api/</link><pubDate>Thu, 05 May 2016 06:02:17 +0000</pubDate><guid>https://mryqu.github.io/post/get_likes_count_using_fields_parameters_in_facebook_graph_api/</guid><description>原来获得Facebook帖子/评论的点赞数，需要额外单独发送一次API请求： 通过对Facebook GraphAPI中fields参数添加likes.limit(0).summary(1)，仅需一次API请求就可获得帖子/评论的所有信息：</description></item><item><title>使用Facebook Graph API中的fields参数</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8facebook_graph_api%E4%B8%AD%E7%9A%84fields%E5%8F%82%E6%95%B0/</link><pubDate>Fri, 15 Jan 2016 05:50:04 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8facebook_graph_api%E4%B8%AD%E7%9A%84fields%E5%8F%82%E6%95%B0/</guid><description>使用Facebook Graph API进行查询，v2.3和v2.4版返回结果截然不同。使用v2.3之前的FacebookGraph API获得的响应信息很详细，而使用v2.4及之后的Facebook Graph API获得的响应基本没什么信息！ 这可是相同的AccessToken呀。卖萌的话，可以说句“吓死宝宝了”。
Using the Graph API提到可以使用fields参数选择所需字段，照着v2.3的加上了id、name、about、awards&amp;hellip;&amp;hellip; 失而复得，虚惊一场！！！
Using the Graph API里不仅提到了选择参数，还提到可以使用字段表达式进行嵌套查询。 likes字段使用limit(1)限定其仅返回一个点赞数据，反正我还要使用GraphAPI对帖子点赞数据进行请求，返回一个点赞知道需不需要请求就好了。
comments字段还制定了二级字段attachment、id和from。这样comments字段既不会漏了我需要的子字段，也不会多出来我不需要的字段。在上图GraphAPI Explorer中，左侧comments字段下面的”Search for afield“链接可以提示那些子字段可选，很方便。</description></item><item><title>Facebook Graph API之我的常用URL笔记</title><link>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8url%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 08 Jan 2016 06:20:20 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8B%E6%88%91%E7%9A%84%E5%B8%B8%E7%94%A8url%E7%AC%94%E8%AE%B0/</guid><description>获取Facebook主页Id https://graph.facebook.com/v2.5/SasSoftware?access_token={accessToken}&amp;amp;format=json 上面示例是通过主页名SasSoftware获取其主页Id。
获取Facebook主页帖子 https://graph.facebook.com/v2.5/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=2015-01-01&amp;amp;util=2015-12-31 https://graph.facebook.com/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 https://graph.facebook.com/v2.0/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 通过Facebook Graph API 2.5或不带版本的API仅能获取帖子的Id、创建时间和帖子内容，而FacebookGraph API 2.0则可以获得更多内容。
获取Facebook帖子的评论信息 https://graph.facebook.com/{postId}/comments?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}
获取Facebook帖子的点赞信息 https://graph.facebook.com/{postId}/likes?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;summary=true&amp;amp;access_token={accessToken}</description></item><item><title>Facebook Graph API之message_tags</title><link>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8Bmessage_tags/</link><pubDate>Tue, 05 Jan 2016 06:38:10 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E4%B9%8Bmessage_tags/</guid><description>message_tag是Facebook帖子和评论中消息标记的设置档，包括标记ID、文本、类型、偏移和长度。 今天才注意到Facebook帖子（Post）中message_tag是一个JSON对象，而评论（Comment）中message_tag是一个JSON数组。
帖子中的message_tag是这个样子的：
&amp;#34;message_tags&amp;#34;: { &amp;#34;88&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;168597536563870&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;IBM&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 88, &amp;#34;length&amp;#34;: 3 } ], &amp;#34;93&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;241760048297&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Fidelity Investments&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 93, &amp;#34;length&amp;#34;: 20 } ], &amp;#34;115&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;145619362306025&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;ABB&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 115, &amp;#34;length&amp;#34;: 3 } ], &amp;#34;120&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;252467906271&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Quintiles&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 120, &amp;#34;length&amp;#34;: 9 } ], &amp;#34;131&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;193453547355388&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;SAS Software&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 131, &amp;#34;length&amp;#34;: 12 } ], &amp;#34;161&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;702317053131576&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Duke Energy&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 161, &amp;#34;length&amp;#34;: 11 } ], &amp;#34;174&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;313176732094295&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Toshiba Global Commerce Solutions&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 174, &amp;#34;length&amp;#34;: 33 } ], &amp;#34;209&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;20531316728&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Facebook&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;page&amp;#34;, &amp;#34;offset&amp;#34;: 209, &amp;#34;length&amp;#34;: 8 } ] } 评论中的message_tag是这个样子的：</description></item><item><title>Facebook Graph API获取帖子订阅信息之limit参数</title><link>https://mryqu.github.io/post/facebook_graph_api%E8%8E%B7%E5%8F%96%E5%B8%96%E5%AD%90%E8%AE%A2%E9%98%85%E4%BF%A1%E6%81%AF%E4%B9%8Blimit%E5%8F%82%E6%95%B0/</link><pubDate>Mon, 04 Jan 2016 05:30:32 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api%E8%8E%B7%E5%8F%96%E5%B8%96%E5%AD%90%E8%AE%A2%E9%98%85%E4%BF%A1%E6%81%AF%E4%B9%8Blimit%E5%8F%82%E6%95%B0/</guid><description>不同版本Facebook Graph API对 获取帖子订阅信息中limit参数要求不同：
v2.0及以下版本没有说明 v2.1、v2.2和v2.3版本上限为250 v2.4和v2.5版本上限为100</description></item><item><title>Facebook开发调试工具</title><link>https://mryqu.github.io/post/facebook%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 07 Oct 2015 07:13:44 +0000</pubDate><guid>https://mryqu.github.io/post/facebook%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>Facebook开发调试工具大体位于https://developers.facebook.com/tools-and-support/下。
访问口令工具:这里所提供的用户口令便于测试应用，会过期。应用口令不会过期，应该秘密存储。 图谱API探索工具:测试图谱API或FQL查询。 JS JDK控制台: 可以加载FacebookJS库，执行HTML代码 URL调试器:可以让Facebook的爬虫抓取你的网站，看看你的网站在Facebook被共享时的模样。 这里面我用的最多的是图谱API探索工具，其次就是看图谱API参考文档了。</description></item><item><title>[算法] 学习无向图</title><link>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E5%AD%A6%E4%B9%A0%E6%97%A0%E5%90%91%E5%9B%BE/</link><pubDate>Fri, 21 Mar 2014 21:40:18 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E5%AD%A6%E4%B9%A0%E6%97%A0%E5%90%91%E5%9B%BE/</guid><description>本文是学习http://algs4.cs.princeton.edu/41graph/的吐槽和体会。
一点吐槽 一开始对GraphClient.java中numberOfSelfLoops函数进行count/2不解，翻回Graph.java，看看addEdge函数才明白，合着对自循环连接，adj里面加两次。这么干有什么好处么？！！
再后来看Cycle.java，对hasParallelEdges函数又不解，仔细想想Graph.java不但接受addEdge(1,23)和addEdge(23, 1)，对执行多次addEdge(1,23)也不拒绝。一个无向图这么弄，对么？算不算检查不严格呀？！！
理解Cycle.java 示例代码：
public static void main(String[] args) { Graph G = new Graph(4); G.addEdge(0, 1); G.addEdge(1, 2); G.addEdge(1, 3); G.addEdge(2, 3); Cycle finder = new Cycle(G); if (finder.hasCycle()) { for (int v : finder.cycle()) { StdOut.print(v + &amp;#34; &amp;#34;); } StdOut.println(); } else { StdOut.println(&amp;#34;Graph is acyclic&amp;#34;); } } dfs搜索：
|上一节点u|当前节点v|下一节点w|注解 |&amp;mdash;&amp;ndash; |-1|0|1|节点1没有标注，嵌套dfs |0|1|3|节点3没有标注，嵌套dfs |1|3|2|节点2没有标注，嵌套dfs |3|2|1|节点1已标注，发现cycle，创建栈，依次：
(在for循环中)push 2 (在for循环中)push 3 push 1 push 2说白了就是当发现下一节点w已经标注，那就返回去找w到v的路径，然后凑上w和v，就是一个环路。 理解Bipartite.java 二分图又称作二部图、两偶图，是图论中的一种特殊模型。设G=(V,E）是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B），并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集（iin A,j in B），则称图G为一个二分图。</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>graph on Mryqu's Notes</title><link>https://mryqu.github.io/tags/graph/</link><description>Recent content in graph on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 04 Jan 2016 05:30:32 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>Facebook Graph API合集</title><link>https://mryqu.github.io/post/facebook_graph_api_notes/</link><pubDate>Mon, 04 Jan 2016 05:30:32 +0000</pubDate><guid>https://mryqu.github.io/post/facebook_graph_api_notes/</guid><description>常用URL笔记 获取Facebook主页Id https://graph.facebook.com/v2.5/SasSoftware?access_token={accessToken}&amp;amp;format=json 上面示例是通过主页名SasSoftware获取其主页Id。
获取Facebook主页帖子
https://graph.facebook.com/v2.5/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=2015-01-01&amp;amp;util=2015-12-31 https://graph.facebook.com/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 https://graph.facebook.com/v2.0/{pageId}/feed?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}&amp;amp;since=1420041660&amp;amp;util=1422634320 通过Facebook Graph API 2.5或不带版本的API仅能获取帖子的Id、创建时间和帖子内容，而FacebookGraph API 2.0则可以获得更多内容。
获取Facebook帖子的评论信息 https://graph.facebook.com/{postId}/comments?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;access_token={accessToken}
获取Facebook帖子的点赞信息 https://graph.facebook.com/{postId}/likes?limit=100&amp;amp;format=json&amp;amp;include_hidden=true&amp;amp;summary=true&amp;amp;access_token={accessToken}
获取帖子订阅信息之limit参数 不同版本Facebook Graph API对获取帖子订阅信息 中limit参数要求不同：
v2.0及以下版本没有说明 v2.1、v2.2和v2.3版本上限为250 v2.4和v2.5版本上限为100 处理Facebook API访问速率超限错误 对于下列Facebook通用错误，我个人觉的#2、#4、#9、#17、#18和#32错误都可以向客户端报告FacebookAPI访问速率超限，至于#5不确定。
Error number PHP Constant name Error description Generated by methods 2 API_EC_SERVICE Service temporarily unavailable (all) 4 API_EC_TOO_MANY_CALLS Application request limit reached (all) 5 API_EC_BAD_IP Unauthorized source IP address (all) 9 API_EC_RATE User is performing too many actions 17 API_EC_USER_TOO_MANY_CALLS User request limit reached 18 API_EC_REQUEST_RESOURCES_EXCEEDED This API call could not be completed due to resourcelimits 32 Page request limit reached 参考</description></item><item><title>Facebook开发调试工具</title><link>https://mryqu.github.io/post/facebook%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 07 Oct 2015 07:13:44 +0000</pubDate><guid>https://mryqu.github.io/post/facebook%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>Facebook开发调试工具大体位于https://developers.facebook.com/tools-and-support/下。
访问口令工具:这里所提供的用户口令便于测试应用，会过期。应用口令不会过期，应该秘密存储。 图谱API探索工具:测试图谱API或FQL查询。 JS JDK控制台: 可以加载FacebookJS库，执行HTML代码 URL调试器:可以让Facebook的爬虫抓取你的网站，看看你的网站在Facebook被共享时的模样。 这里面我用的最多的是图谱API探索工具，其次就是看图谱API参考文档了。</description></item><item><title>[算法] 学习无向图</title><link>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E5%AD%A6%E4%B9%A0%E6%97%A0%E5%90%91%E5%9B%BE/</link><pubDate>Fri, 21 Mar 2014 21:40:18 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%AE%97%E6%B3%95_%E5%AD%A6%E4%B9%A0%E6%97%A0%E5%90%91%E5%9B%BE/</guid><description>本文是学习http://algs4.cs.princeton.edu/41graph/的吐槽和体会。
一点吐槽 一开始对GraphClient.java中numberOfSelfLoops函数进行count/2不解，翻回Graph.java，看看addEdge函数才明白，合着对自循环连接，adj里面加两次。这么干有什么好处么？！！
再后来看Cycle.java，对hasParallelEdges函数又不解，仔细想想Graph.java不但接受addEdge(1,23)和addEdge(23, 1)，对执行多次addEdge(1,23)也不拒绝。一个无向图这么弄，对么？算不算检查不严格呀？！！
理解Cycle.java 示例代码：
public static void main(String[] args) { Graph G = new Graph(4); G.addEdge(0, 1); G.addEdge(1, 2); G.addEdge(1, 3); G.addEdge(2, 3); Cycle finder = new Cycle(G); if (finder.hasCycle()) { for (int v : finder.cycle()) { StdOut.print(v + &amp;#34; &amp;#34;); } StdOut.println(); } else { StdOut.println(&amp;#34;Graph is acyclic&amp;#34;); } } dfs搜索：
|上一节点u|当前节点v|下一节点w|注解 |&amp;mdash;&amp;ndash; |-1|0|1|节点1没有标注，嵌套dfs |0|1|3|节点3没有标注，嵌套dfs |1|3|2|节点2没有标注，嵌套dfs |3|2|1|节点1已标注，发现cycle，创建栈，依次：
(在for循环中)push 2 (在for循环中)push 3 push 1 push 2说白了就是当发现下一节点w已经标注，那就返回去找w到v的路径，然后凑上w和v，就是一个环路。 理解Bipartite.java 二分图又称作二部图、两偶图，是图论中的一种特殊模型。设G=(V,E）是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B），并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集（iin A,j in B），则称图G为一个二分图。</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javaee on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/javaee/</link>
    <description>Recent content in Javaee on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 13 Aug 2018 10:25:53 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/javaee/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Spring] LDAP用户验证笔记</title>
      <link>https://mryqu.github.io/post/spring_ldap%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 13 Aug 2018 10:25:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spring_ldap%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E7%AC%94%E8%AE%B0/</guid>
      <description>对Spring LDAP用户验证进行了学习，制作了时序图： LDAP身份验证的步骤为：
- 从客户端登录页面获得用户名和密码。
- 匿名或使用管理DN/密码绑定到LDAP服务器，通过登录用户名查询用户DN，如失败则报用户不存在。
- 使用用户DN和密码再次绑定到LDAP服务器，如果能成功绑定则验证成功，否则报用户密码错误。
参考 Spring Security Architecture
Spring Security Reference
Spring Security Project
GETTING STARTED: Authenticating a User with LDAP
GitHub: spring-guides/gs-authenticating-ldap</description>
    </item>
    
    <item>
      <title>差一点搞混了Transactional注解</title>
      <link>https://mryqu.github.io/post/%E5%B7%AE%E4%B8%80%E7%82%B9%E6%90%9E%E6%B7%B7%E4%BA%86transactional%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 01 Apr 2014 20:03:28 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B7%AE%E4%B8%80%E7%82%B9%E6%90%9E%E6%B7%B7%E4%BA%86transactional%E6%B3%A8%E8%A7%A3/</guid>
      <description>今天给我的Srping业务层加如下Service和Transactional注解：
@Service @Scope(BeanDefinition.SCOPE_SINGLETON) @Transactional(propagation=Propagation.REQUIRED, timeout=600, rollbackFor=Exception.class)  结果总是不认propagation、timeout和rollbackFor，后来才发现我引入类定义错了，本来应该用Spring的org.springframework.transaction.annotation.Transactional，可是引入了JavaEE用于CDI(Contextsand Dependency Injection for the Java EEplatform，上下文和依赖注入)bean的javax.transaction.Transactional,不注意还真容易混淆。</description>
    </item>
    
    <item>
      <title>玩玩HTTP servlet和session资源监控器</title>
      <link>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9http_servlet%E5%92%8Csession%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7%E5%99%A8/</link>
      <pubDate>Thu, 07 Nov 2013 22:40:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E7%8E%A9%E7%8E%A9http_servlet%E5%92%8Csession%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7%E5%99%A8/</guid>
      <description>WebListener是Servlet的监视器，它可以监听Http请求、会话生命周期事件等。其中包含如下接口： - ServletContextListener:监视servlet上下文的初始化(启动Web应用的初始化过程)、销毁（关闭Web应用）。 - ServletContextAttributeListener:监视servlet上下文属性的添加、删除和替换。 - ServletRequestListener:监视Http请求的初始化（进入第一个servlet或过滤器）、Web应用对请求处理结束（离开最后一个servlet或过滤器）。 - ServletRequestAttributeListener:监视Http请求属性的添加、删除和替换。 - HttpSessionListener:监视Http会话创建和失效操作。 - HttpSessionAttributeListener:监视Http会话属性的添加、删除和替换。最近hello一个Web项目，其中有个向导上传文件进行处理，文件被保存在tomcat的临时目录，处理后再删除。过段时间发现临时目录里有一些未删除的临时文件，应该是上传文件后，在处理结束前有一段时间未进行操作，会话失效，临时文件没有被删除。后来添加了一个MyResourceMonitorListener完成这些未处理临时文件的删除操作，解决了这个问题。代码如下：
MyResourceMonitorListener package com.yqu.http.session; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class MyResourceMonitorListener implements ServletContextListener, HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent event) { trace(&amp;quot;sessionCreated!&amp;quot;); } @Override public void sessionDestroyed(HttpSessionEvent event) { HttpSession session = event.getSession(); if (session != null) { String sessionId = session.getId(); trace(&amp;quot;sessionDestroyed with sessionId=&amp;quot; + sessionId + &amp;quot;!&amp;quot;); MyUtil.cleanSessionResources(session); } } @Override public void contextDestroyed(ServletContextEvent event) { MyUtil.</description>
    </item>
    
  </channel>
</rss>
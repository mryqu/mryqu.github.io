<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>遍历 on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/%E9%81%8D%E5%8E%86/</link>
    <description>Recent content in 遍历 on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 31 May 2013 12:21:17 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/%E9%81%8D%E5%8E%86/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>多维数据遍历</title>
      <link>https://mryqu.github.io/post/%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 31 May 2013 12:21:17 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86/</guid>
      <description>在联机分析处理（OLAP）系统中，需要对存储在数据库或数据仓库中的数据提供分析。由于数据维数不定，无法采用多重for循环进行数据遍历。我在开发过程中一般使用扁平化下标对多维数据进行遍历，今天尝试了一下递归方式，效率更高一些，但是对栈的消耗也更多一些。下面的代码示例使用两种不同的方式对多维数据进行遍历： - 递归 - 采用扁平化下标
示例代码 package com.yqu.collection; import java.util.ArrayList; import java.util.List; public class MultipleDimensionTraveling &amp;lt;T&amp;gt;{ private List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; mdList; public MultipleDimensionTraveling(){ mdList = new ArrayList&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;(); } public MultipleDimensionTraveling(List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; mdList){ this.mdList = mdList; } public void addDimension(List&amp;lt;T&amp;gt; dim){ mdList.add(dim); } public void travelByRecursion(){ if(!mdList.isEmpty()) travelByRecursion(0, new ArrayList&amp;lt;T&amp;gt;(mdList.size())); } private void travelByRecursion(int dimIdx, List&amp;lt;T&amp;gt; crossing){ for(int i=0;i&amp;lt;mdList.get(dimIdx).size();i++){ if(crossing.size()&amp;lt;mdList.size()) crossing.add(dimIdx, mdList.get(dimIdx).get(i)); else crossing.set(dimIdx, mdList.get(dimIdx).get(i)); if(dimIdx==mdList.size()-1){ System.out.println(crossing.toString()); } else { travelByRecursion(dimIdx+1, crossing); } } } public void travelByFlatIndice(){ if(!</description>
    </item>
    
  </channel>
</rss>
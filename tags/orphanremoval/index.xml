<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Orphanremoval on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/orphanremoval/</link>
    <description>Recent content in Orphanremoval on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 26 Oct 2013 13:15:59 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/orphanremoval/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[JPA] CascadeType.REMOVE与orphanRemoval的区别</title>
      <link>https://mryqu.github.io/post/jpa_cascadetype.remove%E4%B8%8Eorphanremoval%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 26 Oct 2013 13:15:59 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/jpa_cascadetype.remove%E4%B8%8Eorphanremoval%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Cascading Remove 将引用字段标注为CascadeType.REMOVE（或包含REMOVE的CascadeType.ALL）表明删除操作将应该自动级联到由该字段引用的实体对象（多个实体对象可以由集合字段引用）:
@Entity class Employee { : @OneToOne(cascade=CascadeType.REMOVE) private Address address; : }  Orphan Removal JPA2额外支持一种更积极的删除级联模式，可以通过@OneToOne和@OneToMany注释的orphanRemoval元素设置:
@Entity class Employee { : @OneToOne(orphanRemoval=true) private Address address; : }  区别 两个设置的区别在于关系断开的响应。 例如，将地址字段设置为null或另一个Address对象时，不同设置的结果是不同。 - 如果指定了 orphanRemoval = true，则断开关系的的Address实例将被自动删除。这对于清除没有所有者对象（例如Employee）引用的、不该存在的依赖对象（例如Address）很有用。 - 如果仅指定 cascade = CascadeType.REMOVE，则不会执行上述自动删除操作，因为断开关系不是删除操作。
参考 Deleting JPA Entity Objects</description>
    </item>
    
  </channel>
</rss>
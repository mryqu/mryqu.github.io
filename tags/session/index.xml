<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>session on Mryqu's Notes</title><link>https://mryqu.github.io/tags/session/</link><description>Recent content in session on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 17 Jul 2018 06:09:41 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/session/index.xml" rel="self" type="application/rss+xml"/><item><title>[Spark] 使用Spark的REST服务Livy</title><link>https://mryqu.github.io/post/spark_%E4%BD%BF%E7%94%A8spark%E7%9A%84rest%E6%9C%8D%E5%8A%A1livy/</link><pubDate>Tue, 17 Jul 2018 06:09:41 +0000</pubDate><guid>https://mryqu.github.io/post/spark_%E4%BD%BF%E7%94%A8spark%E7%9A%84rest%E6%9C%8D%E5%8A%A1livy/</guid><description>Apache Livy简介 Apache Livy是由Cloudera Labs贡献的基于Apache Spark的开源REST服务，它不仅以REST的方式代替了Spark传统的处理交互方式，同时也提供企业应用中不可忽视的多用户，安全，以及容错的支持。其功能如下：- 拥有可用于多Spark作业或多客户端长时间运行的SparkContext；
同时管理多个SparkContext，并在集群（YARN / Mesos）而不是Livy服务器上运行它们，以实现良好的容错性和并发性； 可以通过预先编译好的JAR、代码片段或是java/scala客户端API将Spark作业提交到远端的Spark集群上执行。 建立测试环境 今天在GitHub: mryqu/vagrant-hadoop-hive-spark提交了add livy support，因此可以在Vagrant搭建的Hadoop 2.7.6 + Hive 2.3.3 + Spark 2.3.0虚拟机环境中使用Livy 0.5.0服务。 使用Livy的REST API 创建交互式会话 curl -X POST -d &amp;#39;{&amp;#34;kind&amp;#34;: &amp;#34;spark&amp;#34;}&amp;#39; -H &amp;#34;Content-Type: application/json&amp;#34; http://10.211.55.101:8998/sessions { &amp;#34;id&amp;#34;:0, &amp;#34;appId&amp;#34;:null, &amp;#34;owner&amp;#34;:null, &amp;#34;proxyUser&amp;#34;:null, &amp;#34;state&amp;#34;:&amp;#34;starting&amp;#34;, &amp;#34;kind&amp;#34;:&amp;#34;spark&amp;#34;, &amp;#34;appInfo&amp;#34;:{ &amp;#34;driverLogUrl&amp;#34;:null, &amp;#34;sparkUiUrl&amp;#34;:null }, &amp;#34;log&amp;#34;:[ &amp;#34;stdout: &amp;#34;, &amp;#34; stderr: &amp;#34; ] } 成功创建会话0，kind指定为spark，如果之后提交的代码中没有指定kind，则使用此处的会话默认kind。
查询交互式会话列表 curl http://10.211.55.101:8998/sessions { &amp;#34;from&amp;#34;:0, &amp;#34;total&amp;#34;:1, &amp;#34;sessions&amp;#34;:[ { &amp;#34;id&amp;#34;:0, &amp;#34;appId&amp;#34;:null, &amp;#34;owner&amp;#34;:null, &amp;#34;proxyUser&amp;#34;:null, &amp;#34;state&amp;#34;:&amp;#34;idle&amp;#34;, &amp;#34;kind&amp;#34;:&amp;#34;spark&amp;#34;, &amp;#34;appInfo&amp;#34;:{ &amp;#34;driverLogUrl&amp;#34;:null, &amp;#34;sparkUiUrl&amp;#34;:null }, &amp;#34;log&amp;#34;:[ &amp;#34;2018-07-18 03:19:16 INFO BlockManager:54 - Using org.</description></item><item><title>Tomcat的会话持久化</title><link>https://mryqu.github.io/post/tomcat%E7%9A%84%E4%BC%9A%E8%AF%9D%E6%8C%81%E4%B9%85%E5%8C%96/</link><pubDate>Fri, 08 Nov 2013 20:17:47 +0000</pubDate><guid>https://mryqu.github.io/post/tomcat%E7%9A%84%E4%BC%9A%E8%AF%9D%E6%8C%81%E4%B9%85%E5%8C%96/</guid><description>《玩玩HTTP servlet和session资源监控器》提到我hello的一个web项目，刚开始我只是用监视器清除了Tomcat容器外部的文件资源，以为会话失效后Tomcat会自己清除会话属性，但后来发现想的太简单了。不但会话失效，并且重启Tomcat服务器，服务器端原来的会话及其属性都在,如果客户端浏览器的会话没有丢的话，刷新页面仍然可以获得以前的信息。原来Tomcat（起码5.x之后的版本）在默认的情况下提供了会话持久化这项功能，见$TOMCAT_HOME$/conf/context.xml：Tomcat的默认会话管理器是标准会话管理器(StandardManager)，用于非集群环境中对单个处于运行状态的Tomcat实例会话进行管理。当Tomcat关闭时，这些会话相关的数据会被写入磁盘上的一个名叫SESSION.ser的文件，并在Tomcat下次启动时读取此文件。
默认只有在Tomcat正常关闭时才会保存完整的用户会话信息 默认保存于$CATALINA_HOME$/work/Catalina/[host]/[webapp]/下的SESSIONS.ser文件中 若是自定义的虚拟主机则保存在$CATALINA_HOME/work/Catalina/[host]/_/下的SESSIONS.ser文件中 如果不想再获得失效会话属性的话，解决办法为：
关闭Tomcat会话持久化功能。去掉context.xml中那句注释即可。 HttpSessionListener实现类的sessionDestroyed方法删除该会话所有属性。 参考 Apache Tomcat 5.5 Configuration ReferenceTomcat会话管理</description></item></channel></rss>
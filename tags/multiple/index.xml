<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Multiple on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/multiple/</link>
    <description>Recent content in Multiple on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 29 Dec 2016 06:10:45 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/multiple/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>在Google Drive上创建存在多个目录下的文件</title>
      <link>https://mryqu.github.io/post/%E5%9C%A8google_drive%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 29 Dec 2016 06:10:45 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%9C%A8google_drive%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>准备环境 在Google Drive上创建两个目录: parent1和parent2 代码 package com.yqu.gd; import java.io.IOException; import java.util.ArrayList; import java.util.List; import com.google.api.client.auth.oauth2.Credential; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.FileContent; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.jackson2.JacksonFactory; import com.google.api.services.drive.Drive; import com.google.api.services.drive.model.File; import com.google.api.services.drive.model.FileList; public class FileWithMultiParents { private static final String APPLICATION_NAME = &amp;quot;Hello Google Drive API&amp;quot;; private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance(); private static HttpTransport HTTP_TRANSPORT; static { try { HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport(); } catch (Throwable t) { t.</description>
    </item>
    
    <item>
      <title>[Maven] 构建多模块项目</title>
      <link>https://mryqu.github.io/post/maven_%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Sat, 03 Sep 2016 07:07:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/maven_%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE/</guid>
      <description> 在前一篇博文[Gradle] 将多项目转换成Maven项目中利用Gradle转换成Maven构建脚本，将朋友糊弄过去了。后来想想，还是给他做一个重头搭建多模块Maven项目的演示吧。
创建根（父）项目 下列脚本可以创建一个包含pom.xml的yqu-ts-parent目录：
mvn archetype:generate -DgroupId=com.yqu.ts -DartifactId=yqu-ts-parent -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false  测试结果： 进入yqu-ts-parent目录，删除src子目录，然后将pom.xml文件中packaging节点内容由jar改为pom。pom表示它是一个被继承的模块
创建子项目 在yqu-ts-parent目录中运行下列脚本可以创建两个包含pom.xml文件的子目录yqu-ts-service和yqu-ts-webapp：
mvn archetype:generate -DgroupId=com.yqu.ts -DartifactId=yqu-ts-service -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false mvn archetype:generate -DgroupId=com.yqu.ts -DartifactId=yqu-ts-webapp -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false  测试结果： 这两个命令会修改yqu-ts-parent项目的pom.xml，增加了两个子模块yqu-ts-service和yqu-ts-webapp。对于两个字模块的pom.xml，增加packaging节点，由于这两个子模块将用SpringBoot实现因而内容都为jar。
确认项目/模块的pom.xml yqu-ts-parent项目的pom.xml yqu-ts-service模块的pom.xml yqu-ts-webapp模块的pom.xml </description>
    </item>
    
    <item>
      <title>[Spring Boot] 使用多个Servlet</title>
      <link>https://mryqu.github.io/post/spring_boot_%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAservlet/</link>
      <pubDate>Wed, 28 Oct 2015 06:07:53 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spring_boot_%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAservlet/</guid>
      <description>当使用Spring boot的嵌入式servlet容器时，可以通过Springbean或扫描Servlet组件的方式注册Servlet、Filter和Servlet规范的所有监听器(例如HttpSessionListener)。 - 当urlMapping不是很复杂时，可以通过ServletRegistrationBean、FilterRegistrationBean和ServletListenerRegistrationBean获得完整控制。如果bean实现了ServletContextInitializer接口的话则可以直接注册。 - 当使用@ServletComponentScan扫描Servlet组件时，Servlet、过滤器和监听器可以是通过@WebServlet、@WebFilter和@WebListener自动注册
示例代码 Application.java package com.yqu.multiservlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.embedded.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.web.servlet.DispatcherServlet; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean public ServletRegistrationBean dispatcherRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean(dispatcherServlet); registration.addUrlMappings(&amp;quot;/hirest/*&amp;quot;); printStacks(); return registration; } @Bean public ServletRegistrationBean servletRegistrationBean() { printStacks(); return new ServletRegistrationBean( new SigninServlet(), &amp;quot;/signin&amp;quot;); } private void printStacks() { StackTraceElement[] elements = Thread.</description>
    </item>
    
  </channel>
</rss>
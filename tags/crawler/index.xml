<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crawler on Mryqu's Notes</title><link>https://mryqu.github.io/tags/crawler/</link><description>Recent content in crawler on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 20 Oct 2016 06:32:31 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/crawler/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello Google Drive APIs</title><link>https://mryqu.github.io/post/hello_google_drive_apis/</link><pubDate>Thu, 20 Oct 2016 06:32:31 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_drive_apis/</guid><description>准备环境 当前我的Google Drive内容如下： 继续使用博文《Google Sheets API认证和鉴权》中用过的应用yquGSTest，不过需要激活Google Drive API： Google Drive API测试 方法drive.about.get测试 方法drive.about.get用于获取用户、驱动和系统容量等信息。
方法drive.files.list测试 方法drive.files.list用于列举或搜索文件。
与Microsoft OneDriveAPI仅列举请求目录下文件不同，方法drive.files.list列举文件时返回了所有目录和文件，例如子目录FolderTest1下的文件Class_cn_Tab.csv也在响应内容里面。
方法drive.files.get测试 方法drive.files.get用于通过ID获取文件元数据。下面获得Class_cn_Tab.csv文件的元数据。
方法drive.files.create测试 方法drive.files.create用于创建一个新文件。
在API Explorer中仅能指定新文件的元数据，没法上传文件内容，所以虽然测试成功且GoogleDrive里也会显示新的文件，但是打不开。这种仅指定元数据不提供内容的方式特别适合创建目录。
https://developers.google.com/drive/v3/web/manage-uploads里面说明了如何在创建或更新文件时上传文件内容。
通过Java JDK创建文件 与博文《Google Sheets API认证和鉴权》中获取访问令牌的差异如下：
GET https://accounts.google.com/o/oauth2/v2/auth? scope=**&amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;https://www.googleapis.com/auth/drive&amp;lt;/font&amp;gt;** https://www.googleapis.com/auth/drive.readonly profile&amp;amp;amp; redirect_uri=urn:ietf:wg:oauth:2.0:oob&amp;amp;amp; response_type=code&amp;amp;amp; client_id=826380598768-5935tlo90sccvr691ofmp4nrvpthrnn6.apps.googleusercontent.com``` 代码如下： package com.yqu.gd;
import java.io.IOException; import java.util.Collections; import java.util.List;
import com.google.api.client.auth.oauth2.Credential; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.FileContent; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.jackson2.JacksonFactory; import com.google.api.services.drive.Drive; import com.google.api.services.drive.model.File; import com.google.api.services.drive.model.FileList;
public class HelloGoogleDrive {</description></item><item><title>Hello Microsoft OneDrive API</title><link>https://mryqu.github.io/post/hello_microsoft_onedrive_api/</link><pubDate>Wed, 12 Oct 2016 06:14:09 +0000</pubDate><guid>https://mryqu.github.io/post/hello_microsoft_onedrive_api/</guid><description>OneDriveAPI提供了一套HTTP服务用以将应用连接到OneDrive个人版、OneDrive商业版及SharePoint在线文档库上的文件和目录。OneDriveAPI使应用连接Office 365上文档及访问OneDrive和SharePoint上文件高级功能变得容易。
测试源 为了省事，就用我自己私人的OneDrive做测试吧。 获取Token 最省事的方法是在OneDrive authentication and sign-in里面获得测试Token，无需注册新的应用就可以请求到与登录账户绑定的、一个有效期1小时的开发者Token。
测试API 获取默认Drive 查看Drive 根目录内容 从上图可知，根目录包含一个包含&amp;quot;050709大同&amp;quot;子目录，该子目录的id为&amp;quot;712B21FCE8E08C92!112&amp;quot;。从整个响应内容可知，根目录包含&amp;quot;文档&amp;quot;子目录，其id为&amp;quot;712B21FCE8E08C92!442&amp;quot;。
查看Drive &amp;ldquo;文档&amp;quot;目录 该目录下有一个CN_EN_JP_KO.xlsx文件，其@content.downloadUrl属性值为下载链接。
获取CN_EN_JP_KO.xlsx文件 如果将链接直接放入浏览器，下载后将文件名变更成xlsx后缀，即可用Excel打开。
参考 Develop with the OneDrive API</description></item><item><title>Hello Dropbox API</title><link>https://mryqu.github.io/post/hello_dropbox_api/</link><pubDate>Tue, 04 Oct 2016 05:53:29 +0000</pubDate><guid>https://mryqu.github.io/post/hello_dropbox_api/</guid><description>本博文用来记录一下粗略体验Dropbox关于用户、文件、共享三方面API的过程。
准备环境 还是用我私人的Dropbox做测试，所以只显示Public目录下的东东了。 用户类API测试 方法get_current_account测试 方法get_account测试 方法get_space_usage测试 文件类API测试 方法list_folder测试 方法list_folder其实是列举文件和目录，而且是分层的。如果path没设，则显示根目录下的元素。
方法get_metadata测试 方法get_metadata用于获取一个元素（文件/目录）的元数据。
方法create_folder测试 方法get_preview测试 方法get_preview仅支持 .doc、 .docx、 .docm、 .ppt、 .pps、 .ppsx、 .ppsm、.pptx、.pptm、 .xls、 .xlsx、 .xlsm、.rtf文件类型。就我的测试而言，没看出跟下面的download方法有多大区别。
这里尝试了一下path的其他使用方式。除了最常规的文件路径外，path参数还可以使用id或rev。
方法download测试 方法search测试 方法upload测试 方法delete测试 方法delete用于删除一个元素（文件/目录）。
方法permanently_delete测试 方法permanently_delete是支持Dropbox商业应用，而我的是开发应用，因而测试失败。
共享类API测试 方法share_folder测试 方法list_folders测试 方法unshare_folder测试 方法unshare_folder使用的是异步任务的方式，需要通过下列的方法check_job_status查询任务进度及结果。
方法check_job_status测试 方法create_share_link测试 share_folder可以通过邮件或Dropbox账户的方式分享给其他Dropbox用户，而share_link甚至可以共享给没有安装Dropbox的使用者。
方法get_share_links测试 方法get_shared_link_file测试 方法revoke_shared_link测试 revoke_shared_link竟然不返回结果，查证文档后确实如此。
学习总结 Dropbox关于文件共享方面的API占比相对OneDrive、Google Drive要多一些。 Dropbox API相对OneDrive、GoogleDrive而言，成熟度更低。按照REST的Richardson成熟度模型来说仅在2-级别，它的REST资源还是动词，例如get_metadata、check_job_status。
参考 Dropbox Dropbox API v2 for HTTP Developers Dropbox API Explorer</description></item><item><title>Hello Google Sheets API</title><link>https://mryqu.github.io/post/hello_google_sheets_api/</link><pubDate>Wed, 28 Sep 2016 06:00:05 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_sheets_api/</guid><description>准备环境 首先在Google Sheets创建了SpreadSheetTest1和To-do list两个电子表格，以备使用。 API测试 方法spreadsheets.get测试 方法spreadsheets.get可以获得一个电子表格中所有表单的内容和元数据。 下面是用Postman进行同样操作： 方法spreadsheets.values.get测试 方法spreadsheets.values.get可以获得一个电子表格中所有表单的内容。 方法spreadsheets.create测试 方法spreadsheets.create可以创建一个新的电子表格。 查看GoogleSheets，也可以看到新创建的电子表格SpreadSheetCreate1。由于我的请求里没有数据，因此下图中数据区也是空空。 方法spreadsheets.values.append测试 方法spreadsheets.values.append可以向电子表格中添加内容。 查看Google Sheets，也可以看到刚才创建的电子表格SpreadSheetCreate1有了九个单元格新数据。 学习结论 Google Sheets API可以创建、读取和修改电子表格，但是没有找到删除电子表格的方法。 Google SheetsAPI可以创建、读取、修改和删除一个电子表格内容，例如方法spreadsheets.batchUpdate中deleteSheet就可以删除一个表单，而deleteDimension就可以删除一个表单中的行/列。
参考 Google Sheets Google Sheets API Google API Explorer: Sheets</description></item><item><title>Hello Spring Social LinkedIn</title><link>https://mryqu.github.io/post/hello_spring_social_linkedin/</link><pubDate>Tue, 03 Nov 2015 05:50:46 +0000</pubDate><guid>https://mryqu.github.io/post/hello_spring_social_linkedin/</guid><description>本想玩玩Spring SocialLinkedIn，看看能从LinkedIn哪里获得什么有价值的数据。可是LinkedIn现在放开的只有r_basicprofile、r_emailaddress、rw_company_admin、w_share权限，如LinkedIn developer program transition所说的不要在认证中请求r_fullprofile、r_network、r_contactinfo、rw_nus、rw_groups和w_messages权限了。 在LinkedIn API Console中可试最多的是CompaniesAPI，可是我在LinkedIn上没有公司主页可以创建。所以浅尝则止，没什么太多可分享的。
参考 Spring Social LinkedIn Project
Spring Social Project
GitHub: spring-projects/spring-social-samples
LinkedIn Developer
LinkedIn API Console
LinkedIn developer program transition</description></item><item><title>Hello Spring Social Twitter</title><link>https://mryqu.github.io/post/hello_spring_social_twitter/</link><pubDate>Sun, 01 Nov 2015 06:03:04 +0000</pubDate><guid>https://mryqu.github.io/post/hello_spring_social_twitter/</guid><description>学习了Spring Accessing Twitter Data Guide，稍作修改，练习一下用Spring Social Twitter搜索推文。
HelloSpringTwitter代码 src/main/java/com/yqu/springtwitter/Application.java package com.yqu.springtwitter; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } src/main/java/com/yqu/springtwitter/HelloController.java package com.yqu.springtwitter; import javax.inject.Inject; import org.springframework.social.connect.ConnectionRepository; import org.springframework.social.twitter.api.SearchResults; import org.springframework.social.twitter.api.Twitter; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; @Controller @RequestMapping(&amp;#34;/&amp;#34;) public class HelloController { private Twitter twitter; private ConnectionRepository connectionRepository; @Inject public HelloController(Twitter twitter, ConnectionRepository connectionRepository) { this.</description></item><item><title>Hello RestFB</title><link>https://mryqu.github.io/post/hello_restfb/</link><pubDate>Wed, 21 Oct 2015 05:55:32 +0000</pubDate><guid>https://mryqu.github.io/post/hello_restfb/</guid><description>RestFB是一个简单灵活的Facebook图谱API和REST客户端Java库。本演示用它来获取一个Facebook主页下的帖子、评论及回复。
获取Facebook AccessToken 示例代码 package com.yqu.restfb; import java.util.List; import com.restfb.Connection; import com.restfb.DefaultFacebookClient; import com.restfb.FacebookClient; import com.restfb.Parameter; import com.restfb.Version; import com.restfb.types.Comment; import com.restfb.types.Page; import com.restfb.types.Post; public class HelloRestFB { public static void main(String[] args) { FacebookClient facebookClient = new DefaultFacebookClient( MY_ACCESS_TOKEN, Version.VERSION_2_5); Page pageInfo = (Page) facebookClient.fetchObject(&amp;#34;YquTest&amp;#34;, Page.class, new Parameter[0]); Connection postConnection = facebookClient.fetchConnection( pageInfo.getId() + &amp;#34;/feed&amp;#34;, Post.class, new Parameter[] { Parameter.with(&amp;#34;limit&amp;#34;, 10), Parameter.with(&amp;#34;include_hidden&amp;#34;, &amp;#34;true&amp;#34;) }); if (postConnection.getData().size() &amp;lt;= 0) { System.</description></item><item><title>Twitter的高级搜索和过滤功能</title><link>https://mryqu.github.io/post/twitter%E7%9A%84%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E5%92%8C%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/</link><pubDate>Tue, 20 Oct 2015 06:08:31 +0000</pubDate><guid>https://mryqu.github.io/post/twitter%E7%9A%84%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E5%92%8C%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/</guid><description>刚接触Twitter的搜索功能，以为仅能用关键字搜索推文。后来才知道，Twitter搜索不仅支持关键字的与或非逻辑处理，还能根据日期、地理位置、推文是否有链接、图像、视频、转推、回复等条件进行过滤。例如：
即包含&amp;quot;andrew&amp;quot;又包含&amp;quot;2015&amp;quot;的推文``` https://twitter.com/search?q=andrew 2015&amp;amp;src=typd - 完全匹配&amp;#34;andrew 2015&amp;#34;的推文``` https://twitter.com/search?q=&amp;#34;andew 2015&amp;#34;&amp;amp;src=typd 包含&amp;quot;andrew&amp;quot;或&amp;quot;2015&amp;quot;的中文推文``` https://twitter.com/search?q=andew OR 2015 lang:zh&amp;amp;src=typd - 包含&amp;#34;andrew&amp;#34;的推文（包括转推）``` https://twitter.com/search?q=andrew include:retweets&amp;amp;src=typd 包含&amp;quot;andrew&amp;quot;的推文（不包括转推）``` ttps://twitter.com/search?q=andrew exclude:retweets&amp;amp;src=typd - 包含&amp;#34;andrew&amp;#34;且有URL链接的推文``` https://twitter.com/search?q=andrew filter:links&amp;amp;src=typd 包含&amp;quot;andrew&amp;quot;且没有URL链接的推文``` https://twitter.com/search?q=andrew -filter:links&amp;amp;src=typd ### 参考 [Twitter Advanced Search](https://twitter.com/search-advanced) [Using Twitter Advanced Search](https://support.twitter.com/articles/71577) [How to Master Twitter Search: Basic Boolean Operators and Filters](http://thesocialchic.com/2013/04/26/how-to-master-twitter-search/)</description></item><item><title>Hello Twitter4J</title><link>https://mryqu.github.io/post/hello_twitter4j/</link><pubDate>Mon, 19 Oct 2015 06:10:11 +0000</pubDate><guid>https://mryqu.github.io/post/hello_twitter4j/</guid><description>Twitter4J是Twitter API的第三方Java库。本演示用它通过关键字搜索推文。
获取Twitter应用证书 示例代码
package com.yqu.twitter4j; import twitter4j.Query; import twitter4j.QueryResult; import twitter4j.Status; import twitter4j.Twitter; import twitter4j.TwitterFactory; public class HelloTwitter4J { // I18NOK:CLS public static void main(String[] args) { try { // The factory instance is re-useable and thread safe. Twitter twitter = TwitterFactory.getSingleton(); Query query = new Query(&amp;#34;夏洛特烦恼&amp;#34;); query.setLang(&amp;#34;zh&amp;#34;); query.setCount(10); QueryResult result = twitter.search(query); for (Status status : result.getTweets()) { System.out.println(status.getCreatedAt()+&amp;#34;:&amp;#34;+status.getText()); } } catch (Exception e) { e.printStackTrace(); } } } twitter.</description></item><item><title>Hello Youtube Analytics</title><link>https://mryqu.github.io/post/hello_youtube_analytics/</link><pubDate>Sat, 17 Oct 2015 06:10:21 +0000</pubDate><guid>https://mryqu.github.io/post/hello_youtube_analytics/</guid><description>Google Credential设置见我之前的博文解决 &amp;ldquo;Access Not Configured. The API (YouTube Analytics API) is not enabled for your project.&amp;rdquo;。
示例代码：
package com.yqu.yt; import java.io.IOException; import java.io.PrintStream; import java.math.BigDecimal; import java.util.List; import com.google.api.client.auth.oauth2.Credential; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.http.HttpTransport; import com.google.api.client.http.javanet.NetHttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.jackson2.JacksonFactory; import com.google.api.services.youtube.YouTube; import com.google.api.services.youtube.model.Channel; import com.google.api.services.youtube.model.ChannelListResponse; import com.google.api.services.youtubeAnalytics.YouTubeAnalytics; import com.google.api.services.youtubeAnalytics.model.ResultTable; import com.google.api.services.youtubeAnalytics.model.ResultTable.ColumnHeaders; import com.google.common.collect.Lists; public class HelloYoutubeAnalytics { //I18NOK:CLS private static final HttpTransport HTTP_TRANSPORT = new NetHttpTransport(); private static final JsonFactory JSON_FACTORY = new JacksonFactory(); private static YouTube youtube; private static YouTubeAnalytics analytics; public static void main(String[] args) { // These scopes are required to access information about the // authenticated user&amp;#39;s YouTube channel as well as Analytics // data for that channel.</description></item><item><title>Hello Google Analytics</title><link>https://mryqu.github.io/post/hello_google_analytics/</link><pubDate>Mon, 28 Sep 2015 05:57:14 +0000</pubDate><guid>https://mryqu.github.io/post/hello_google_analytics/</guid><description>Google Credential设置见我之前的博文Google Analytics API Error 403: &amp;ldquo;User does not have any Google Analytics Account&amp;rdquo;。
示例代码：
package com.yqu.ga; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.util.List; import com.google.api.client.googleapis.auth.oauth2.GoogleCredential; import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport; import com.google.api.client.http.HttpRequest; import com.google.api.client.http.HttpRequestInitializer; import com.google.api.client.http.HttpTransport; import com.google.api.client.json.JsonFactory; import com.google.api.client.json.gson.GsonFactory; import com.google.api.services.analytics.Analytics; import com.google.api.services.analytics.AnalyticsScopes; import com.google.api.services.analytics.model.Accounts; import com.google.api.services.analytics.model.GaData; import com.google.api.services.analytics.model.GaData.ColumnHeaders; import com.google.api.services.analytics.model.GaData.Query; import com.google.api.services.analytics.model.Profiles; import com.google.api.services.analytics.model.Webproperties; public class HelloAnalytics { // I18NOK:CLS private static enum AuthType { SERVICE_ACCOUNT, SERVICE_ACCOUNT_P12, OAUTH }; protected static final String APPLICATION_NAME = &amp;#34;Hello Analytics&amp;#34;; protected static final JsonFactory JSON_FACTORY = GsonFactory .</description></item></channel></rss>
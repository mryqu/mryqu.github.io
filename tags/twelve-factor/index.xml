<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>twelve-factor on Mryqu's Notes</title><link>https://mryqu.github.io/tags/twelve-factor/</link><description>Recent content in twelve-factor on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 16 Jun 2015 05:36:28 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/twelve-factor/index.xml" rel="self" type="application/rss+xml"/><item><title>使用Consul的十二要素应用（Twelve-Factor App）</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</link><pubDate>Tue, 16 Jun 2015 05:36:28 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8consul%E7%9A%84%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8twelve-factor_app/</guid><description>十二要素应用（The Twelve-Factor App）主张web应用应该从环境变量里获取其配置。这一实践很快被现代PaaS服务采用以用于允许简单的配置变更。 使用Consul，很容易将这一实践用于你自己的数据中心。如果你基础架构的某些方面部分使用PaaS，Consul是配置数据中心化的一个很好的方式。 在这篇文章中，我们将展示Consul和envconsul如何在不修改应用程序的情况下被用于设置配置值和在配置变更时触发自动重启。
为什么使用环境变量? 根据十二要素应用，web应用配置应该使用环境变量。跟配置文件或Java系统属性这样的机制比，环境变量有很多优点：
环境变量是一个与开发语言和操作系统无关的标准。 环境变量更难被意外提交到代码库。 环境变量跟易于在development、staging、QA这样不同的环境之间改变。 无论如何部署，环境变量易于设置和更新。 例如Heroku这样的完整PaaS解决方案公开一些有用的API以用于为应用自动设置/读取环境变量。 当手动部署应用时，以往这样的事会更复杂一些。而使用Consul，程序员就可以很容易地设置和读取配置，运营工程师就可以很容易地提供支持和维护。
Consul键值对和Envconsul Consul能够存储键值对数据。对于设置和获取键值对数据，Consul拥有简单的API和美丽且直观的web界面。对于存储配置数据来说，它是完美的。 很容易看到如何设置和读取配置数据，但是对于配置数据如何变成应用的环境变量还不是很清楚。envconsul是一个解决该类问题的轻量级解决方案。 使用envconsul，环境变量存储在ConsulKV中并具有某些（以&amp;quot;/&amp;ldquo;分割的）前缀。例如，为了配置服务&amp;quot;foo&amp;rdquo;，我们可能存储如下配置：
$ curl -X PUT -d &amp;#39;false&amp;#39; http://localhost:8500/v1/kv/foo/enabled true 这会在键foo/enabled中存储值false。 之后，使用envconsul, 我们可以将这些键转换为环境变量：
$ envconsul foo env ENABLED=false envconsul是一个对UNIX非常友好的应用。他有两个必需的参数：一个用于查找数据的KV前缀和一个应用及其可选参数。在上例中，我们告诉envconsul配置位于前缀foo下，且我们想运行应用env，该应用仅仅是输出环境变量。 在示例结果中，我们可以清楚地看到ENABLED如我们在ConsulKV中所设置的false。
如果将env改成你自己的应用，那么环境变量将暴露给你的应用。例如，为了运行一个Rails服务器你可能做如下操作。注意在真实生产场景中，你可能不直接运行Rails内建服务器，但是它不失为一个好案例：
$ envconsul foo bin/rails server ... 自动重载 使用PaaS，当你修改任何配置时你的应用将自动重启。我们可以以最小的代价通过Consul和Envconsul实现相同效果。 通过对envconsul添加-reload标志，一旦配置键发生增删改，envconsul将中断(SIGTERM)并重启你的应用：
$ envconsul -reload foo bin/rails server ... 注：该功能已经在0.4.0版本移除。 Consul HTTP API支持对给定前缀KV中的变更进行长轮询。一旦KV中发生变更，Envconsul通过这种方式可以高效地进行检测。
改良流程 对应用配置使用Consul和envconsul可以将PaaS化应用配置易用性带入你自己的原生环境。 对于开发者而言，他们可以无需跟运营工程师沟通或重新部署应用就可以设置配置。 对于运营来说，Consul对整个基础架构的服务发现和配置提供了统一的解决方案。Consul自动复制数据并存储在磁盘上以方便备份，运营工程师也可以高枕无忧了。
我的实践 Envconsul获取的环境变量既可以直接给启动服务器的命令使用（例如上面启动Rails内建服务器的bin/rails命令）；也可以通过python之类的脚本存成Java系统属性文件，通过chpst这样可以加载环境变量/系统属性文件的命令间接给Java命令使用。
envconsul \ -once \ -log-level info \ -consul localhost:8500 \ -upcase=false \ -prefix config/foo/jvm \ foo env /usr/local/tomcat/bin/catalina.</description></item><item><title>使用Docker的现代十二要素应用</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</link><pubDate>Thu, 04 Jun 2015 05:26:36 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8docker%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8D%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E5%BA%94%E7%94%A8/</guid><description>【编者的话】“十二要素应用”为开发SaaS应用提供了方法上的指导，而Docker能够提供打包依赖，解耦后端服务等特性，使得两者非常吻合。这篇文章介绍了Docker特性怎样满足了开发“十二要素应用”的对应要点。Docker非常适合开发“十二要素应用”。
“十二要素应用”为构建SaaS应用提供了方法论，是由知名PaaS云计算平台Heroku的创始人AdamWiggins提出的。请参考这篇[文章](http://www.infoq.com/cn/news/2012/09/12-factor-app)。 Dockerfile与docker-compose.yml正在成为用代码定义服务的标准，通过它们可以定义服务的所有内容：依赖、环境、端口、各种进程以及后端服务。Docker镜像和容器为操作系统提供了保证，使得开发环境和生产环境可以有效地保持一致。这篇文章简单地介绍了Docker是怎样满足“十二要素应用”的核心要点的。它解释了用Docker开发一个典型的“Rails/Postgres/Redis/web/worker”所应用的技术。后续文章将通过代码深入介绍如何应用这些技术。
II. 依赖—显示地声明和隔离依赖关系 Docker镜像基于显示的Dockerfile构建，而Docker容器作为独立的运行环境。Dockerfile提供了显示声明基础操作系统的方法（FROM）,而且通过运行命令来安装附加的系统包以及应用的依赖包（RUN）。通过这些方法，你可以声明你需要ubuntu 14.04、Ruby 2.2.2、Node 0.11，然后一次性安装。
III. 配置—在环境中储存配置 Docker容器非常依赖Linux的环境变量进行配置。docker-compose.yml有一个环境变量的哈希表，你可以通过它显示的定义容器的环境变量。这些默认的或者未定义的值将在运行时从主机中继承。另外，还有Dokckerfile的ENV命令以及『docker run –env=[]』和『docker run–env-file=[]』运行选项可以设置环境变量。通过这些方法，你可以声明你的应用需要环境变量GITHUB_AUTH_TOKEN。 VII. 端口绑定—通过端口绑定来提供服务 Docker非常依赖端口绑定。docker-compose.yml有一个端口阵列，可以通过它显示的定义“主机:容器”的端口绑定。『docker run –pHOST:CONTAINER』让你可以在运行时定义端口绑定。通过这些方法，你可以声明你的应用的网络服务器将监听端口5000，而且你可以通过主机的端口5000获取服务。
IV. 后端服务—把后端服务当作附加资源 Docker容器与其它容器几乎完全隔离，所以需要通过网络与后端服务进行通信。docker-compse.yml有一个链接哈希表，你可以通过它指定你的应用所需要依赖的其他容器服务。‘docker-composeup’命令将首先开启这些后端服务，然后配置应用容器中网络连接信息的环境变量。通过这些方法，你可以声明你的应用需要Postgres 9.4和Redis3.0服务，让你的应用通过主机名和端口号与他们建立连接。
VI. 进程—以一个或者多个无状态进程运行应用 默认情况下，Docker容器是不带储存的进程。docker-compose.yml定义了一系列服务，每一个服务都有自己的镜像或者构建文件(Dockerfile)以及命令。通过这些方法，你可以声明你的应用同时有一个网络进程和工作进程。
XII. 管理进程—后台管理任务当做一次性进程运行 Docker镜像可以很容易地运行一次性进程。‘docker run myapp CMD’可以在与你的网络进程一致的环境中运行任意命令。通过这些方法，你可以基于你的Postgres数据库运行交互式的bash或者运行一次性的’rakedb:migrate’进程。
现有技术 若没有Docker，OS X的开发工具链是这样的：Homebrew作为系统依赖包， Postgres和Redis作为开发服务,Ruby的Bundler作为跨平台开发依赖，一系列的Shell脚本和foreman让所有工具在本地同时运行起来，以及一个独立的基于Linux的构建服务负责将应用打包到生产环境。这样的工作流并没有错误，但是Docker提供一个更简洁的方式。有了Dockerfile和docker-compose.yml文件，我们将不再需要任何OSX系统依赖，服务包或者跨平台的语言依赖。一个简单的“dicker-composeup”命令可以提供一个完整的Linux开发环境，并且能够轻易地将“十二要素应用”移植到生产机器。
原英文链接：Modern Twelve-Factor Apps With Docker
原译文链接：现代“十二要素应用”与Docker</description></item></channel></rss>
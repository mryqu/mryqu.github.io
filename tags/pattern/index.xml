<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pattern on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/pattern/</link>
    <description>Recent content in Pattern on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 Jun 2015 06:22:55 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/pattern/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读八种Docker开发模式</title>
      <link>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Jun 2015 06:22:55 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E8%AF%BB%E5%85%AB%E7%A7%8Ddocker%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</guid>
      <description>Eight Docker Development Patterns（原文）
八种Docker开发模式（译文）
八种Docker开发模式（介绍）
目前，我对可重用的基础容器和支持共享文件夹的开发容器这两种模式接触的多一些。</description>
    </item>
    
    <item>
      <title>重温MVC:一个很好的MVC图</title>
      <link>https://mryqu.github.io/post/%E9%87%8D%E6%B8%A9mvc%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84mvc%E5%9B%BE/</link>
      <pubDate>Wed, 26 Mar 2014 22:28:35 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E9%87%8D%E6%B8%A9mvc%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84mvc%E5%9B%BE/</guid>
      <description>今天看了一个帖子A terrific Model View Controller (MVC) diagram，感觉文中说的很对：一个技术如果能简洁地表达出来，才容易被人记住并记的牢。该文中的Model/View/ControllerUML图共有两个，第一个图非常简单，仅展示作者用于控制器、视图和模型的符号。第二个图展示了MVC模式允许的操作和禁止的操作。- 用户与视图对象交互。 - 视图对象和控制器对象可以相互访问调用。 - 不同的控制器对象之间可以相互访问调用。 - 控制器对象可以访问调用模型对象。 - 除了上面这四种访问方式，禁止对象之间的其他通信方法。</description>
    </item>
    
    <item>
      <title>Servlet URL映射模式</title>
      <link>https://mryqu.github.io/post/servlet_url%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Oct 2013 20:56:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/servlet_url%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>Servlet 2.5规范中的映射规则:  完全匹配URL 匹配通配符路径 匹配扩展名 匹配默认servlet  特殊URL模式: url-pattern:/* servlet上的/* 会压制所有其他servlet。无论什么请求都会被该servlet处理。这是一种不好的URL模式。通常，仅将/* 用于过滤器。它能通过调用FilterChain#doFilter()让请求继续由监听另外一个特定URL模式的任何servlet处理。
url-pattern:/ / 不会压制其他servlet。它仅会替换servlet容器内建的默认servlet，用于无法匹配任何已注册servlet的所有请求。一般仅调用在静态资源(CSS/JS/image/etc)和列举目录上。servlet容器内建默认servlet也能处理HTTP缓存请求、媒体（音视频）流和文件重新下载。由于必须负责默认servlet的所有任务，工作量不小，通常不会想要替换默认servlet。这也是一种不好的URL模式。关于为什么JSP页面不会调用这个servlet，是因为servlet容器的内建JSPservlet默认映射到*.jsp并被调用。
url-pattern: 这也有一个空字符串URL模式。当上下文根被请求时会被调用。这不同于welcome-file方法，因为它对任何子目录请求不会被调用，而welcome-file方法对任何局部有效但没有匹配上servlet的请求都会被调用。这更像需要“主页servlet”所要用到的URL模式。.</description>
    </item>
    
  </channel>
</rss>
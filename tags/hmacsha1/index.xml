<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hmacsha1 on Mryqu's Notes</title><link>https://mryqu.github.io/tags/hmacsha1/</link><description>Recent content in hmacsha1 on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 31 Jul 2017 05:46:44 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/hmacsha1/index.xml" rel="self" type="application/rss+xml"/><item><title>[C++] 优化twitcurl项目中的HMAC_SHA1</title><link>https://mryqu.github.io/post/c++_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</link><pubDate>Mon, 31 Jul 2017 05:46:44 +0000</pubDate><guid>https://mryqu.github.io/post/c++_%E4%BC%98%E5%8C%96twitcurl%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84hmac_sha1/</guid><description>twitcurl开源项目中包含SHA1.cpp和HMAC_SHA1.cpp用于计算Twitter认证所需的HMAC-SHA1签名。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC_SHA1需要一个密钥，而SHA1不需要。HMAC_SHA1的公式为：SHA1(Key XOR opad, SHA1(Key XOR ipad, text)) 通过分析oauthlib.cpp和HMAC_SHA1.cpp可知：
对于HMAC_SHA1算法，请求URL及参数信息作为文本输入，ConsumerSecret和AccessTokenSecret组合作为密钥输入； 第一步：如果密钥输入大小超过64字节，则先做一次SHA1获取其摘要用于后继操作；否则直接使用密钥进行后继操作； 第二步：密钥输入（/密钥输入摘要）XOR ipad（即0x36）； 第三步：将上一步的[Key XOR ipad]和文本输入并入缓存AppendBuf1； 第四步：使用上一步生成的缓存AppendBuf1一起进行SHA1以产生内部摘要； 第五步：密钥输入（/密钥输入摘要）XOR opad（即0x5C）； 第六步：将上一步的[Key XOR opad]和第四步产生的内部摘要并入缓存AppendBuf2； 第七步：使用上一步生成的缓存AppendBuf2一起进行SHA1以产生外部摘要。 HMAC_SHA1.h中定义的AppendBuf1和AppendBuf2都有4K大小，合计8K。能不能省点空间呢？
下面我们可以看一个小示例：
char srcTest[] = &amp;#34;abcdef&amp;#34;; int srcTestL = strlen(srcTest); char srcTest1[] = &amp;#34;abc&amp;#34;; int srcTestL1 = strlen(srcTest1); char srcTest2[] = &amp;#34;def&amp;#34;; int srcTestL2 = strlen(srcTest2); unsigned char dst1[20] = &amp;#34;&amp;#34;; unsigned char dst2[20] = &amp;#34;&amp;#34;; CSHA1 sha1A = CSHA1(); sha1A.Reset(); sha1A.Update((UINT_8 *)srcTest, srcTestL); sha1A.</description></item></channel></rss>
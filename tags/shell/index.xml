<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/shell/</link>
    <description>Recent content in Shell on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Dec 2020 12:31:23 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Shell读取文件修改时间并格式化输出</title>
      <link>https://mryqu.github.io/post/shell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</link>
      <pubDate>Wed, 23 Dec 2020 12:31:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</guid>
      <description>最近有一些golang代码实现的功能需要移植到用于低版本AIX的korn shell上去。其中碰到了文件修改时间格式化问题。
通过下面的golang示例代码可知最后需要的是本地时间而不是UTC时间。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; &amp;quot;path/filepath&amp;quot; &amp;quot;time&amp;quot; ) // Infrastructrue var basedir string func init() { exe, err := os.Executable() if err != nil { os.Exit(1) } basedir = filepath.Dir(exe) } func main() { fmt.Printf(&amp;quot;now=%s\n&amp;quot;, time.Now().Format(&amp;quot;02Jan06:15:04:05&amp;quot;)) fmt.Printf(&amp;quot;now.UTC()=%s\n&amp;quot;, time.Now().UTC().Format(&amp;quot;02Jan06:15:04:05&amp;quot;)) fmt.Printf(&amp;quot;now.Local()=%s\n&amp;quot;, time.Now().Local().Format(&amp;quot;02Jan06:15:04:05&amp;quot;)) f, ferr := os.Lstat(basedir) if ferr != nil { fmt.Printf(&amp;quot;Unable to access %s. Skipping...\n&amp;quot;, basedir) os.Exit(1) } mode := f.Mode() if mode&amp;amp;os.ModeSymlink != 0 { fmt.</description>
    </item>
    
    <item>
      <title>Shell逐行读取、解析并export变量实践</title>
      <link>https://mryqu.github.io/post/shell%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90%E5%B9%B6export%E5%8F%98%E9%87%8F%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 15 Dec 2020 12:31:23 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90%E5%B9%B6export%E5%8F%98%E9%87%8F%E5%AE%9E%E8%B7%B5/</guid>
      <description>setenv.yaml示例
MY_HOME: /local/install/myhome MY_JAVA_HOME: $MY_HOME/jre/bin  test.ksh示例
#!/bin/ksh getCustEnv() { # 除了while read 也可以使用for var，但是需要更改IFS为换行符 cat setenv.yaml | while read line; do line=$(echo $line | grep -v &amp;quot;^\s*#&amp;quot; | grep &amp;quot;:&amp;quot;) if [ ! -z $line ]; then key=$(echo $line | cut -d: -f1 | sed -e &#39;s/^\s*//&#39; -e &#39;s/\s*$//&#39;) val=$(echo $line | cut -d: -f2 | sed -e &#39;s/^\s*//&#39; -e &#39;s/\s*$//&#39;) echo &amp;quot;line=$line&amp;quot; echo &amp;quot;key=$key&amp;quot; echo &amp;quot;val=$val&amp;quot; if [ !</description>
    </item>
    
    <item>
      <title>Shell显示彩色文字</title>
      <link>https://mryqu.github.io/post/shell%E6%98%BE%E7%A4%BA%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97/</link>
      <pubDate>Thu, 26 Nov 2020 08:25:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E6%98%BE%E7%A4%BA%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97/</guid>
      <description>昨天学习一下如何使用shell在屏幕显示彩色文字。解决方案有两种：1. 转义字符 2. tput设置文本颜色。
在Linux上这两种方式都正常工作，在FreeBSD上第二种方式不起作用。
代码如下：
#!/bin/ksh println() { printf &amp;quot;%s\n&amp;quot; $* } ########################## # Solution 1 ########################## colorsEnabled() { if [ $TERM == &#39;TERM&#39; ] then return 0 fi return 1 } printlnColor() { c=$1 shift msg=$*; colorsEnabled if [ $? == 1 ] then printf &amp;quot;\033[0;%dm%s\033[0m\n&amp;quot; $c &amp;quot;$msg&amp;quot; else printf &amp;quot;%s\n&amp;quot; &amp;quot;$msg&amp;quot; fi } # Success printlnSuccess() { printlnColor 32 $* } # Warning printlnWarning() { printlnColor 33 $* } # Failure printlnFailure() { printlnColor 31 $* } # Verbose printlnVerbose() { printlnColor 35 $* } # Emphasis printlnEmphasis() { printlnColor 36 $* } # Note printlnNote() { printlnColor 37 $* } ########################## # Solution 2 ########################## println_color() { c=$1 shift msg=$*; tput setaf $c printf &amp;quot;%s\n&amp;quot; &amp;quot;$msg&amp;quot; tput sgr0 } # Success println_success() { println_color 2 $* } # Warning println_warning() { println_color 3 $* } # Failure println_failure() { println_color 1 $* } # Verbose println_verbose() { println_color 5 $* } # Emphasis println_emphasis() { println_color 6 $* } # Note println_note() { println_color 7 $* } printlnEmphasis hahaha 123 echo &amp;quot;=====================&amp;quot; println_emphasis hahaha 123  参考  ANSI Escape sequences</description>
    </item>
    
    <item>
      <title>[HBase] 使用HBase Shell时遇到ZooKeeper exists failed after 4 attempts错误</title>
      <link>https://mryqu.github.io/post/hbase_%E4%BD%BF%E7%94%A8hbase_shell%E6%97%B6%E9%81%87%E5%88%B0zookeeper_exists_failed_after_4_attempts%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 05 Mar 2016 06:21:09 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/hbase_%E4%BD%BF%E7%94%A8hbase_shell%E6%97%B6%E9%81%87%E5%88%B0zookeeper_exists_failed_after_4_attempts%E9%94%99%E8%AF%AF/</guid>
      <description>今天打开HBase Shell就闪退，可是前两天还好好的。错误如下：
2016-03-05 00:32:23,597 ERROR [main] zookeeper.RecoverableZooKeeper: ZooKeeper exists failed after 4 attempts 2016-03-05 00:32:23,598 WARN [main] zookeeper.ZKUtil: hconnection-0x2dba911d0x0, quorum=node50064.mryqu.com:2181,node50069.mryqu.com:2181,node51054.mryqu.com:2181, baseZNode=/hbase Unable to set watcher on znode (/hbase/hbaseid) org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for /hbase/hbaseid at org.apache.zookeeper.KeeperException.create(KeeperException:99) at org.apache.zookeeper.KeeperException.create(KeeperException:51) at org.apache.zookeeper.ZooKeeper.exists(ZooKeeper:1045) at org.apache.hadoop.hbase.zookeeper.RecoverableZooKeeper.exists(RecoverableZooKeeper:220) at org.apache.hadoop.hbase.zookeeper.ZKUtil.checkExists(ZKUtil:419) at org.apache.hadoop.hbase.zookeeper.ZKClusterId.readClusterIdZNode(ZKClusterId:65) at org.apache.hadoop.hbase.client.ZooKeeperRegistry.getClusterId(ZooKeeperRegistry:105) at org.apache.hadoop.hbase.client.ConnectionManager$HConnectionImplementation.retrieveClusterId(ConnectionManager:905) at org.apache.hadoop.hbase.client.ConnectionManager$HConnectionImplementation.&amp;lt;init&amp;gt;(ConnectionManager:648) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl:45) at at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory:238) at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory:218) at org.apache.hadoop.hbase.client.ConnectionFactory.createConnection(ConnectionFactory:119) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.</description>
    </item>
    
    <item>
      <title>[Hive] Hive CLI和Beeline学习</title>
      <link>https://mryqu.github.io/post/hive_hive_cli%E5%92%8Cbeeline%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 28 Jul 2015 05:59:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/hive_hive_cli%E5%92%8Cbeeline%E5%AD%A6%E4%B9%A0/</guid>
      <description>Hive CLI学习 Hive CLI使用手册很简单，但是看完了对有些参数还是不太理解，所以就翻翻Hive CLI源码对照学习吧。
-f和-i选项的区别 Hive CLI使用手册说-i指定的是初始化SQL文件，-f指定的是SQL脚本文件。 通过阅读源码可知，所谓的初始化SQL文件就是你期望每次执行HiveCLI都要在其他操作之前运行的一些SQL命令。执行完初始化SQL，可以接着执行-e选项中的SQL命令、-f选项中的SQL脚本文件或交互输入的命令；而-f选项和-e选项二者只能存在其一，执行完-f选项后退出CLI。
hiverc文件 当没有指定-i参数时，CLI会尝试加载$HIVE_HOME/bin/.hiverc、$HIVE_CONF_DIR/.hiverc和$HOME/.hiverc作为初始化文件。只要存在，这些.hiverc都会被加载执行。 通过CliDriver类的processInitFiles方法可知，执行初始化SQL时始终采用静默模式，即不显示执行进度信息，只显示最后结果；执行-f选项中SQL脚本时是否采用静默模式由-S选项控制。
Hive CLI如何处理shell命令、Hive命令和SQL的？ HiveCLI既可以处理一个SQL脚本文件、也可以处理多个SQL命令。它通过处理多行命令，以&amp;rdquo;;&amp;ldquo;为分隔符，获取单个命令列表。一个单个命令，即可能是&amp;ndash;开头的注释行，也可能是!开头的shell命令，此外SQL命令和Hive自身支持的命令。 - 对于shell命令，Hive CLI是通过ShellCmdExecutor执行的； - 对于SQL命令，Hive CLI是通过org.apache.hadoop.hive.ql.Driver执行的； - 对于Hive命令，HiveCLI通过SetProcessor、ResetProcessor、DfsProcessor、AddResourceProcessor、ListResourceProcessor、DeleteResourceProcessor、CompileProcessor、ReloadProcessor、CryptoProcessor这些处理进行执行。
&amp;ndash;hiveconf、&amp;ndash;define (-d)、&amp;ndash;hivevar之间的关系 首先我们看一下OptionsProcessor类，它通过Apache Commons CLI解析Hive CLI命令参数: - 其process_stage1方法将&amp;ndash;hiveconf参数置入系统属性中，将&amp;ndash;define和&amp;ndash;hivevar参数置入CliSessionState对象的hiveVariables字段 - 其process_stage2方法将&amp;ndash;hiveconf参数置入CliSessionState对象的cmdProperties字段
接下来看一下CliSessionState对象的hiveVariables字段和cmdProperties字段使用情况: - CliDriver.run方法将CliSessionState对象的cmdProperties字段中的键值对覆盖HiveConf对象，然后置入CliSessionState对象的overriddenConfigurations字段 - CliSessionState对象的hiveVariables字段主要用于变量替换，包括替换提示符（CliDriver.run）、替换source命令所跟文件路径及shell命令（CliDriver.processCmd）、替换SQL（Driver.compile）、替换Hive命令（DfsProcessor.run、&amp;hellip;&amp;hellip;）
总之： - &amp;ndash;hiveconf参数在命令行中设置Hive的运行时配置参数，优先级高于hive-site.xml,但低于Hive交互Shell中使用Set命令设置。 - &amp;ndash;define (-d)和&amp;ndash;hivevar没有区别，都是用于变量替换的。
hivehistory文件 Hive CLI会创建$HOME/.hivehistory文件，并在其中记录命令历史记录。
-v参数打印出的SQL语句是变量替换后的吗？ 不是，打印的是原始SQL语句。 看了Hive CLI源码后的疑惑  CliDriver类主函数实例化一个CliDriver对象，而在executeDriver方法中不用自身实例，偏偏又实例化一个CliDriver对象cli来，为啥？ &amp;ndash;hiveconf参数会被放入CliSessionState对象的cmdProperties字段和overriddenConfigurations字段，难道不能合并成一份么？  Hive Beeline学习 BeeLine类的dispatch负责将特定命令行分发给适合的CommandHandler。 - 其中以!起始的SQLLine命令由execCommandWithPrefix方法处理，具体实现见Commands类的同名方法。- 其他命令则由Commands类的sql方法处理
参考 Hive LanguageManual CLI
Hive LanguageManual VariableSubstitution
Hive CLI source code</description>
    </item>
    
    <item>
      <title>Vagrant运行Docker的几种方法</title>
      <link>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 15 Jun 2015 06:15:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/vagrant%E8%BF%90%E8%A1%8Cdocker%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>Vagrant的docker provisioner能够自动安装Docker、下载Docker容器、随着vagrant up命令自动运行容器。 Vagrantfile Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.provision &amp;quot;docker&amp;quot; do |d| d.pull_images &amp;quot;consul&amp;quot; d.run &amp;quot;consul&amp;quot; d.pull_images &amp;quot;rabbitmq&amp;quot; d.run &amp;quot;rabbitmq&amp;quot; end end  仅使用Vagrant的docker provisioner安装Docker，使用脚本下载并运行Docker容器 Vagrantfile # Install Docker config.vm.provision &amp;quot;docker&amp;quot; # Download Docker images, create and start containers config.vm.provision :shell, :path =&amp;gt; &amp;quot;runMyDockers.sh&amp;quot;  runMyDockers.sh #!/bin/bash docker rm -f consul 2&amp;gt;/dev/null docker create --hostname consul --name consul -v /data/consul1:/data --dns 127.0.0.1 --restart always -p 8500:8500 --env CONSUL_OPTIONS=-bootstrap consul:dev docker start consul docker rm -f rabbitmq 2&amp;gt;/dev/null docker create --name rabbitmq --hostname rabbitmq -p 5672:5672 -v /data/rabbitmq:/data --dns 127.</description>
    </item>
    
    <item>
      <title>[HBase] HBase Shell中的put操作解析</title>
      <link>https://mryqu.github.io/post/hbase_hbase_shell%E4%B8%AD%E7%9A%84put%E6%93%8D%E4%BD%9C%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 03 Jan 2014 23:20:51 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/hbase_hbase_shell%E4%B8%AD%E7%9A%84put%E6%93%8D%E4%BD%9C%E8%A7%A3%E6%9E%90/</guid>
      <description>阅读了HBase Shell datatype conversion一贴，感觉下列两个操作结果中的单元格数据值都像是文本类型的：
put &#39;mytable&#39;, &#39;2342&#39;, &#39;cf:c1&#39;, &#39;67&#39; put &#39;mytable&#39;, &#39;2341&#39;, &#39;cf:c1&#39;, 23  预知真相，看来只好看HBase Shell代码了。HBase Shell是Ruby代码，首先找到这些代码的位置：
cd $HBASE_HOME find . -name &#39;*.rb&#39; -print  找到了$HBASE_HOME/lib/ruby/shell/commands/put.rb，其GitHub代码库位置为https://github.com/apache/hbase/commits/master/hbase-shell/src/main/ruby/shell/commands/put.rb：
def command(table, row, column, value, timestamp=nil, args = {}) put table(table), row, column, value, timestamp, args end def put(table, row, column, value, timestamp = nil, args = {}) format_simple_command do table._put_internal(row, column, value, timestamp, args) end end  继而找到了$HBASE_HOME/lib/ruby/hbase/table.rb，其GitHub代码库位置为https://github.com/apache/hbase/blob/master/hbase-shell/src/main/ruby/hbase/table.rb：
def _put_internal(row, column, value, timestamp = nil, args = {}) p = org.</description>
    </item>
    
    <item>
      <title>[HBase] HBase Shell交互实践</title>
      <link>https://mryqu.github.io/post/hbase_hbase_shell%E4%BA%A4%E4%BA%92%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 25 Oct 2013 20:12:48 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/hbase_hbase_shell%E4%BA%A4%E4%BA%92%E5%AE%9E%E8%B7%B5/</guid>
      <description>HBase Shell是对HBase的脚本接口，是一个JRuby REPL(Read-Eval-PrintLoop，“读取-求值-输出”循环)，可以通过脚本访问所有HBase客户端API。
单列族练习 创建表friends $ hbase shell hbase(main):001:0&amp;gt; list TABLE customer 1 row(s) in 0.2050 seconds =&amp;gt; [&amp;quot;customer&amp;quot;, &amp;quot;student&amp;quot;] hbase(main):002:0&amp;gt; create &#39;friends&#39;, &#39;d&#39; 0 row(s) in 1.3350 seconds =&amp;gt; Hbase::Table - friends hbase(main):003:0&amp;gt; list TABLE customer friends 2 row(s) in 0.0060 seconds =&amp;gt; [&amp;quot;customer&amp;quot;, &amp;quot;friends&amp;quot;, &amp;quot;student&amp;quot;]  获得表friends的描述说明 hbase(main):004:0&amp;gt; describe &#39;friends&#39; Table friends is ENABLED friends COLUMN FAMILIES DESCRIPTION {NAME =&amp;gt; &#39;d&#39;, DATA_BLOCK_ENCODING =&amp;gt; &#39;NONE&#39;, BLOOMFILTER =&amp;gt; &#39;ROW&#39;, REPLICATION_SCO PE =&amp;gt; &#39;0&#39;, VERSIONS =&amp;gt; &#39;1&#39;, COMPRESSION =&amp;gt; &#39;NONE&#39;, MIN_VERSIONS =&amp;gt; &#39;0&#39;, TTL =&amp;gt; &#39;FO REVER&#39;, KEEP_DELETED_CELLS =&amp;gt; &#39;FALSE&#39;, BLOCKSIZE =&amp;gt; &#39;65536&#39;, IN_MEMORY =&amp;gt; &#39;false&#39;, BLOCKCACHE =&amp;gt; &#39;true&#39;} 1 row(s) in 0.</description>
    </item>
    
    <item>
      <title>Shell中的source和.命令</title>
      <link>https://mryqu.github.io/post/shell%E4%B8%AD%E7%9A%84source%E5%92%8C.%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 10 Oct 2013 23:11:05 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E4%B8%AD%E7%9A%84source%E5%92%8C.%E5%91%BD%E4%BB%A4/</guid>
      <description>source是csh(C Shell)的内置命令: 标识读入并执行文件中的命令。 这与执行shell脚本是不一样的./script.sh会启动一个新的shell并执行script.sh中的命令。
source [-h] filename [arguments] The shell reads and executes commands from name. The commands are not placed on the history list. If any args are given, they are placed in argv. (+) source commands may be nested; if they are nested too deeply the shell may run out of file descriptors. An error in a source at any level terminates all nested source commands. With -h, commands are placed on the history list instead of being executed, much like `history -L&#39;.</description>
    </item>
    
    <item>
      <title>[HBase] Shell命令</title>
      <link>https://mryqu.github.io/post/hbase_shell%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 27 Sep 2013 19:58:03 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/hbase_shell%E5%91%BD%E4%BB%A4/</guid>
      <description>HBase提供可扩展的基于jruby(JIRB)命令行已用于执行一些命令。HBase命令行主要归为六类。
1) 通用HBase命令 status 显示集群状态。可以为‘summary’、‘simple’或‘detailed’。默认为‘summary’。 用法:
hbase&amp;gt; status hbase&amp;gt; status ‘simple’ hbase&amp;gt; status ‘summary’ hbase&amp;gt; status ‘detailed’  version 输出HBase版本 用法:
hbase&amp;gt; version  whoami 显示当前HBase用户。 用法:
hbase&amp;gt; whoami  2) 表管理命令 alter 修改列族schema；提供表名和指定新列族schema的字典。字典必须包含所要修改的列族名。例如，
对表‘t1’修改或添加列族‘f1’从当前值到最大版本5：
hbase&amp;gt; alter ‘t1’, NAME =&amp;gt; ‘f1’, VERSIONS =&amp;gt; 5  对多个列族进行操作:
hbase&amp;gt; alter ‘t1’, ‘f1’, {NAME =&amp;gt; ‘f2’, IN_MEMORY =&amp;gt; true}, {NAME =&amp;gt; ‘f3’, VERSIONS =&amp;gt; 5}  删除表‘t1’中的列族‘f1’，使用下列方法之一：
hbase&amp;gt; alter ‘t1’, NAME =&amp;gt; ‘f1’, METHOD =&amp;gt; ‘delete’ hbase&amp;gt; alter ‘t1’, ‘delete’ =&amp;gt; ‘f1’  也可以修改诸如MAX_FILESIZE、READONLY、MEMSTORE_FLUSHSIZE、DEFERRED_LOG_FLUSH等表属性，例如将region最大容量设为128MB：</description>
    </item>
    
    <item>
      <title>Shell参数扩展</title>
      <link>https://mryqu.github.io/post/shell%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 23 Jun 2013 18:55:00 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/shell%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95/</guid>
      <description>在hadoop-env.sh中，有如下语句：
export HADOOP_CONF_DIR=${HADOOP_CONF_DIR:-&amp;quot;/etc/hadoop&amp;quot;}  这种用法在Shell Parameter Expansion中进行了详尽的介绍，系统学习一下。 Bash中的$符号的作用是参数替换，将参数名替换为参数所代表的值。对于$来说，大括号是可选的，即$ABC和${ABC}代表同一个参数。但是它可以防止变量被错误解析，比如：${hello}world、${arr[1]}。 参数扩展 下列Bash对参数的测试项为未设置和null。如果略掉冒号，则仅测试未设置。
|表达式|含义 |&amp;mdash;&amp;ndash; |${parameter:-word}|如果parameter没有被声明或者其值为空的话，则表达式替换成word；否则替换成parameter的值。 |${parameter:=word}|如果parameter没有被声明或者其值为空的话，则parameter设为word之后表达式返回parameter的值；否则替换成parameter的值。 |${parameter?word}|如果parameter没有被声明或者其值为空的话，则word被写往标准错误输出和Shell，非可交互的情况下退出；否则替换成parameter的值。 |${parameter:+word}|如果parameter没有被声明或者其值为空的话，则不进行替换；否则替换成parameter的值。 |${!varprefix}
${!varprefix@}|匹配之前所有以varprefix开头进行声明的变量 |${!name[@]}
${!name[]}|如果name是数组对象，返回数组下标列表；如果name以设置但不为数组对象，返回0；否则返回null。
字符串操作 |表达式|含义 |&amp;mdash;&amp;ndash; |${% raw %}{#{% endraw %}parameter}|parameter的长度。 |${parameter:offset}|在parameter中，从位置offset开始提取子串。 |${parameter:offset:length}|在parameter中，从位置offset开始提取长度为length的子串。 |${parameter#word}
${parameter##word}|从头开始扫描parameter对应值，将匹配word正则表达式的字符删除掉#为最短匹配，##为最长匹配。 |${parameter%word}
${parameter%%word}|从尾开始扫描parameter对应值，将匹配word正则表达式的字符删除掉%为最短匹配，%%为最长匹配。 |${parameter/pattern/string}
${parameter//pattern/string}|将parameter对应值的pattern代替为string。/表示只替换一次，//表示全部替换。 |${parameter^pattern}
${parameter^^pattern}|如果pattern是单个字符，将parameter对应值中匹配pattern的字符转换为大写。^表示只转换匹配的首字母，^^表示全部转换。 |${parameter,pattern}
${parameter,,pattern}|如果pattern是单个字符，将parameter对应值中匹配pattern的字符转换为小写。,表示只转换匹配的首字母，,,表示全部转换。</description>
    </item>
    
  </channel>
</rss>
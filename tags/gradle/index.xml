<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gradle on Mryqu's Notes</title><link>https://mryqu.github.io/tags/gradle/</link><description>Recent content in gradle on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 25 Apr 2020 12:01:23 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/gradle/index.xml" rel="self" type="application/rss+xml"/><item><title>Gradle构建ReactJS前端实践</title><link>https://mryqu.github.io/post/gradle%E6%9E%84%E5%BB%BAreactjs%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 25 Apr 2020 12:01:23 +0000</pubDate><guid>https://mryqu.github.io/post/gradle%E6%9E%84%E5%BB%BAreactjs%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/</guid><description>frontend-maven-plugin使用介绍 Spring指南里面有个示例React.js and Spring Data REST ，技术架构为：
后端采用Spring Data Rest 前端采用React.js 构建工具为Maven 下面看一下其pom.xml构建前端的片段:
&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;com.github.eirslett&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;frontend-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.6&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;installDirectory&amp;gt;target&amp;lt;/installDirectory&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;install node and npm&amp;lt;/id&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;install-node-and-npm&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;nodeVersion&amp;gt;v10.11.0&amp;lt;/nodeVersion&amp;gt; &amp;lt;npmVersion&amp;gt;6.4.1&amp;lt;/npmVersion&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;npm install&amp;lt;/id&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;npm&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;arguments&amp;gt;install&amp;lt;/arguments&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;webpack build&amp;lt;/id&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;webpack&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; frontend-maven-plugin 用于构建JavaScript部分：
install-node-and-npm命令将安装node.js及其包管理工具npm到target目录。 （这确保这些二进制文件不在源代码控制范围内并且能被clean命令清除）。 npm命令将执行使用参数install的npm二进制文件，它会安装定义在package.json内的模块。 webpack命令将执行webpack二进制文件，它会基于webpack.config.js打包所有JavaScript代码。 这些步骤依次运行，完成安装node.js、下载JavaScript模块、构建JS部分。
备选Gradle前端构建插件 frontend-maven-plugin 是专用于Maven的插件，在Gradle上并没有直接对应的插件。
我查找后，重点考察了下面两个插件：
Frontend Gradle plugin Gradle Plugin for Node Frontend Gradle plugin实践 代码修改 package.</description></item><item><title>Gradle：解决error: unmappable character for encoding GBK</title><link>https://mryqu.github.io/post/gradle_%E8%A7%A3%E5%86%B3error-unmappable-character-for-encoding-gbk/</link><pubDate>Wed, 20 Nov 2019 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%A7%A3%E5%86%B3error-unmappable-character-for-encoding-gbk/</guid><description>在学习某个项目时，.\gradlew build总是遇到error: unmappable character for encoding GBK。至少确定源文件至少会是UTF8的，所以尝试设置文件编码格式来解决这个问题。
一般使用javac编译和java执行程序时，可以使用：
javac -encoding UTF-8 Test.java java -Dfile.encoding=UTF-8 Test 对于Gradle项目，可以设置gradlew.bat:
set DEFAULT_JVM_OPTS=&amp;#34;-Dfile.encoding=UTF-8&amp;#34; 对于IntelliJ Idea，可在配置文件vmoption文件底部添加一行：
-Dfile.encoding=UTF-8 经过上述尝试，问题依旧存在，仔细一看错误是发生在javadoc任务阶段，一个java文件注释中包含一个字符“ß”导致这个问题的出现。
在build.gradle文件中添加：
javadoc { options.encoding = &amp;#39;UTF-8&amp;#39; } 搞定！！！</description></item><item><title>升级Idea IntelliJ</title><link>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7idea-intellij/</link><pubDate>Thu, 21 Feb 2019 15:30:23 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%8D%87%E7%BA%A7idea-intellij/</guid><description>上次重装机器时，看看自己用的IntelliJ是ideaIU-2016.3.5，而可以升级的最新版本是ideaIU-2018.3.3。犹豫了一下，害怕万一将来跟公司的插件、设置冲突没法用，就没敢升级那么大，只升到ideaIU-2016.3.8而已。
结果从已有项目导入Idea，不仅报错&amp;quot;Failed to notify progress listener.&amp;quot;，而且依赖库也找不到。上网查了查才发现ideaIU-2018.2之前的版本不支持Gradle 5。
好吧，升级到ideaIU-2018.3.4了。</description></item><item><title>[Gradle] 遭遇 Unable to process incoming event 'ProgressComplete' (ProgressCompleteEvent)</title><link>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</link><pubDate>Thu, 30 Nov 2017 06:08:53 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E9%81%AD%E9%81%87_unable_to_process_incoming_event_progresscomplete_progresscompleteevent/</guid><description>最近开始玩一个项目，结果gradle build总是报错：
FAILURE: Build failed with an exception. * What went wrong: Unable to process incoming event &amp;#39;ProgressComplete &amp;#39; (ProgressCompleteEvent) 参考了帖子Build fails with “Unable to process incoming event ‘ProgressComplete ’ (ProgressCompleteEvent)”：
The Workaround: use the --console plain gradle command line switch The Fix: If you use git + git-bash, upgrade to git 2.x.x (2.9.3 is current and works for me) If you use DOS, try increasing your screen buffer size.(mine is 1024 x 1024) 将Git Window从2.</description></item><item><title>玩一下uptodate-gradle-plugin插件</title><link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</link><pubDate>Fri, 03 Mar 2017 05:57:34 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Buptodate-gradle-plugin%E6%8F%92%E4%BB%B6/</guid><description>玩了一下uptodate-gradle-plugin插件，使用这个插件后执行 gradle uptodate 可以看到那些库在Maven Central仓库有新版本，用于辅助判断是否需要更新Java库。 我一般不追新库，所以这个插件对我的用处小，看一看玩一玩，仅此而已。</description></item><item><title>[Gradle] 将多项目转换成Maven项目</title><link>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</link><pubDate>Fri, 02 Sep 2016 05:46:07 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%B0%86%E5%A4%9A%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90maven%E9%A1%B9%E7%9B%AE/</guid><description>手头有一个构建多项目的Gradle构建脚本，但是一个哥们问我能不能换成Maven的，搜到一篇gradle项目与maven项目相互转化，照着实践，证明多项目构建也是可行的。
文件结构介绍 ts-demo目录 setting.gradle build.gradle ts-service目录 build.gradle src目录 ts-webapp目录 build.gradle src目录 ts-demo/setting.gradle rootProject.name = &amp;#39;ts-demo&amp;#39; include &amp;#34;ts-service&amp;#34; include &amp;#34;ts-webapp&amp;#34; project(&amp;#34;:ts-service&amp;#34;).name = &amp;#34;ts-service&amp;#34; project(&amp;#34;:ts-webapp&amp;#34;).name = &amp;#34;ts-webapp&amp;#34; ts-demo/build.gradle buildscript { repositories { mavenCentral() } } allprojects { apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;maven&amp;#39; repositories { mavenCentral() } group = &amp;#39;com.yqu&amp;#39; version = &amp;#39;0.1.0&amp;#39; task writeNewPom { pom { project { inceptionYear &amp;#39;2016&amp;#39; licenses { license { name &amp;#39;The Apache Software License, Version 2.</description></item><item><title>使用Jacoco</title><link>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8jacoco/</link><pubDate>Thu, 16 Jun 2016 05:41:19 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BD%BF%E7%94%A8jacoco/</guid><description>在以前的项目都是用Cobertura做代码覆盖率测试的，这次有机会接触了一下另一个代码覆盖率Java库JaCoco。 JaCoCo拥有友好的授权形式。JaCoCo使用了Eclipse PublicLicense，方便个人用户和商业用户使用。JaCoCo/EclEmma项目除了提供JaCoCo库之外，还提供了Ant任务、Maven插件及EclEmmaEclipse插件，也可以使用JavaAgent技术监控Java程序。很多第三方的工具提供了对Jacoco的集成，如SonarQube、Jenkins、Netbeans、IntelliJIDEA、Gradle等。 JaCoCo包含多种级别的覆盖率计数器，包含指令级覆盖(Instructions，C0coverage)，分支（Branches，C1coverage）、圈复杂度(CyclomaticComplexity)、行覆盖(Lines)、方法覆盖(non-abstractmethods)、类覆盖(classes)。
指令覆盖：计数单元是单个java字节码指令，指令覆盖率提供了代码是否被执行的信息，该指标完全独立与源码格式。 分支覆盖率：度量if和switch语句的分支覆盖情况，计算一个方法里面的总分支数，确定执行和不执行的分支数量。 圈复杂度：在（线性）组合中，计算在一个方法里面所有可能路径的最小数目，缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。 行覆盖率：度量被测程序的每行代码是否被执行，判断标准行中是否至少有一个指令被执行。 方法覆盖率：度量被测程序的方法执行情况，是否执行取决于方法中是否有至少一个指令被执行。 类覆盖率：度量计算class类文件是否被执行。 JaCoCo的一个主要优点是使用Java代理，可以动态（on-the-fly）对类进行插桩。这样代码覆盖率分析简化了预插桩过程，也无需考虑classpath的设置。但是还存在如下不适合动态插桩的情况，需要线下对字节码进行预插桩：
运行环境不支持java agent。 部署环境不允许设置JVM参数。 字节码需要被转换成其他的虚拟机如Android Dalvik VM。 动态修改字节码过程中和其他agent冲突。 示例 我这个懒人还是在Building a Hypermedia-Driven RESTful Web Service示例的基础上稍作修改，熟悉一下JaCoCo的使用。
build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.X.Y.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; apply plugin: &amp;#39;jacoco&amp;#39; jar { baseName = &amp;#39;hello-jacoco&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.</description></item><item><title>Gradle multi-project Builds on HelloSocialMedia</title><link>https://mryqu.github.io/post/gradle_multi-project_builds_on_hellosocialmedia/</link><pubDate>Thu, 22 Oct 2015 05:38:15 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_multi-project_builds_on_hellosocialmedia/</guid><description>尝试对我的HelloSocialMedia演示代码集合使用Gradle的多项目构建，项目结构如下：
HelloSocialMedia/ build.gradle settings.gradle HelloYoutubeAnalytics/ build.gradle HelloGoogleAnalytics/ build.gradle HelloTwitter4J/ build.gradle HelloRestFB/ build.gradle settings.gradle
rootProject.name = &amp;#39;HelloSocialMedia&amp;#39; include &amp;#34;HelloYoutubeAnalytics&amp;#34; include &amp;#34;HelloGoogleAnalytics&amp;#34; include &amp;#34;HelloTwitter4J&amp;#34; include &amp;#34;HelloRestFB&amp;#34; project(&amp;#34;:HelloYoutubeAnalytics&amp;#34;).name = &amp;#34;HelloSocialMedia-YoutubeAnalytics&amp;#34; project(&amp;#34;:HelloGoogleAnalytics&amp;#34;).name = &amp;#34;HelloSocialMedia-GoogleAnalytics&amp;#34; project(&amp;#34;:HelloTwitter4J&amp;#34;).name = &amp;#34;HelloSocialMedia-Twitter4J&amp;#34; project(&amp;#34;:HelloRestFB&amp;#34;).name = &amp;#34;HelloSocialMedia-RestFB&amp;#34; build.gradle
buildscript { repositories { mavenCentral() } } subprojects { apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 } HelloYoutubeAnalytics/build.gradle
jar { baseName = &amp;#39;hello-youbube-analytics&amp;#39; version = &amp;#39;0.</description></item><item><title>[Gradle] 创建含有依赖库的jar文件</title><link>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 18 Oct 2015 05:54:13 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</guid><description>想把自己的Gradle项目打成jar文件，但是&amp;rsquo;gradle build jar&amp;rsquo;生成的jar文件不含依赖库。
按照Gradle – Create a Jar file with dependencies改写了自己的build.gradle，成功包含了依赖库。但是依赖库不再是原来的jar文件，而是以目录的形式存在。
我的build.gradle
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloTwitter4J&amp;#39; version = &amp;#39;0.1.0&amp;#39; } task fatJar(type: Jar) { baseName = &amp;#39;HelloTwitter4J-all&amp;#39; version = &amp;#39;0.1.0&amp;#39; manifest { attributes &amp;#34;Main-Class&amp;#34;: &amp;#34;com.yqu.cdfwebtool.twitter.TwitterRateInfo&amp;#34; } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } with jar } repositories { mavenCentral() } sourceCompatibility = 1.</description></item><item><title>遭遇“GsonFactory cannot be resolved”</title><link>https://mryqu.github.io/post/%E9%81%AD%E9%81%87gsonfactory_cannot_be_resolved/</link><pubDate>Fri, 18 Sep 2015 05:07:00 +0000</pubDate><guid>https://mryqu.github.io/post/%E9%81%AD%E9%81%87gsonfactory_cannot_be_resolved/</guid><description>遭遇GsonFactory无法解析的错误：
...\HelloAnalytics.java:7: error: package com.google.api.client.json.gson does not exist import com.google.api.client.json.gson.GsonFactory; ^ ...\HelloAnalytics.java:28: error: cannot find symbol private static final JsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance(); ^ symbol: variable GsonFactory location: class HelloAnalytics 2 errors :compileJava FAILED 解决方案为在_gradle.build_中添加：
compile &amp;#39;com.google.api-client:google-api-client-gson:1.20.0&amp;#39; exclude module: &amp;#39;httpclient&amp;#39; 参考 GsonFactory cannot be found</description></item><item><title>从Gradle bootRun任务向Spring Boot应用传递环境变量</title><link>https://mryqu.github.io/post/%E4%BB%8Egradle_bootrun%E4%BB%BB%E5%8A%A1%E5%90%91spring_boot%E5%BA%94%E7%94%A8%E4%BC%A0%E9%80%92%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link><pubDate>Tue, 08 Sep 2015 06:32:44 +0000</pubDate><guid>https://mryqu.github.io/post/%E4%BB%8Egradle_bootrun%E4%BB%BB%E5%8A%A1%E5%90%91spring_boot%E5%BA%94%E7%94%A8%E4%BC%A0%E9%80%92%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid><description>尝试了从Gradle bootRun任务中传递环境变量给Spring Boot应用，下面是示例代码和演示。
示例代码 Application.java package com.yqu.gradlesysprop; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; @SpringBootApplication public class Application { private static final Logger log = LoggerFactory.getLogger(Application.class); public static void main(String[] args) { SpringApplication app = new SpringApplication(Application.class); app.setWebEnvironment(false); app.setShowBanner(false); app.run(args); } @Bean public CommandLineRunner demo1() { return (args) -&amp;gt; { log.info(&amp;#34;mryqu.prop.test=&amp;#34;+ System.getProperty(&amp;#34;mryqu.prop.test&amp;#34;)); }; } } build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; jar { baseName = &amp;#39;hello-gradlesysprop&amp;#39; version = &amp;#39;0.</description></item><item><title>Gradle代理配置</title><link>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 31 Aug 2015 05:46:52 +0000</pubDate><guid>https://mryqu.github.io/post/gradle%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</guid><description>HTTP代理配置 gradlew -Dhttp.proxyHost=[myServer] -Dhttp.proxyPort=[myPort] -Dhttp.proxyUser=[myUser] -Dhttp.proxyPassword=[myPassword] HTTPS代理配置 gradlew -Dhttps.proxyHost=[myServer] -Dhttps.proxyPort=[myPort] -Dhttps.proxyUser=[myUser] -Dhttps.proxyPassword=[myPassword]</description></item><item><title>[Gradle] 列举插件</title><link>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 27 Jul 2015 06:17:30 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%97%E4%B8%BE%E6%8F%92%E4%BB%B6/</guid><description>下列方法可以列举出当前build.gradle牵涉的插件:
project.plugins.each { println it }</description></item><item><title>Gradle Docker Plugin介绍</title><link>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 14 Jul 2015 05:57:33 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_docker_plugin%E4%BB%8B%E7%BB%8D/</guid><description>gradle-docker-plugin gradle-docker-plugin是由《Gradle实战》作者BenjaminMuschko实现的Gradle插件，用来管理Docker镜像和容器。gradle-docker-plugin实际上包括两个插件：
com.bmuschko.docker-remote-api:提供通过远程API与Docker进行交互的定制任务 com.bmuschko.docker-java-application:为Java应用创建和上传Docker镜像 build.gradle buildscript { repositories { jcenter() } dependencies { classpath &amp;#39;com.bmuschko:gradle-docker-plugin:2.4.1&amp;#39; } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-java-application&amp;#39; apply plugin: &amp;#39;com.bmuschko.docker-remote-api&amp;#39; 参考 GitHub：bmuschko/gradle-docker-plugin</description></item><item><title>执行Gradle artifactoryPublish任务时碰到HTTP 409 Conflict错误</title><link>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</link><pubDate>Mon, 13 Jul 2015 06:10:00 +0000</pubDate><guid>https://mryqu.github.io/post/%E6%89%A7%E8%A1%8Cgradle_artifactorypublish%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%A2%B0%E5%88%B0http_409_conflict%E9%94%99%E8%AF%AF/</guid><description>这篇博文算是《尝试Artifactory》的姐妹篇。我打算将《尝试Artifactory》中的&amp;rsquo;libs-snapshot-local&amp;rsquo;和&amp;rsquo;libs-snapshot&amp;rsquo;换成&amp;rsquo;libs-release-local&amp;rsquo;和&amp;rsquo;libs-release&amp;rsquo;，以便将我的构件发布到发布版仓库里。结果遭遇如下错误：
C:\test123\HelloArtifactory&amp;gt;gradlew artifactoryPublish [buildinfo] Not using buildInfo properties file for this build. :generatePomFileForMavenJavaPublication :compileJava 查看Artifactory日志，才知道根本原因在于创建的是SNAPSHOT而libs-release-local只处理发布版构建。The repository &amp;rsquo;libs-release-local&amp;rsquo; rejected the artifact&amp;rsquo;libs-release-local:com/yqu/HelloArtifactory/0.1.0-SNAPSHOT/HelloArtifactory-0.1.0-SNAPSHOT.jar&amp;rsquo;due to its snapshot/release handling policy。 解决方案有如下两种：
修改libs-release-local属性，勾选Handle Snapshots选择框（工作流不正规啦） 将gradle.properties中的version由0.1.0-SNAPSHOT改成0.1.0即可</description></item><item><title>Gradle Git Plugin介绍</title><link>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</link><pubDate>Sun, 12 Jul 2015 21:15:17 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_git_plugin%E4%BB%8B%E7%BB%8D/</guid><description>Grgit和gradle-git Git是一个很流行的分布式版本管理工具。能在构建过程中与Git进行交互，可以提供更强大和更一致的结果。
JGit提供了与Git仓库交互的强大JavaAPI。然而，在Groovy上下本使用它会笨重，需要在所要执行的表达式包一堆换七八糟的东东。Grgit是Andre wOberstar实现的JGit封装器，为基于Groovy的工具与Git仓库交互提供了更简洁流畅的API。 gradle-git同样是由Andrew Oberstar实现的一系列Gradle插件：
org.ajoberstar.grgit - 提供一个Grgit实例，允许与Gradle项目所在的Git仓库交互 org.ajoberstar.github-pages - 向Github仓库的gh-pages分支发布文件 org.ajoberstar.release-base -提供用于从项目状态和所在Git仓库推断当前项目版本和创建新版本的通用结构 org.ajoberstar.release-opinion -用于org.ajoberstar.release-base的默认选项，遵从语义版本控制（Semantic Versioning）下面是一个Gradle任务示例，用于从Git仓库克隆项目。 build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;org.ajoberstar:gradle-git:1.2.0&amp;#39; } } import org.ajoberstar.gradle.git.tasks.* task cloneGitRepo(type: GitClone) { def destination = file(&amp;#34;destination_folder&amp;#34;) uri = &amp;#34;your_git_repo_uri&amp;#34; destinationPath = destination bare = false enabled = !destination.exists() //to clone only once } 参考 GitHub：ajoberstar/gradle-git
GitHub：ajoberstar/grgit</description></item><item><title>尝试Artifactory</title><link>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95artifactory/</link><pubDate>Tue, 30 Jun 2015 06:28:36 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%B0%9D%E8%AF%95artifactory/</guid><description>Artifactory简介 首先，JFrogArtifactory是统一构件仓库管理器，全面支持任何语言或技术创建的软件包。Artifactory是一个适合企业的仓库管理器，支持安全、集群和高可用的Docker注册。与所有主流CI/CD和DevOps工具进行集成，Artifactory提供了端到端的自动化的解决方案用以追踪从开发阶段到生产环境阶段中的构件。 安装Artifactory 在https://www.jfrog.com/open-source/下载开源版的jFrogArtifactory，按照JFrog Artifactory用户指南即可轻松安装和使用。 发布构件 使用Gradle构建脚本生成器 gradle.properties artifactory_contextUrl=http://localhost:8081/artifactory artifactory_user=admin artifactory_password=password group = com.yqu version = 0.1.0-SNAPSHOT description = Hello artifactory build.gradle buildscript { repositories { maven { url &amp;#34;https://plugins.gradle.org/m2/&amp;#34; } } dependencies { //Check for the latest version here: // http://plugins.gradle.org/plugin/com.jfrog.artifactory classpath &amp;#34;org.jfrog.buildinfo:build-info-extractor-gradle:+&amp;#34; } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;maven-publish&amp;#39; apply plugin: &amp;#34;com.jfrog.artifactory&amp;#34; jar { baseName = &amp;#39;HelloArtifactory&amp;#39; } artifacts { archives jar } publishing { publications { maven { from components.</description></item><item><title>[Gradle] buildScript块与allprojects块及根级别的repositories区别</title><link>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 29 Jun 2015 00:03:59 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_buildscript%E5%9D%97%E4%B8%8Eallprojects%E5%9D%97%E5%8F%8A%E6%A0%B9%E7%BA%A7%E5%88%AB%E7%9A%84repositories%E5%8C%BA%E5%88%AB/</guid><description>一直对为什么buildScript块里定义了repositories而allprojects段或根还定义repositories没有思考过，偶然有了念头想要探究一下。
build.gradle：
buildscript { repositories { ... } dependencies { ... } } allprojects { repositories { ... } dependencies { ... } }repositories { ... } dependencies { ... } buildScript块主要是为了Gradle脚本自身的执行，获取脚本依赖插件。我在写的一篇博客《尝试Artifactory》中Gradle脚本需要com.jfrog.artifactory插件才能执行成功，而这个插件是从URL为https://plugins.gradle.org/m2/的Maven仓库获得。 根级别的repositories主要是为了当前项目提供所需依赖包，比如log4j、spring-core等依赖包可从mavenCentral仓库获得。 allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。而子项目可以配置自己的repositories以获取自己独需的依赖包。
参考 What&amp;rsquo;s the difference between buildscript and allprojects in build.gradle?
Gradle buildscript dependencies
Gradle: Project</description></item><item><title>Spring Boot Example：Rest Exception Handling</title><link>https://mryqu.github.io/post/spring_boot_examplerest_exception_handling/</link><pubDate>Tue, 02 Jun 2015 00:14:40 +0000</pubDate><guid>https://mryqu.github.io/post/spring_boot_examplerest_exception_handling/</guid><description>要给同事做个Rest异常处理的演示，顺便用用Spring Boot和Gradle构建。 首先新建一个项目：rest-exception-handling。
rest-exception-handling/src/main/java/com/yqu/rest目录 Application.java package com.yqu.rest; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } GreetingController.java package com.yqu.rest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; @RestController public class GreetingController { @Autowired private GreetingService service; @RequestMapping(value = &amp;#34;/&amp;#34;, method = RequestMethod.GET) public ModelAndView home(Model m){ System.out.println(&amp;#34;home&amp;#34;); return new ModelAndView(&amp;#34;index&amp;#34;); } @RequestMapping(value = &amp;#34;/greeting&amp;#34;, method = RequestMethod.GET) public @ResponseBody GreetingVO greeting(@RequestParam(value=&amp;#34;name&amp;#34;) String name) throws GreetingException { System.</description></item><item><title>玩一下gradle-jvmsrc-plugin</title><link>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</link><pubDate>Wed, 27 May 2015 05:51:01 +0000</pubDate><guid>https://mryqu.github.io/post/%E7%8E%A9%E4%B8%80%E4%B8%8Bgradle-jvmsrc-plugin/</guid><description>玩了一下gradle-jvmsrc-plugin插件，使用这个插件后执行gradlecreateJvmSrcDirs可以根据Gradle项目的JVM语言插件（(java、groovy、scala、android等），自动创建默认的源代码、测试和资源包目录。例如：
src/main/resources src/main/java/ src/main/groovy/ src/test/java/ src/test/groovy/ src/test/resources 刚上手总是报错，看了一下CreateJvmSourceDirs.groovy，定位到packageToDirectoryPath方法：
* What went wrong: Execution failed for task &amp;#39;:HelloJvmsrc:createJvmSrcDirs&amp;#39;. &amp;gt; character to be escaped is missing 按照如下gradle-jvmsrc-plugin的说明，要配置基础包名。可是真按它介绍的带有.分割的包名就会出错，简单改成&amp;quot;com&amp;quot;这种没有.分割的包名就可以避免错误。
jvmsrc { packageName &amp;#34;com.mycompany.myproject.mymodule&amp;#34; } 此外，gradle-jvmsrc-plugin对空目录默认生成.gitkeep文件。 总体来说，用处不是很大，可以偷点懒！</description></item><item><title>[Gradle] 在子项目中共享项目属性</title><link>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</link><pubDate>Fri, 22 May 2015 06:09:34 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%9C%A8%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7/</guid><description>build.gradle:
buildscript { repositories { mavenCentral() } } subprojects { apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 ext { HadoopVersion = &amp;#39;2.7.x&amp;#39; JUnitVersion = &amp;#39;4.11&amp;#39; ...... } } HelloHadoopClient/build.gradle：
jar { baseName = &amp;#39;hello-hadoopclient&amp;#39; version = &amp;#39;0.1.0&amp;#39; } dependencies { compile &amp;#34;org.apache.hadoop:hadoop-common:${HadoopVersion}&amp;#34; testCompile &amp;#34;junit:junit:${JUnitVersion}&amp;#34; } HelloMapReduce/build.gradle：
jar { baseName = &amp;#39;hello-mapreduce&amp;#39; version = &amp;#39;0.1.0&amp;#39; } dependencies { compile &amp;#34;org.</description></item><item><title>Git+Gerrit+Gradle+Jenkins持续集成</title><link>https://mryqu.github.io/post/git+gerrit+gradle+jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link><pubDate>Sun, 26 Apr 2015 07:45:11 +0000</pubDate><guid>https://mryqu.github.io/post/git+gerrit+gradle+jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid><description>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile）在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。
Gerrit Gerrit是基于GWT web应用的开源代码审查系统，为使用Git版本控制系统的项目提供在线代码审查。安卓开源项目（AOSP）用其来管理多代码库的庞大项目。Gerrit通过在自身代码库跟踪提交的Git变更集来提供代码审查的。它并排显示新旧文件，让审查者更容易对变更进行审查，并允许审查者添加内嵌注释。 提交的变更既可以被Jenkins这样的自动系统进行审查，也可以由同事进行审查。每个审查者检查代码变更、添加注释，然后将变更标记为“在我看来代码不错”(“没有打分”或“我期望你不要提交代码”)。验证者(例如Jenkins或其他人)通过构建和测试代码来验证变更。如果他们认为代码可行，则设置“在我看来代码不错”标记，Gerrit将尝试将变更合并到公开的“权威”代码库。文章Life of a Patch描述了这一工作流: Gradle 在Java构建工具的世界里，先有了Ant，然后有了Maven。Maven的CoC（约定优于配置）、依赖管理以及项目构建规则重用性等特点，让Maven几乎成为Java构建工具的事实标准。然而，冗余的依赖管理配置、复杂并且难以扩展的构建生命周期，都成为使用Maven的困扰。Gradle作为新的构建工具，是基于Groovy语言的构建工具，既保持了Maven的优点，又通过使用Groovy定义的DSL克服了Maven中使用XML繁冗以及不灵活等缺点，支持依赖管理和多项目，而且它有非常完善的说明文档。目前，SpringSource、Hibernate等都采用Gradle来构建。
Jenkins Jenkins，之前叫做Hudson，是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时Jenkins能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。Jenkins通过Gerrit触发器插件可在新的Gerrit补丁集创建时开始使用Gerrit代码库中的代码进行构建项目，通过Gradle插件调用Gradle构建脚本，以帮助变更验证。
参考 Git权威指南-第5篇-第32章 Gerrit 代码审核服务器 Git+Gerrit+Gradle+Jenkins持续集成设置</description></item><item><title>[Gradle] 输出依赖包</title><link>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</link><pubDate>Thu, 16 Apr 2015 06:13:52 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</guid><description>下面我以https://spring.io/guides/gs/spring-boot/中的gs-spring-boot项目为例，使用Gradle输出依赖包。
首先对build.gradle做如下修改：
buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; jar { baseName = &amp;#39;gs-spring-boot&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 task copyToLib(type: Copy) { print configurations into &amp;#34;$buildDir/dep-libs&amp;#34; from configurations.runtime } build.dependsOn(copyToLib) dependencies { compile(&amp;#34;org.springframework.boot:spring-boot-starter-web&amp;#34;) // tag::actuator[] compile(&amp;#34;org.springframework.boot:spring-boot-starter-actuator&amp;#34;) // end::actuator[] // tag::tests[] testCompile(&amp;#34;org.springframework.boot:spring-boot-starter-test&amp;#34;) // end::tests[] } 首先可以在命令行中看到：</description></item><item><title>[Gradle] 执行Java类</title><link>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</link><pubDate>Wed, 15 Apr 2015 18:32:08 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E6%89%A7%E8%A1%8Cjava%E7%B1%BB/</guid><description>需求 我想用Gradle脚本执行下列Java类Hello123.java：
import java.util.Arrays; public class Hello123 { public static void main(String[] args) { System.out.println(&amp;#34;args:&amp;#34;+ Arrays.toString(args)); } } 测试一：创建execute任务 build.gralde apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; task execute(type: { main = System.getProperty(&amp;#34;exec.mainClass&amp;#34;) classpath = sourceSets.main.runtimeClasspath systemProperties System.getProperties() if(System.getProperty(&amp;#34;exec.args&amp;#34;)) args System.getProperty(&amp;#34;exec.args&amp;#34;).split() } sourceCompatibility = 1.8 targetCompatibility = 1.8 测试结果 测试二：重写run任务 build.gralde apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#34;application&amp;#34; mainClassName = &amp;#34;NonExistentClass&amp;#34; task run (type: { main = System.</description></item><item><title>[Gradle] 阻止build任务执行测试任务</title><link>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</link><pubDate>Tue, 14 Apr 2015 05:53:30 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E9%98%BB%E6%AD%A2build%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1/</guid><description>在执行gradle build时想要阻止执行测试任务，方法如下：
第一种方法：如Gradle用户指南的14.8 Skipping tasks所说，在build.gradle里设置&amp;quot;test.enabled=false&amp;quot;，执行gradle build 第二种方法：在build.gradle里设置&amp;quot;check.dependsOn.remove(test)&amp;quot;，执行gradle build 第三种方法：执行gradle build -x test</description></item><item><title>[Gradle] 强制重新下载依赖</title><link>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</link><pubDate>Mon, 13 Apr 2015 05:49:35 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%BC%BA%E5%88%B6%E9%87%8D%E6%96%B0%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</guid><description>强制Gradle重新下载依赖的方式有两种：
在Gradle命令中加入&amp;ndash;refresh-dependencies选项。该选项会让Gradle忽略已解析模块和构件的所有缓存项，对所配置的仓库重新进行解析，动态计算版本、更新模块和下载构件。 删除Gralde的缓存目录~/.gradle/caches。这个有点过于粗暴。 示例：
gradlew clean --refresh-dependencies build bootRun</description></item><item><title>学习Gradle</title><link>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</link><pubDate>Sun, 12 Apr 2015 00:08:35 +0000</pubDate><guid>https://mryqu.github.io/post/%E5%AD%A6%E4%B9%A0gradle/</guid><description>当前参与的SAS Workflow2.0原型开发项目，美国那边的项目组经营将代码编译脚本从Ant切换成Gradle了。此外我司已经在去年就将Gradle列入了技术雷达的正式采用象限，感觉有必要学习一下Gradle，扩充自己的开发能力。 Gradle官网上提供的图书信息链接中有两本免费O&amp;rsquo;Reilly出版社图书：
Building and Testing With Gradle Gradle Beyond the Basics一般软件官网文档质量不错的情况下，我优先阅读最新的官网文档，所以我先看了《Gradle入门》和《Gradle用户指南》。 参考 Gradle官网 Gradle文档 Spring提供的Gradle入门 Gradle用户指南 Groovy官网 Groovy++ Java Build Tools: Ant vs Maven vs Gradle</description></item><item><title>[Gradle] 设置项目属性的三种方式</title><link>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Tue, 07 Apr 2015 05:36:16 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>命令行 gradle bootRun -PyquPropKey=yquPropValue build.properties yquPropKey=yquPropValue gradle.properties 添加ext块：
ext { yquPropKey=yquPropValue }</description></item><item><title>[Gradle] 在build.gradle中添加本地包依赖</title><link>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</link><pubDate>Wed, 16 Apr 2014 22:17:45 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</guid><description>一直在Gradle中用的依赖包都是来自仓库，头一次添加本地包依赖。
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloAlgs&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { runtime files(&amp;#39;libs/algs4.jar&amp;#39;) } task wrapper(type: Wrapper) { gradleVersion = &amp;#39;2.3&amp;#39; }</description></item></channel></rss>
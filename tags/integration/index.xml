<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Integration on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/integration/</link>
    <description>Recent content in Integration on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 03 Aug 2016 06:10:01 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/integration/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Spark]Spark和Hive集成</title>
      <link>https://mryqu.github.io/post/spark_spark%E5%92%8Chive%E9%9B%86%E6%88%90/</link>
      <pubDate>Wed, 03 Aug 2016 06:10:01 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/spark_spark%E5%92%8Chive%E9%9B%86%E6%88%90/</guid>
      <description>在前一博文[Spark] Spark2集群安装实践中安装了Spark后，发现和Hive还没有集成在一起，此外Hive自己也不好使了。
hadoop@node50064:~$hive ls: cannot access /usr/local/spark/lib/spark-assembly-*.jar: No such file or directory .................  原来Spark assemblyjar在Spark2中已经不存在了，而Hive脚本判断系统存在Spark后仍要使用，需要将$HIVE_HOME/bin/hive中的这部分代码注释掉：
# add Spark assembly jar to the classpath #if [[ -n &amp;quot;$SPARK_HOME&amp;quot; ]] #then # sparkAssemblyPath=`ls ${SPARK_HOME}/lib/spark-assembly-*.jar` # CLASSPATH=&amp;quot;${CLASSPATH}:${sparkAssemblyPath}&amp;quot; #fi  至此，Hive本身工作正常。下面开始Spark和Hive集成配置工作。 - Spark SQL CLI需要使用到Hive Metastore，因此需要在[Hive] 安装Hive 1.2.x的基础上继续修改$HIVE_HOME/conf/hive-site.xml：- 将$HIVE_HOME/conf/hive-site.xml软连接到$SPARK_HOME/conf目录中:
 cd $SPARK_HOME/conf ln -s $HIVE_HOME/conf/hive-site.xml   启动Hive Metastore和HiveServer2：  hive --service metastore &amp;amp; hive --service hiveserver2 &amp;amp;   下面进行验证工作：
hadoop@node50064:~$ hive hive&amp;gt; use default; OK Time taken: 0.</description>
    </item>
    
    <item>
      <title>了解一下Gerrit与BitBucket集成</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bgerrit%E4%B8%8Ebitbucket%E9%9B%86%E6%88%90/</link>
      <pubDate>Sun, 17 May 2015 00:18:31 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bgerrit%E4%B8%8Ebitbucket%E9%9B%86%E6%88%90/</guid>
      <description>在《Gerrit插件配置》中没有找到有关BitBucket的信息。 通过https://marketplace.atlassian.com/search?q=Gerrit在Atlassian市场搜到几个跟Gerrit相关的控件，不过都是为JIRA/BitBucket/Bambooserve增加类似Gerrit的工作流的功能。 结论就是：目前没法用Gerrit为BitBucket进行代码审查。</description>
    </item>
    
    <item>
      <title>了解用于Gerrit代码审查的GitHub插件</title>
      <link>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E7%94%A8%E4%BA%8Egerrit%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84github%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 16 May 2015 07:28:57 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E4%BA%86%E8%A7%A3%E7%94%A8%E4%BA%8Egerrit%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84github%E6%8F%92%E4%BB%B6/</guid>
      <description>在网上看到了GitHub plugin for Gerrit，学习一下。
对比GitHub与Gerrit的代码审查机制 GitHub一派的代码审查机制主要通过fork一个远程分支，进行本地修改并提交到远程分支，然后通过PULL REQUEST来请求代码审查及合并回原上游远程分支。 Gerrit一派的代码审查机制主要通过checkout一个分支(refs/for/master)。从Gerrit克隆获得本地分支，进行修改并提交到Gerrit的refs/for/master分支，中间还可以通过Amend commit修改之前的提交，经过评审人批准后，代码会提交到&amp;rdquo;权威&amp;rdquo;仓库。 GitHub BitBucket GitLab Gitorious阵营 这一派的PULL REQUEST基于两个分支的合并，注释可能会乱一点，有点惹人烦。不考虑将所有原子/相关修改作为一个提交。除了写注释无法知道审查打分情况。 Gerrit GitBlit阵营 这一派的每个提交有其审查结果，可以清晰查看以往历史。Gerrit审查可以强制成仅接受快进（fast-worward）或可rebase的提交。 用于Gerrit代码审查的GitHub插件 https://gerrit-review.googlesource.com/#/admin/projects/plugins/github 优点： - 引入Pull Requests -&amp;gt;Gerrit改动/主题 - 使用Gerrit认证规则重用GitHub账户 - 复制: 代码继续存在于http://github.com 仓库 - 防止不可管理的fork激增 - 避免GitHub垃圾邮件 -&amp;gt;每个改动一封电邮
第一步：为Gerrit在GitHub上注册新的OAUTH应用 第二步：获取Client ID和Client Secret 第三步：下载并安装Gerrit 下载地址：https://gerrit-releases.storage.googleapis.com/index.html 为了确保安装成功，首先使用DEVELOPMENT_BECOME_ANY_ACCOUNT作为认证方式确保能登录进Gerrit。 使用Git Bash启动Gerrit。 登陆后，可以查看到当前安装的插件。 第四步：构建GitHub插件 git clone https://gerrit.googlesource.com/plugins/github &amp;amp;&amp;amp; cd github mvn install  第五步：安装OAUTH过滤器和GitHub插件 第六步：重新配置Gerrit 第七步：完成GitHub认证 参考 GitHub plugin for Gerrit
Gerrit vs Github: for code review and codebase management</description>
    </item>
    
    <item>
      <title>将GoJS和Activiti Explorer熬成一锅粥</title>
      <link>https://mryqu.github.io/post/%E5%B0%86gojs%E5%92%8Cactiviti_explorer%E7%86%AC%E6%88%90%E4%B8%80%E9%94%85%E7%B2%A5/</link>
      <pubDate>Fri, 27 Feb 2015 20:05:26 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/%E5%B0%86gojs%E5%92%8Cactiviti_explorer%E7%86%AC%E6%88%90%E4%B8%80%E9%94%85%E7%B2%A5/</guid>
      <description>熬粥时，一开始创建一个跟editor-app平行的独立目录gojs-editor-app，结果我的Chrome浏览器报“Resourceinterpreted as stylesheet but transferred with MIME typetext/html”错误，GoJS的所有Javascript和stylesheet文件(例如BPMN.js和BPMN.css)都被加了料从Tomcat发给浏览器变成了html格式。 看了下面两个帖子，没有丝毫头绪： http://stackoverflow.com/questions/3467404/chrome-says-resource-interpreted-as-script-but-transferred-with-mime-type-tex
thttp://stackoverflow.com/questions/22631158/resource-interpreted-as-stylesheet-but-transferred-with-mime-type-text-html-see
搜了一下ActivitiExplorer的配置，看到org.activiti.explorer.filter.ExplorerFilter里有六个路径(&amp;ldquo;/ui&amp;rdquo;、&amp;rdquo;/VAADIN&amp;rdquo;、&amp;rdquo;/modeler.html&amp;rdquo;、&amp;rdquo;/editor-app&amp;rdquo;、&amp;rdquo;/service&amp;rdquo;、&amp;rdquo;/diagram-viewer&amp;rdquo;)走了特殊的过滤器。只好将GoJS的内容都转到Activiti已有的editor-app目录，这下齐活了。</description>
    </item>
    
  </channel>
</rss>
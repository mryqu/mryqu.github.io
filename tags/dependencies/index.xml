<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dependencies on Mryqu's Notes</title><link>https://mryqu.github.io/tags/dependencies/</link><description>Recent content in dependencies on Mryqu's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 16 Oct 2017 15:47:55 +0000</lastBuildDate><atom:link href="https://mryqu.github.io/tags/dependencies/index.xml" rel="self" type="application/rss+xml"/><item><title>[Golang] Glide的安装和使用</title><link>https://mryqu.github.io/post/golang_glide/</link><pubDate>Mon, 16 Oct 2017 15:47:55 +0000</pubDate><guid>https://mryqu.github.io/post/golang_glide/</guid><description>不论是开发Java还是你正在学习的Golang，都会遇到依赖管理问题。Java有牛逼轰轰的Maven和Gradle。 Golang亦有Godep、Govendor、Glide、dep等等。本文主要给大家介绍Glide。 Glide 是Golang的包管理工具，是为了解决Golang依赖问题的。 为什么需要Glide ？ 原因很简单，Go语言原生包管理的缺陷。罗列一下Golang的get子命令管理依赖有很多大缺陷：
能拉取源码的平台很有限，绝大多数依赖的是 github.com 不能区分版本，以至于令开发者以最后一项包名作为版本划分 依赖 列表/关系 无法持久化到本地，需要找出所有依赖包然后一个个 go get 只能依赖本地全局仓库（GOPATH/GOROOT），无法将库放置于项目局部仓库（$PROJECT_HOME/vendor） Glide 是有下列几大主要功能：
持久化依赖列表至配置文件中，包括依赖版本（支持范围限定）以及私人仓库等 持久化关系树至 lock 文件中（类似于 yarn 和 cargo），以重复拉取相同版本依赖 兼容 go get 所支持的版本控制系统：Git, Bzr, HG, and SVN 支持 GO15VENDOREXPERIMENT 特性，使得不同项目可以依赖相同项目的不同版本 可以导入其他工具配置，例如： Godep, GPM, Gom, and GB Glide 在Mac或Linux上是很容易安装的，但是在Win10 x64上据说最新版有问题。详见https://github.com/Masterminds/glide/issues/873 。 想多了没用，还是实干吧。从https://github.com/Masterminds/glide/releases 上下载了glide-v0.13.0-windows-amd64.zip，里面就一个glide.exe。 将glide.exe放入%GOPATH%/bin下，然后将%GOPATH%/bin加入环境变量Path中，由于我的Go版本是1.9所以GO15VENDOREXPERIMENT环境变量就不用管了。执行 glide --version ，开头没问题呀！ 进入我的项目目录%GOPATH%/src/helloglide，执行下列命令：
glide create #创建新的工作空间，生成glide.yaml glide get github.com/pborman/uuid #获取uui包 glide install #建立glide.lock版本 go build #构建项目 glide list #列举项目导入的所有包 INSTALLED packages: github.</description></item><item><title>[Gradle] 创建含有依赖库的jar文件</title><link>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 18 Oct 2015 05:54:13 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84jar%E6%96%87%E4%BB%B6/</guid><description>想把自己的Gradle项目打成jar文件，但是&amp;rsquo;gradle build jar&amp;rsquo;生成的jar文件不含依赖库。
按照Gradle – Create a Jar file with dependencies改写了自己的build.gradle，成功包含了依赖库。但是依赖库不再是原来的jar文件，而是以目录的形式存在。
我的build.gradle
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloTwitter4J&amp;#39; version = &amp;#39;0.1.0&amp;#39; } task fatJar(type: Jar) { baseName = &amp;#39;HelloTwitter4J-all&amp;#39; version = &amp;#39;0.1.0&amp;#39; manifest { attributes &amp;#34;Main-Class&amp;#34;: &amp;#34;com.yqu.cdfwebtool.twitter.TwitterRateInfo&amp;#34; } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } with jar } repositories { mavenCentral() } sourceCompatibility = 1.</description></item><item><title>[Gradle] 输出依赖包</title><link>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</link><pubDate>Thu, 16 Apr 2015 06:13:52 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E8%BE%93%E5%87%BA%E4%BE%9D%E8%B5%96%E5%8C%85/</guid><description>下面我以https://spring.io/guides/gs/spring-boot/中的gs-spring-boot项目为例，使用Gradle输出依赖包。
首先对build.gradle做如下修改：
buildscript { repositories { mavenCentral() } dependencies { classpath(&amp;#34;org.springframework.boot:spring-boot-gradle-plugin:1.2.2.RELEASE&amp;#34;) } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; apply plugin: &amp;#39;spring-boot&amp;#39; jar { baseName = &amp;#39;gs-spring-boot&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 task copyToLib(type: Copy) { print configurations into &amp;#34;$buildDir/dep-libs&amp;#34; from configurations.runtime } build.dependsOn(copyToLib) dependencies { compile(&amp;#34;org.springframework.boot:spring-boot-starter-web&amp;#34;) // tag::actuator[] compile(&amp;#34;org.springframework.boot:spring-boot-starter-actuator&amp;#34;) // end::actuator[] // tag::tests[] testCompile(&amp;#34;org.springframework.boot:spring-boot-starter-test&amp;#34;) // end::tests[] } 首先可以在命令行中看到：</description></item><item><title>[Gradle] 在build.gradle中添加本地包依赖</title><link>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</link><pubDate>Wed, 16 Apr 2014 22:17:45 +0000</pubDate><guid>https://mryqu.github.io/post/gradle_%E5%9C%A8build.gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%8C%85%E4%BE%9D%E8%B5%96/</guid><description>一直在Gradle中用的依赖包都是来自仓库，头一次添加本地包依赖。
buildscript { repositories { mavenCentral() } } apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;eclipse&amp;#39; apply plugin: &amp;#39;idea&amp;#39; jar { baseName = &amp;#39;HelloAlgs&amp;#39; version = &amp;#39;0.1.0&amp;#39; } repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { runtime files(&amp;#39;libs/algs4.jar&amp;#39;) } task wrapper(type: Wrapper) { gradleVersion = &amp;#39;2.3&amp;#39; }</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Streaming on Mryqu&#39;s Notes</title>
    <link>https://mryqu.github.io/tags/streaming/</link>
    <description>Recent content in Streaming on Mryqu&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 13 Dec 2015 06:02:47 +0000</lastBuildDate>
    
	<atom:link href="https://mryqu.github.io/tags/streaming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>FileUpload Streaming</title>
      <link>https://mryqu.github.io/post/fileupload_streaming/</link>
      <pubDate>Sun, 13 Dec 2015 06:02:47 +0000</pubDate>
      
      <guid>https://mryqu.github.io/post/fileupload_streaming/</guid>
      <description>最近看一下org.apache.tomcat.util.http.fileupload，这个包是从commons-fileupload和commons-io复制而来，为了避免冲突而改名。 Apache Commons FileUpload是用于servlet和web应用的健壮、高性能文件上传库，它支持 RFC 1867和RFC2047。 传统的文件上传API假设文件在被用户访问前必须存储在某处，这种途径便捷、易于访问，但是消耗内存和耗时。流处理API允许在高性能和低内存配置之间做一点折中。 首先，需要确保请求是一个文件上传请求。这通过与传统API相同的静态方法实现：
// Check that we have a file upload request boolean isMultipart = ServletFileUpload.isMultipartContent(request);  现在需要解析请求获取成分项： ``` // Create a new file upload handler ServletFileUpload upload = new ServletFileUpload();
// Parse the request FileItemIterator iter = upload.getItemIterator(request); while (iter.hasNext()) { FileItemStream item = iter.next(); if (!item.isFormField()) { String name = item.getFieldName(); if(name==null) continue; InputStream stream = item.openStream(); System.out.println(&amp;ldquo;File field &amp;rdquo; + name + &amp;ldquo; with file name &amp;ldquo; + item.</description>
    </item>
    
  </channel>
</rss>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>[RabbitMQ] RabbitMQ笔记 - Mryqu's Notes</title><meta name=keywords content="mryqu,yandongqu,博客,程序员,架构师,笔记,技术,分享"><meta property="og:title" content="[RabbitMQ] RabbitMQ笔记"><meta property="og:site_name" content="Mryqu's Notes"><meta property="og:image" content="/img/author.jpg"><meta name=title content="[RabbitMQ] RabbitMQ笔记 - Mryqu's Notes"><meta name=description content="mryqu | yandongqu | 博客 | 软件 | 架构 | 技术"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href="/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet type=text/css><link href="/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel=stylesheet type=text/css><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css><script type=text/javascript id=hexo.configuration>var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0}</script></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class="site-meta custom-logo"><div class=custom-logo-site-title><a href=https://mryqu.github.io/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>Mryqu's Notes</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle></p></div><div class=site-nav-toggle><button>
<span class=btn-bar></span>
<span class=btn-bar></span>
<span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/tags/ rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class=menu-item><a href=/categories/ rel=section><i class="menu-item-icon fa fa-fw fa-categories"></i><br>分类</a></li><li class=menu-item><a href=/post/ rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span>
<input type=text id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://mryqu.github.io/post/rabbitmq_notes/ itemprop=url>[RabbitMQ] RabbitMQ笔记</a></h1><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2016-08-06">2016-08-06</time></span>
<span class=post-category>&nbsp; | &nbsp;
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a href=/categories/service+javaee itemprop=url rel=index><span itemprop=name>Service+JavaEE</span></a>
&nbsp;</span></span>
<span>&nbsp; | &nbsp;
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-visitors-count>732 字 ~4分钟</span></span></div></header><div class=post-body itemprop=articleBody><h3 id=rabbitmq介绍>RabbitMQ介绍</h3><p>RabbitMQ是基于高级消息队列协议的消息代理软件。RabiitMQ服务器由Erlang语言开发，客户端支持多种主流编程语言。
RabbitMQ由LShift和CohesiveFT合营公司Rabbit技术有限公司开发，在2010年4月被SpringSource收购，2013年5月归入Pivotal软件。
RabbitMQ项目包括：</p><ul><li>RabbitMQ交换服务器自身</li><li>用于HTTP、流文本定向消息协议(STOMP)和消息队列遥测传输协议(MQTT)的网关</li><li>Java、.NET Framework和Erlang语言的AMQP客户端库</li><li>支持定制插件的插件平台，内建插件集合为:<ul><li>Shovel插件，负责从一个消息代理（broker）向另一个移动/复制消息。</li><li>Federation插件，在消息代理之间有效共享消息(基于exchange这一级)</li><li>Management插件，监控和管理消息代理</li><li>STOMP插件，提供STOMP协议支持</li><li>MQTT插件，提供MQTT协议支持</li><li>LDAP插件，RabbitMQ通过外部LDAP服务器进行认证和授权</li></ul></li></ul><h3 id=在widnows平台安装rabbitmq>在Widnows平台安装RabbitMQ</h3><p>根据<a href=http://www.rabbitmq.com/install-windows.html>http://www.rabbitmq.com/install-windows.html</a>安装Erlang和RabbitMQ服务器，运行RabbitMQ安装程序时需要选择“<strong>Runas Administrator</strong>”，否则事后需要执行下列命令修正.erlang.cookie位置错误。</p><pre tabindex=0><code>copy /Y %SystemRoot%\.erlang.cookie %HOMEDRIVE%%HOMEPATH%
</code></pre><p>设置环境变量（及安装并启动RabbitMQ服务）</p><pre tabindex=0><code>SET　ERLANG_HOME=C:\tools\erl8.0
SET RABBITMQ_SERVER＝C:\tools\RabbitMQ_Server\rabbitmq_server-3.6.5
SET　RABBITMQ_BASE=C:\rabbitmq-data
ECHO []. &gt; C:\rabbitmq-data\rabbitmq.config
%RABBITMQ_SERVER%\sbin\rabbitmq-service.bat install
%RABBITMQ_SERVER%\sbin\rabbitmq-service.bat start
</code></pre><h4 id=安装管理插件>安装管理插件</h4><p>rabbitmq-management插件提供用于管理和监控RabbitMQ服务器的基于HTTP的API，以及基于浏览器的界面和一个控制台工具rabbitmqadmin。功能包括：</p><ul><li>声明、列举和删除exchange、queue、binding、用户、虚拟主机和权限。</li><li>监控队列长度、消息总速率和每通道速率、连接数据速率等。</li><li>发送和接受消息。</li><li>监控Erlang进程、文件描述符和内存使用。</li><li>导出/导入对象定义到JSON格式</li><li>强制关闭连接、清除队列。<img src=/images/2016/8/0026uWfMzy74vsO9YwJf5.jpg alt=[RabbitMQ] 在Widnows平台安装配置RabbitMQ></li></ul><p>重启RabbitMQ后登录http://guest:guest@localhost:15672/ ，即可见到管理页面。
<img src=/images/2016/8/0026uWfMzy74vxtT5yC2e.jpg alt=[RabbitMQ] 在Widnows平台安装配置RabbitMQ></p><h4 id=rabbitmqctl>rabbitmqctl</h4><p>通过rabbitmqctl创建一个管理员用户admin和一个对虚拟主机有读写权限的普通用户mryqu：
<img src=/images/2016/8/0026uWfMzy74wHf4qcEe8.png alt=[RabbitMQ] 在Widnows平台安装配置RabbitMQ>
自建管理员用户admin的默认用户guest的区别在于：guest仅能本机访问RabbitMQ，除非在rabbitmq.config增加loopback_users设置。</p><h4 id=使用http管理api>使用HTTP管理API</h4><p>将配置导出成JSON格式：</p><pre tabindex=0><code>curl -i -u guest:guest http://localhost:15672/api/definitions
</code></pre><p><img src=/images/2016/8/0026uWfMzy74wO9zc3s3e.jpg alt=[RabbitMQ] 在Widnows平台安装配置RabbitMQ></p><h4 id=激活其他插件>激活其他插件</h4><p>例如激活shovel插件：</p><pre tabindex=0><code>%RABBITMQ_SERVER%\sbin\rabbitmq-plugins.bat enable rabbitmq_shovel
%RABBITMQ_SERVER%\sbin\rabbitmq-plugins.bat enable rabbitmq_shovel_management
</code></pre><h4 id=测试rabbitmq>测试RabbitMQ</h4><p>使用<a href=https://spring.io/guides/gs/messaging-rabbitmq/>GETTING STARTED: Messaging with RabbitMQ</a> 中的代码即可，由于我想试验非本机访问RabbitMQ，因此添加了application.properties：</p><pre tabindex=0><code>spring.rabbitmq.host=rabbitmqServer
spring.rabbitmq.port=5672
spring.rabbitmq.username=mryqu
spring.rabbitmq.password=XXXXXXXXXXXXXX
</code></pre><h4 id=参考>参考</h4><p><a href=http://www.rabbitmq.com/install-windows.html>RabbitMQ - Installing on Windows</a><br><a href=http://www.rabbitmq.com/access-control.html>RabbitMQ - Access Control (Authentication, Authorisation)</a><br><a href=https://www.rabbitmq.com/windows-quirks.html>RabbitMQ - Windows Quirks</a><br><a href=https://www.rabbitmq.com/plugins.html>RabbitMQ - plugins</a><br><a href=https://www.rabbitmq.com/management.html>RabbitMQ - Management Plugin</a><br><a href=https://www.rabbitmq.com/shovel.html>RabbitMQ - Shovel plugin</a><br><a href=https://www.rabbitmq.com/man/rabbitmqctl.1.man.html>RabbitMQ - rabbitmqctl(1) manual page</a><br><a href=https://cdn.rawgit.com/rabbitmq/rabbitmq-management/rabbitmq_v3_6_5/priv/www/api/index.html>RabbitMQ Management HTTP API</a><br><a href=https://spring.io/guides/gs/messaging-rabbitmq/>GETTING STARTED: Messaging with RabbitMQ</a><br><a href=http://docs.spring.io/spring-amqp/reference/html/index.html>Spring AMQP</a><br><a href=https://lostechies.com/derekgreer/2012/03/05/rabbitmq-for-windows-introduction/>RabbitMQ for Windows: Introduction</a></p><h3 id=了解多个同名rabbitmq-server文件>了解多个同名rabbitmq-server文件</h3><p>安装完RabbitMQ后，查了查机器中多了六个rabbitmq-server文件，除了两个位于/usr/lib/rabbitmq目录下的可以不理，其他都有什么区别呢？
<img src=/images/2016/8/0026uWfMzy75aTu8gqF75.jpg alt=了解多个同名rabbitmq-server文件>
下面针对这四个文件进行一下介绍：</p><ul><li>/etc/init.d/rabbitmq-server：RabbitMQ服务器的开机自启动脚本</li><li>/usr/sbin/rabbitmq-server：init脚本所启动的主服务器程序脚本</li><li>/etc/logrotate.d/rabbitmq-server：logrotate是个十分有用的工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。该文件是针对rabbitmq-server的logrotate配置，默认情况下logrotate每周对/var/log/rabbitmq/下的log文件进行处理。</li><li>/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server：OCF指开放集群框架（Open Clustering Framework）。当使用<a href=https://www.rabbitmq.com/pacemaker.html>pacemaker</a> 配置RabbitMQHA时，作为OCF 资源代理脚本，用于操作和监控RabbitMQ节点。OCF 规范（尤其是与资源代理相关的部分）详见在<a href="http://www.opencf.org/cgi-bin/viewcvs.cgi/specs/ra/resource-agent-api.txt?rev=HEAD&content-type=text/vnd.viewcvs-markup">Open Clustering Framework Resource Agent API</a> 。</li></ul><h3 id=强制杀死rabbitmq进程>强制杀死RabbitMQ进程</h3><ul><li>首先，尝试使用init.d脚本优雅关闭RabbitMQ<pre tabindex=0><code>sudo /etc/init.d/rabbitmq-server stop
</code></pre></li><li>如果不成功的话，使用<pre tabindex=0><code>ps -eaf | grep erl
</code></pre>查看进程及父进程ID。输出第三列为父进程ID。找到仍是erlang进程（而不是启动进程的shell脚本）的第一个祖先进程，杀死它，这会同样终止其他子进程。<img src=/images/2016/8/0026uWfMzy75aISYaX577.jpg alt=[RabbitMQ] 强制杀死RabbitMQ进程>上述示例中进程1301为"/bin/sh -e/usr/lib/rabbitmq/bin/rabbitmq-server"，已经不是erlang进程了，所以杀死进程1587就可以了。对于目前的RabbitMQ版本，可直接使用：<pre tabindex=0><code>sudo pkill beam.smp
</code></pre></li></ul><h3 id=学习rabbitmq教程>学习RabbitMQ教程</h3><p>为了快速入门RabbitMQ，我主要学习了下列参考中的两个链接：RabbitMQ教程和SpringAMQP范例。这里对所学教程做一个小笔记。</p><h4 id=准备工作>准备工作</h4><p>由于我不打算跑本机上的RabbitMQ服务器，所有对代码稍有修改。</p><p>TutorialConfiguration.java</p><pre tabindex=0><code>public class TutorialConfiguration {
    public static final String HOST = &#34;mryqu-rabbitmq-server&#34;;
    public static final String USERNAME = &#34;mryqu&#34;;
    public static final String PASSWORD = &#34;mryqu-pwd&#34;;
}
</code></pre><p>对原有代码进行修改</p><pre tabindex=0><code>// factory.setHost(&#34;localhost&#34;);
factory.setHost(TutorialConfiguration.HOST);
factory.setUsername(TutorialConfiguration.USERNAME);
factory.setPassword(TutorialConfiguration.PASSWORD);
}
</code></pre><h4 id=rabbitmq函数>RabbitMQ函数</h4><p>发布方和消费方首先要创建连接，通过连接创建通道。通过通道也可以声明交换器，也可以直接声明队列。</p><ul><li>函数Exchange.DeclareOk exchangeDeclare(String exchange, Stringtype, boolean durable, boolean autoDelete, boolean internal, Maparguments)用于声明交换器。其中exchange为队列名；type为交换器类型，例如fanout、direct、header和topic，<strong>注意无法改变已存在交换器的类型</strong>；durable为true时为持久交换器，在服务器重启后仍将存在，默认为false；autoDelete为true时，当所有的消费者使用完交换器后，服务器会自动删除交换器。服务器必须为判断交换器未使用提供一个合理时延，起码允许客户端能够创建一个代理并将其与队列绑定。默认为false；internal为true时为内部交换器，客户端不能直接向其发布消息，默认为false。</li><li>函数Queue.DeclareOk queueDeclare(String queue, boolean durable,boolean exclusive, boolean autoDelete, Map arguments)用于声明队列，其中queue为队列名；durable为true时为持久队列，在服务器重启后仍将存在。默认为false；exclusive为true时为私有队列，仅在当前连接中可以访问队列，当连接关闭时删除该队列。默认为true；autoDelete为true时，当所有的消费者使用完队列后，服务器会自动删除队列。最后一个消费者可被显式取消或由于通道关闭而取消。如果队列从没有消费者，队列将不会被删除。应用可以像对普通队列一样使用Delete方法显式删除自动删除队列。默认为true。
函数Queue.BindOk queueBind(String queue, String exchange, StringroutingKey, Map arguments)用于通过路由关键字将队列与交换器进行绑定。</li></ul><p>函数void basicPublish(String exchange, String routingKey, booleanmandatory, boolean immediate, BasicProperties props, byte[]body)用于发布者发布消息。其中exchange为交换器名；routingKey为路由关键字，使用默认交换器及命名队列时可直接设为队列名；mandatory标志告知服务器当消息无法路由到队列时如何处理。如果标志被设上，服务器通过一个Return方法返回无法路由的消息。如果标志为空，服务器就仅丢弃消息。默认为false；immediate标志告知服务器当消息无法立即路由到队列消费者时如何处理。如果标志被设上，服务器通过一个Return方法返回无法路由的消息。如果标志为空，服务器就将消息放入队列，但不保证消息最终被消费。默认为false；props可设置下列子属性（可参考com.rabbitmq.client.MessageProperties进行了解）：</p><pre tabindex=0><code>public static class BasicProperties 
extends com.rabbitmq.client.impl.AMQBasicProperties {
  private String contentType; 
</code></pre><p>函数String basicConsume(String queue, boolean autoAck, StringconsumerTag, boolean noLocal, boolean exclusive, Map arguments,Consumercallback)用于消费者接收消息。其中queue为队列名；autoAck为true时，服务器当传递完消息即认为消息被确认。autoAck为false时，服务器必须等待显示确认；consumerTag为客户端生成的用于建立上下文的消费者标签。消费者标签仅对一个通道局部可见，因此两个客户端可以使用相同的消费者标签。如果该字段为空，则服务器将生成一个唯一标签。<font color=#FF0000><strong>如果一个标签已用于标识一个已有消费者，客户端不能在使用该函数时使用其值。</strong></font>标签仅对创建消费者所在的通道有效；noLocal为true的话，服务器不会将消息传递给发布消息的连接。默认为false；exclusive为true的话，请求排外消费者访问，即仅该消费者可以访问队列。客户端可能不会从已有活跃消费者的队列获得排外访问。默认为false。
消息消费者通过函数void basicQos(int prefetchSize, int prefetchCount,boolean global)指定服务质量。QoS可指定用于当前通道或连接的所有通道。机关QoS原则上施加于消息两端，当前仅对服务器有意义。客户端可以请求消息被提前发送，这样当客户端处理完一条消息，下一条消息已被收到本地，而不是此时从通道接收。预抓取可以提升性能。prefetchSize以字节为单位指定了预抓取窗口，服务器当消息大小等于小于prefetchSize（且满足其他预抓取限制）时提前发送消息。改值可以为0，即无限制。如果no-ack选项被设置时prefetchSize将被忽略。当客户端没有处理任何消息时，服务器必须忽略该选项（例如预抓取大小不限制向客户端发送单个消息的大小，仅当客户端仍有一或多个未应答消息时用于提前发送消息）。默认为0；prefetchCount为以消息个数指定预抓取窗口，可与prefetchSize联合使用。如果no-ack选项被设置时prefetchCount将被忽略。服务器可以提前发送少于prefetchCount个消息，而不能多发送；对于global，RabbitMQ重新解释了该字段。原规范指“默认QoS设置仅适用于当前通道。如果该字段被设置，将应用于整个连接”。而RabbitMQ将global=false解释为QoS设置仅应用于消费者（对通道的新消费者生效，已有消费者不受影响），global=true解释为QoS设置应用于通道。默认为false。</p><h4 id=教程一hello-world>教程一：&ldquo;Hello World!&rdquo;</h4><p><img src=/images/2016/8/0026uWfMzy74Q9fWBCbd3.png alt=[RabbitMQ] Hello RabbitMQ>
本教程中消息发布者和消费者直接通过一个命名队列“Hello”传递消息。</p><p>消息发布者：</p><pre tabindex=0><code>private final static String QUEUE_NAME = &#34;hello&#34;;
String message = &#34;Hello World!&#34;;
channel.basicPublish(&#34;&#34;, QUEUE_NAME, null, message.getBytes(&#34;UTF-8&#34;));
</code></pre><p>消息消费者：</p><pre tabindex=0><code>private final static String QUEUE_NAME = &#34;hello&#34;;
Consumer consumer = new DefaultConsumer(channel) {
  @Override
  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)
  throws IOException {
    String message = new String(body, &#34;UTF-8&#34;);
    System.out.println(&#34; [x] Received &#39;&#34; + message + &#34;&#39;&#34;);
  }
};
channel.basicConsume(QUEUE_NAME, true, consumer);
</code></pre><h4 id=教程二工作队列>教程二：工作队列</h4><p><img src=/images/2016/8/0026uWfMzy74Q9BA4ok04.png alt=[RabbitMQ] Hello RabbitMQ>
本教程跟教程一的区别主要有以下几点：</p><ul><li>教程一中消息发布者和消费者声明的队列为非持久性，而本教程中则为持久性；</li><li>教程一中消息发布者发布消息时未指定属性，而本教程中指定内容为纯文本、持久的消息</li><li>教程一中消息消费者消息时自动应答（autoAck或no-ack），而本教程中为非自动应答</li><li>本教程中消息消费者通过函数void basicQos(int prefetchSize)指定服务质量。由于前一条为非自动应答，因此本设置生效。预读取字节无限制，预读取消息个数为1，仅应用于消费者级别。</li><li>本教程中消息消费者通过Thread.sleep函数模拟耗时操作，并通过void basicAck(longdeliveryTag, boolean multiple)确认消息。</li><li>本教程中起了两个消息消费者，两个消息消费者交替处理发布者迅速发出的多个消息。</li></ul><h4 id=教程三订阅发布>教程三：订阅/发布</h4><p><img src=/images/2016/8/0026uWfMzy74WXfT7Zt57.png alt=[RabbitMQ] Hello RabbitMQ>
上一教程工作队列中每个任务仅发送给一个消费者，而本教程中一个消息可被发给多个消费者。实现主要通过一个fanout类型的交换器完成。</p><h4 id=教程四路由>教程四：路由</h4><p><img src=/images/2016/8/0026uWfMzy74WXIBxwm12.png alt=[RabbitMQ] Hello RabbitMQ>
上一教程中fanout类型的交换器将收到的消息广播给所有接收者，而本教程接收者将有选择地接收消息中感兴趣的那一部分。实现主要通过direct类型交换器完成，消费者将通道与交换器通过感兴趣的路由关键字绑定，发布者在使用basicPublish函数发布消息时需提供交换器、路由关键字和消息内容。</p><h4 id=教程五主题>教程五：主题</h4><p><img src=/images/2016/8/0026uWfMzy74WXyqOdf6d.png alt=[RabbitMQ] Hello RabbitMQ>
上一教程的限制在于不能基于多个条件进行路由。本教程通过topic类型交换器完成复杂的路由。其中路由关键字为由点做分界符的词列表，*代表一个词，#代表零或多个词。
例如路由关键词中第一个代表速度、第二个代表颜色，第三个代表物种：..。这里创建三个绑定：Q1与"*.orange.*&ldquo;关键词绑定，Q2与关键词&rdquo;*.*.rabbit"和"lazy.#&ldquo;绑定。其意义为：Q1对所有桔色动物感兴趣，Q2希望获得所有关于兔子及所有关于缓慢动物的消息。
路由关键词设为"quick.orange.rabbit"的消息将会传给两个队列。路由关键词设为"lazy.orange.elephant"的消息也将会传给两个队列。路由关键词设为"quick.orange.fox"将仅会传给第一个队列，路由关键词设为"lazy.brown.fox"将仅会传给第二个队列。路由关键词设为"lazy.pink.rabbit"将仅会传给第二个队列一次，即使它匹配了两个绑定。路由关键词设为"quick.brown.fox"的消息没有匹配任何绑定，因此会被丢弃。路由关键词设为"orange"或"quick.orange.male.rabbit"也不会匹配任何绑定，将被丢弃。而路由关键词设为"lazy.orange.male.rabbit"即使有四个词，也能匹配最后一个绑定，并传给第二个队列。
如果路由关键词不包含*和#字符，则等同direct类型。</p><h4 id=教程六rpc>教程六：RPC</h4><p><img src=/images/2016/8/0026uWfMzy74WXDJDeg38.png alt=[RabbitMQ] Hello RabbitMQ>
本教程借助消息属性中的replyTo和correlationId，完成响应与请求的匹配。</p><h4 id=参考-1>参考</h4><p><a href=http://www.rabbitmq.com/getstarted.html>RabbitMQ Tutorials</a><br><a href=https://github.com/spring-projects/spring-amqp-samples>Spring AMQP Samples</a><br><a href=https://spring.io/guides/gs/messaging-rabbitmq/>GETTING STARTED: Messaging with RabbitMQ</a><br><a href=https://spring.io/understanding/AMQP>Understanding AMQP</a><br><a href=http://docs.spring.io/spring-amqp/reference/html/index.html>Spring AMQP</a><br><a href=http://www.rabbitmq.com/amqp-0-9-1-reference.html>AMQP 0-9-1 Complete Reference Guide</a></p><h3 id=rabbitmqclustering>RabbitMQ Clustering</h3><p>RabbitMQ集群文档的介绍是：
一个RabbitMQ代理（broker）是一或多个Erlang节点的逻辑组合，每个节点运行RabbitMQ应用并共享用户、虚拟主机、队列、交换器、绑定和运行时参数。有时我们将节点集合称之为集群。
对RabbitMQ代理操作所需的所有数据/状态都会在所有节点上复制。唯一的例外是消息队列，默认存在于创建队列的节点上，但是对所有其他节点可见并可访问。集群内节点通过主机名互相通信，所以这些主机名必须能被集群内所有节点解析。</p><h4 id=在ubuntu上安装rabbitmq>在Ubuntu上安装RabbitMQ</h4><p>我在三台Ubuntu服务器上安装了RabbitMQ，分别是node50064，node50069和node51054。</p><ul><li>执行下列命令将APT仓库添加到/etc/apt/sources.list.d:<pre tabindex=0><code>echo &#39;deb http://www.rabbitmq.com/debian/ testing main&#39; |
      sudo tee /etc/apt/sources.list.d/rabbitmq.list
</code></pre></li><li>(可选地)为了避免未签名包告警，使用 apt-key将RabbitMQ网站的公钥添加到信赖密钥列表：<pre tabindex=0><code>wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc |
      sudo apt-key add -
</code></pre></li><li>执行下列命令更新包列表：<pre tabindex=0><code>sudo apt-get update
</code></pre></li><li>安装rabbitmq-server包：<pre tabindex=0><code>sudo apt-get install rabbitmq-server
</code></pre></li></ul><p>配置RabbitMQ</p><ul><li>修改/etc/rabbitmq/enabled_plugins使能管理插件：<pre tabindex=0><code>[rabbitmq_management].
</code></pre></li><li>修改/etc/default/rabbitmq-server，增大每用户可打开文件数（我的系统不使用systemd，无需修改/etc/systemd/system/rabbitmq-server.service.d/limits.conf）：<pre tabindex=0><code>ulimit -S -n 4096
</code></pre></li><li>修改/etc/rabbitmq/rabbitmq-env.conf，激活长主机名并使用每个主机的完整域名作为本地节点名：<pre tabindex=0><code>USE_LONGNAME=true
NODENAME=rabbit@`env hostname -f`
</code></pre></li></ul><p>关闭RabbitMQ：</p><pre tabindex=0><code>sudo /etc/init.d/rabbitmq-server stop
</code></pre><h4 id=配置rabbitmq集群>配置RabbitMQ集群</h4><p>首先启动node50064上的RabbitMQ（注：会有告警，可忽略。-detached选项就会导致PID不写入PID文件。）：</p><pre tabindex=0><code>sudo rabbitmq-server -detached
</code></pre><p>RabbitMQ节点和CLI工具(例如rabbitmqctl)使用cookie来判断节点间是否可以通信。两个能够通信的节点必须拥有相同的共享密文，称之为Erlangcookie。集群中所有节点必须拥有相同cookie。必须在node50069和node51054关闭RabbitMQ的情况下，从node50064将其cookie复制到node50069（对node51054也做相同操作）：
<img src=/images/2016/8/0026uWfMzy754DMOLh4ee.jpg alt=[RabbitMQ] Hello RabbitMQ Clustering> 更省事的方式，是在node50069和node51054没有安装RabbitMQ之前就将node50064上的cookie复制过来，这样node50069和node51054上的erlang节点就不会自己生成cookie了。</p><p>手工配置集群：</p><pre tabindex=0><code>ubuntu@node50069:~$sudo rabbitmq-server -detached
ubuntu@node50069:~$sudo rabbitmqctl stop_app
ubuntu@node50069:~$sudo rabbitmqctl join_cluster rabbit@node50064.mryqu.com
ubuntu@node50069:~$sudo rabbitmqctl start_app

ubuntu@node51054:~$sudo rabbitmq-server -detached
ubuntu@node51054:~$sudo rabbitmqctl stop_app
ubuntu@node51054:~$sudo rabbitmqctl join_cluster rabbit@node50064.mryqu.com
ubuntu@node51054:~$sudo rabbitmqctl start_app
</code></pre><p>验证集群状态：<img src=/images/2016/8/0026uWfMzy75aNJHmCqfe.png alt=[RabbitMQ] Hello RabbitMQ Clustering>
管理UI：<img src=/images/2016/8/0026uWfMzy75aQdNFo03c.jpg alt=[RabbitMQ] Hello RabbitMQ Clustering></p><h4 id=参考-2>参考</h4><p><a href=http://www.rabbitmq.com/clustering.html>RabbitMQ Clustering Guide</a><br><a href=http://www.rabbitmq.com/install-debian.html>Installing RabbitMQ on Debian / Ubuntu</a><br><a href=/post/rabbitmq_hello_rabbitmq>Hello RabbitMQ</a></p><h3 id=autorecoveringconnection在连接恢复后才调用shutdownlistener>AutorecoveringConnection在连接恢复后才调用ShutdownListener</h3><p>想玩一玩RabbitMQ中的ShutdownListener和RecoveryListener，又不想写自己的重连接逻辑，所以使用了ConnectionFactory类的setAutomaticRecoveryEnabled方法让其自动恢复连接。代码如下：</p><pre tabindex=0><code>package com.yqu.rabbitmq;

import com.rabbitmq.client.*;

import java.io.IOException;

public class AutoRecoveryRecv {

  private final static String QUEUE_NAME = &#34;hello&#34;;

  public static void main(String[] argv) throws Exception {
    try {
      ConnectionFactory factory = new ConnectionFactory();
      factory.setHost(ConnectionFactoryConfiguration.HOST);
      factory.setUsername(ConnectionFactoryConfiguration.USERNAME);
      factory.setPassword(ConnectionFactoryConfiguration.PASSWORD);
      factory.setAutomaticRecoveryEnabled(true);
      factory.setNetworkRecoveryInterval(10000);
      Connection connection = factory.newConnection();
      connection.addShutdownListener(new ShutdownListener() {
        @Override
        public void shutdownCompleted(ShutdownSignalException cause)
        {

          String hardError = &#34;&#34;;
          String applInit = &#34;&#34;;

          if (cause.isHardError()) {
            hardError = &#34;connection&#34;;
          } else {
            hardError = &#34;channel&#34;;
          }

          if (cause.isInitiatedByApplication()) {
            applInit = &#34;application&#34;;
          } else {
            applInit = &#34;broker&#34;;
          }

          System.out.println(&#34;Connectivity to MQ has failed.  It was caused by &#34;
                  + applInit + &#34; at the &#34; + hardError
                  + &#34; level.  Reason received &#34; + cause.getReason());
        }
      });
      ((Recoverable)connection).addRecoveryListener(new RecoveryListener() {
        @Override
        public void handleRecovery(Recoverable recoverable) {
          if( recoverable instanceof Connection ) {
            System.out.println(&#34;Connection was recovered.&#34;);
          } else if ( recoverable instanceof Channel ) {
            int channelNumber = ((Channel) recoverable).getChannelNumber();
            System.out.println( &#34;Connection to channel #&#34; 
                   + channelNumber + &#34; was recovered.&#34; );
          }
        }
      });
      Channel channel = connection.createChannel();

      channel.queueDeclare(QUEUE_NAME, false, false, false, null);
      System.out.println(&#34; [*] Waiting for messages. To exit press CTRL+C&#34;);

      Consumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope,
                                   AMQP.BasicProperties properties, byte[] body)
                throws IOException {
          String message = new String(body, &#34;UTF-8&#34;);
          System.out.println(&#34; [x] Received &#39;&#34; + message + &#34;&#39;&#34;);
        }
      };
      channel.basicConsume(QUEUE_NAME, true, consumer);
    }
    catch(Throwable t) {
      t.printStackTrace();
    }
  }
}
</code></pre><p>重启了RabbitMQ所在的服务器，然后获得下列日志，显示连接已修复，然后才调用ShutdownListener显示连接关闭信息：<img src=/images/2016/8/0026uWfMzy75YP4pM7I36.jpg alt=[RabbitMQ] AutorecoveringConnection在连接恢复后才调用ShutdownListener>
为什么会这样？下面就开始我的解密之旅！
首先看一下ShutdownNotifier接口的层次图，Connection下共有三个子孙类，尚不确定在我的测试里是哪一个？
<img src=/images/2016/8/0026uWfMzy75YSEzBzG60.png alt=[RabbitMQ] AutorecoveringConnection在连接恢复后才调用ShutdownListener> 看一下com.rabbitmq.client.ConnectionFactory类newConnection方法实现，豁然开朗！对于ConnectionFactory类，如果automaticRecoveryEnabled被设置则创建AutorecoveringConnection，否则创建AMQConnection。而RecoveryAwareAMQConnectionFactory才会创建RecoveryAwareAMQConnection。
AutorecoveringConnection类init方法会调用addAutomaticRecoveryListener方法，addAutomaticRecoveryListener方法会添加一个ShutdownListener类实例automaticRecoveryListener到列表shutdownListeners，而我创建的ShutdownListener类实例是列表shutdownListeners中的第二个元素。
参看下面堆栈信息，ShutdownNotifierComponent类的notifyListeners会遍历所有shutdownListeners列表所有监听器，第一个关闭监听器实例automaticRecoveryListener会进行连接修复并通知RecoveryListener，然后才到我的关闭监听器打印关闭信息。</p><pre tabindex=0><code>at AutoRecoveryRecv$2.handleRecovery(AutoRecoveryRecv.
at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.notifyRecoveryListeners(AutorecoveringConnection.
at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.beginAutomaticRecovery(AutorecoveringConnection.
- locked &lt;0x30d&gt; (a com.rabbitmq.client.impl.recovery.AutorecoveringConnection)
at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.access$000(AutorecoveringConnection.
at com.rabbitmq.client.impl.recovery.AutorecoveringConnection$1.shutdownCompleted(AutorecoveringConnection.
at com.rabbitmq.client.impl.ShutdownNotifierComponent.notifyListeners(ShutdownNotifierComponent.
at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.
at 
</code></pre><p><a href=https://github.com/rabbitmq/rabbitmq-java-client>rabbitmq/rabbitmq-java-client</a>项目在https://github.com/rabbitmq/rabbitmq-java-client/pull/136 修正了这个错误，先通知所有ShutdownListener再尝试自动修复连接。但是在我所用的amqp-client-3.6.5.jar还没有包含这一修改。</p></div><footer class=post-footer><div class=post-nav><div style="border:1px dashed #e0e0e0;padding:10px;background-color:#fffeee;background-repeat:no-repeat;background-attachment:scroll;background-position:1%;-moz-background-size:auto auto;-moz-background-clip:-moz-initial;-moz-background-origin:-moz-initial;-moz-background-inline-policy:-moz-initial"><div><p style=margin-top:0>标题：[RabbitMQ] RabbitMQ笔记<br>作者：<a target=_blank href=/>mryqu</a><br>声明： 本博客所有文章除特别声明外，均采用 <a href=http://creativecommons.org/licenses/by-nc-sa/3.0/cn/>CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div></div><div class=clear></div></div><div class=post-tags><a href=/tags/rabbitmq rel=tag title=rabbitmq>#rabbitmq#</a>
<a href=/tags/queue rel=tag title=queue>#queue#</a>
<a href=/tags/exchange rel=tag title=exchange>#exchange#</a>
<a href=/tags/route rel=tag title=route>#route#</a>
<a href=/tags/topic rel=tag title=topic>#topic#</a>
<a href=/tags/clustering rel=tag title=clustering>#clustering#</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://mryqu.github.io/post/facebook_user_token/ rel=next title=获取Facebook User Token><i class="fa fa-chevron-left"></i> 获取Facebook User Token</a></div><div class="post-nav-prev post-nav-item"><a href=https://mryqu.github.io/post/spark_spark%E5%92%8Chive%E9%9B%86%E6%88%90/ rel=prev title=[Spark]Spark和Hive集成>[Spark]Spark和Hive集成 <i class="fa fa-chevron-right"></i></a></div></div><div class=comments id=comments><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://mryqu.github.io/post/rabbitmq_notes/",this.page.identifier="https://mryqu.github.io/post/rabbitmq_notes/"};(function(){var e=document,t=e.createElement("script");t.src="//mryqu.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/author.jpg alt><p class=site-author-name itemprop=name></p><p class="site-description motion-element" itemprop=description>Programmer & Architect</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>663</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>28</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>1472</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/mryqu target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://twitter.com/yandongqu target=_blank title=Twitter><i class="fa fa-fw fa-twitter"></i>
Twitter</a></span>
<span class=links-of-author-item><a href=https://www.facebook.com/yandongqu target=_blank title="FB Page"><i class="fa fa-fw fa-facebook"></i>
FB Page</a></span></div><div class="links-of-blogroll motion-element inline"><script type=text/javascript src="//rf.revolvermaps.com/0/0/8.js?i=01h16xrlw6m&m=0&s=220&c=ff0000&cr1=ffffff&f=arial&l=33&bv=35" async></script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#rabbitmq介绍>RabbitMQ介绍</a></li><li><a href=#在widnows平台安装rabbitmq>在Widnows平台安装RabbitMQ</a></li><li><a href=#了解多个同名rabbitmq-server文件>了解多个同名rabbitmq-server文件</a></li><li><a href=#强制杀死rabbitmq进程>强制杀死RabbitMQ进程</a></li><li><a href=#学习rabbitmq教程>学习RabbitMQ教程</a></li><li><a href=#rabbitmqclustering>RabbitMQ Clustering</a></li><li><a href=#autorecoveringconnection在连接恢复后才调用shutdownlistener>AutorecoveringConnection在连接恢复后才调用ShutdownListener</a></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span itemprop=copyrightYear>&copy;
2009 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>Mryqu's Notes</span></div><div class=powered-by>Powered by - <a class=theme-link href=http://gohugo.io target=_blank title=hugo>Hugo v0.105.0</a></div><div class=theme-info>Theme by - <a class=theme-link href=https://github.com/xtfly/hugo-theme-next target=_blank>NexT</a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript>Object.prototype.toString.call(window.Promise)!=="[object Function]"&&(window.Promise=null)</script><script type=text/javascript src="/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type=text/javascript src="/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
<script type=text/javascript src="/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type=text/javascript src="/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type=text/javascript src="/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
<script src="/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<script type=text/javascript src=/js/utils.js></script>
<script type=text/javascript src=/js/motion.js></script>
<script type=text/javascript src=/js/affix.js></script>
<script type=text/javascript src=/js/schemes/pisces.js></script>
<script type=text/javascript src=/js/scrollspy.js></script>
<script type=text/javascript src=/js/post-details.js></script>
<script type=text/javascript src=/js/toc.js></script>
<script type=text/javascript src=/js/bootstrap.js></script>
<script type=text/javascript src=/js/search.js></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script></body></html>